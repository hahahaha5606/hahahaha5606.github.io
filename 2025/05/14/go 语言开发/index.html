<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>go语言开发 | 藕片种植基地</title><meta name="author" content="胖胖大藕片"><meta name="copyright" content="胖胖大藕片"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、简介与环境搭建
 Go 即 Golang，是 Google 公司 2009 年 11 月正式对外公开的一门编程语言，其特点在于“简洁、高效”。
 Go 语言不仅拥有静态编译语言的安全和高性能，而且又达到了动态语言开发速度和易维护性。有人形容 Go 语言：Go = C + Python , 说明 Go 语言既有 C 语言程序的运行速度，又能达到 Python 语言的快速开发。B站、Docker(">
<meta property="og:type" content="article">
<meta property="og:title" content="go语言开发">
<meta property="og:url" content="http://example.com/2025/05/14/go%20%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/index.html">
<meta property="og:site_name" content="藕片种植基地">
<meta property="og:description" content="一、简介与环境搭建
 Go 即 Golang，是 Google 公司 2009 年 11 月正式对外公开的一门编程语言，其特点在于“简洁、高效”。
 Go 语言不仅拥有静态编译语言的安全和高性能，而且又达到了动态语言开发速度和易维护性。有人形容 Go 语言：Go = C + Python , 说明 Go 语言既有 C 语言程序的运行速度，又能达到 Python 语言的快速开发。B站、Docker(">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hahahaha5606/blogImage/post_img/20231125235054.jpg">
<meta property="article:published_time" content="2025-05-14T05:44:45.692Z">
<meta property="article:modified_time" content="2025-06-02T11:49:36.074Z">
<meta property="article:author" content="胖胖大藕片">
<meta property="article:tag" content="代码箱">
<meta property="article:tag" content="编码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/hahahaha5606/blogImage/post_img/20231125235054.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/05/14/go%20%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'go语言开发',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-02 19:49:36'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/transpancy.css"><link rel="stylesheet" href="/css/showAppreciation.css"><link rel="stylesheet" href="/css/ancientPoetry.css"><link rel="stylesheet" href="/css/mycss.css"><style>#article-container.post-content h1:before, h2:before, h3:before, h4:before, h5:before, h6:before { -webkit-animation: avatar_turn_around 1s linear infinite; -moz-animation: avatar_turn_around 1s linear infinite; -o-animation: avatar_turn_around 1s linear infinite; -ms-animation: avatar_turn_around 1s linear infinite; animation: avatar_turn_around 1s linear infinite; }</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/macblack.css"><link rel="stylesheet" href="/css/datu.css"><link rel="stylesheet" href="/css/aplayer.css"><link rel="stylesheet" href="/css/myvaline.css"><link rel="stylesheet" href="/css/music.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/firacode@6.2.0/distr/fira_code.css"><link rel="stylesheet" href="/css/cloud.css"><link rel="stylesheet" href="/css/maoboli_bg.css"><link rel="stylesheet" type="text/css" href="/css/perfectscrollbar.css"><link rel="stylesheet" type="text/css" href="/css/szgotop.css"></head><body><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css">
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="/css/loading-bar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="an_music_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/load1.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">80</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-space-shuttle"></i><span> 游戏</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/2048/"><i class="fa-fw fa fa-cubes"></i><span> 2048</span></a></li><li><a class="site-page child" href="/catch_cat/"><i class="fa-fw fa fa-cat"></i><span> 抓猫猫</span></a></li><li><a class="site-page child" href="/flower/"><i class="fa-fw fa fa-eye"></i><span> 花花世界迷人眼</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/Message/"><i class="fa-fw fa fa-paper-plane"></i><span> 打卡</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/hahahaha5606/blogImage/post_img/20231125235054.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="藕片种植基地"><span class="site-name">藕片种植基地</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-space-shuttle"></i><span> 游戏</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/2048/"><i class="fa-fw fa fa-cubes"></i><span> 2048</span></a></li><li><a class="site-page child" href="/catch_cat/"><i class="fa-fw fa fa-cat"></i><span> 抓猫猫</span></a></li><li><a class="site-page child" href="/flower/"><i class="fa-fw fa fa-eye"></i><span> 花花世界迷人眼</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/Message/"><i class="fa-fw fa fa-paper-plane"></i><span> 打卡</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">go语言开发</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-14T05:44:45.692Z" title="发表于 2025-05-14 13:44:45">2025-05-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-02T11:49:36.074Z" title="更新于 2025-06-02 19:49:36">2025-06-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">52.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>220分钟</span></span><span class="post-meta-separator">|</span><span class="leancloud_visitors" id="/2025/05/14/go%20%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/" data-flag-title="go语言开发"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span class="leancloud-visitors-count"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2025/05/14/go%20%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2025/05/14/go%20%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url('https://cdn.jsdelivr.net/gh/hahahaha5606/blogImage/post_img/20231125235054.jpg');"></div><article class="post-content" id="article-container"><h1 id="一简介与环境搭建">一、简介与环境搭建</h1>
<p>Go 即 Golang，是 Google 公司 2009 年 11 月正式对外公开的一门编程语言，其特点在于“简洁、高效”。</p>
<p>Go 语言不仅拥有静态编译语言的安全和高性能，而且又达到了动态语言开发速度和易维护性。有人形容 Go 语言：<strong>Go = C + Python</strong> , 说明 Go 语言既有 C 语言程序的运行速度，又能达到 Python 语言的快速开发。B站、Docker(基于 lxc 的一个虚拟打包工具，能够实现 PAAS 平台的组建)等均是基于 Go 语言开发的。</p>
<p><strong>在Win上的配置：</strong></p>
<p>Go 官网下载地址：https://golang.org/dl/</p>
<p>Go 官方镜像站（推荐）：https://golang.google.cn/dl/</p>
<p>点击下载安装后，在终端输入<code>go version</code> 验证是否安装成功，输入<code>go env</code>查看 Go 环境。推荐使用 VC Code 软件进行开发，开发时安装 Go 语言的插件（插件安装失败参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41065919/article/details/107710144">一招完美解决vscode安装go插件失败问题-CSDN博客</a>）。</p>
<blockquote>
<p>在 Golang1.11 版本之前如果我们要自定义包的话必须把项目放在 GOPATH 目录。Go1.11 版本之后无需手动配置环境变量，使用 go mod 管理项目，也不需要非得把项目放到 GOPATH 指定目录下，你可以在你磁盘的任何位置新建一个项目 , Go1.13 以后可以彻底不要 GOPATH了。</p>
</blockquote>
<h1 id="二基本语法">二、基本语法</h1>
<blockquote>
<p><font color="black">Go 语言中使用双斜杠 “// 注释内容” 行注释，“/* 注释内容 */” 块注释。【Ctrl + /】键快速注释。</font></p>
<p><font color="#ef042a"><strong>新建 Go 项目后需要在终端初始化：<code>go mod init ProjectName</code></strong> </font>。初始化后文件夹下会出现一个 <code>go.mod</code> 文件夹。</p>
<p><strong><font color="#985fff"> Go 语言中，</font></strong></p>
<ul>
<li><p><font color="#985fff"><strong>每个运行的源文件都必须以 <code>package 包名</code> 声明开头</strong></font>，这条语句声明当前源文件属于哪个包，而且这个声明必须是文件中的第一个非注释语句。</p></li>
<li><p><font color="#985fff"><strong>每条 <code>import</code> 语句必须放在包声明之后，其他声明之前</strong></font>。如果导入多个包，需要用括号括起来如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ( </span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"math"</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><font color="#985fff"><strong>所有函数调用必须在函数内部。</strong></font></p></li>
<li><p>运行 Go 文件，可在终端输入：<code>go run .\main.go</code></p></li>
</ul>
</blockquote>
<p><strong>Go 语言代码风格</strong></p>
<p>1、代码每一行结束后不用写分号（ ;）</p>
<p>2、Go 语言程序员推荐使用驼峰式命名，当名字有几个单词组成的时优先使用大小写分隔。</p>
<p>3、可以使用命令 <code>go fmt ./...</code> 格式化当前项目下的所有 Go 源文件，使得代码风格保持一致。</p>
<h2 id="变量声明">1.变量声明</h2>
<blockquote>
<p>Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。Go 语言中关键字和保留字都不能用作变量名。</p>
<p>Go 语言中</p>
<ul>
<li><p>变量需要声明后才能使用，<strong>同一作用域内不支持重复声明</strong>。</p></li>
<li><p><strong>全局变量声明后如果不赋值，变量值将被设置为默认值</strong>。整型和浮点型变量的默认值为 0。 字符串变量的默认值为空字符串。 布尔型变量默认为 false。 切片、函数、指针变量的默认为 nil。且<strong>全局变量首次赋值（初始化）后只能在函数中修改变量值</strong>。</p></li>
<li><p><strong>如果局部变量和全局变量重名，优先访问局部变量。</strong></p></li>
<li><p>在 Go 语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间（new / make 函数），否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。</p></li>
</ul>
<p><strong>关于nil</strong> ：当你声明了一个变量 , 但却还并没有赋值时 , golang 中会自动给你的变量赋值一个默认零值。nil 即是每种类型对应的零值。</p>
<p></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">bool</span> -&gt; <span class="literal">false</span></span><br><span class="line">numbers -&gt; <span class="number">0</span></span><br><span class="line"><span class="type">string</span>-&gt; <span class="string">""</span> </span><br><span class="line">pointers -&gt; <span class="literal">nil</span></span><br><span class="line">slices -&gt; <span class="literal">nil</span></span><br><span class="line">maps -&gt; <span class="literal">nil</span></span><br><span class="line">channels -&gt; <span class="literal">nil</span></span><br><span class="line">functions -&gt; <span class="literal">nil</span></span><br><span class="line">interfaces -&gt; <span class="literal">nil</span></span><br></pre></td></tr></tbody></table></figure><p></p>
</blockquote>
<ul>
<li><strong>全局变量定义</strong>：<code>var 变量名 类型 = 值</code> 。这种方式可以同时初始化值，但是代码较长。如果将类型省略，变量类型将由编译器自动推断。</li>
<li><strong>局部变量定义</strong>：<code>变量名 := 值</code> 。变量类型由编译器自动推断，只能在函数内部使用，更加简洁。<font color="#985fff"><strong>注意，Go 语言中，声明但未使用的局部变量会导致编译错误！</strong></font>。</li>
<li><strong>连续多个变量定义</strong>：见代码。</li>
</ul>
<p>注：如果声明了变量，但不想使用改变量，可以使用下划线 “_” 为其命名来忽略它（该方法不能用于局部变量，局部变量声明后必须被使用）。</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">代码</button><button type="button" class="tab " data-href="样例-2">预览</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//变量声明</span></span><br><span class="line"><span class="keyword">var</span> varName <span class="type">string</span> = <span class="string">"zhangsan"</span> <span class="comment">//声明全局变量</span></span><br><span class="line"><span class="keyword">var</span> _ = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//连续声明多个全局变量法1</span></span><br><span class="line"><span class="keyword">var</span> varName3, varName4 = <span class="string">"zhangsan"</span>, <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> varName5, varName6 <span class="type">string</span> = <span class="string">"lisi"</span>, <span class="string">"wangwu"</span></span><br><span class="line"><span class="keyword">var</span> varName7 <span class="type">int</span>	<span class="comment">//varName7将被初始化为0</span></span><br><span class="line"><span class="comment">//连续声明多个全局变量法2</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	varName8, varName9 <span class="type">string</span>  = <span class="string">"a"</span>, <span class="string">"b"</span></span><br><span class="line">	varName10          <span class="type">int</span>     = <span class="number">2</span></span><br><span class="line">	varName11          <span class="type">bool</span>    = <span class="literal">false</span></span><br><span class="line">	varName12          <span class="type">float32</span> = <span class="number">888</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LocalVar</span><span class="params">()</span></span> {</span><br><span class="line">	localVar := <span class="number">10</span> <span class="comment">//声明局部变量</span></span><br><span class="line">	fmt.Println(localVar)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	fmt.Println(varName)</span><br><span class="line">	LocalVar()</span><br><span class="line"></span><br><span class="line">	fmt.Println(varName7)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//连续声明多个局部变量法1</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		a, d <span class="type">string</span></span><br><span class="line">		b    <span class="type">int</span></span><br><span class="line">		c    <span class="type">bool</span></span><br><span class="line">		f    <span class="type">float32</span> = <span class="number">888</span></span><br><span class="line">	)</span><br><span class="line">	a, d = <span class="string">"张三"</span>, <span class="string">"李四"</span></span><br><span class="line">	b = <span class="number">10</span></span><br><span class="line">	c = <span class="literal">true</span></span><br><span class="line">	fmt.Println(a, b, c, d, f)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//连续声明多个局部变量法2</span></span><br><span class="line">	m1, m2, m3 := <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span></span><br><span class="line">	fmt.Println(m1, m2, m3)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">zhangsan</span><br><span class="line">10</span><br><span class="line">0</span><br><span class="line">张三 10 true 李四 888</span><br><span class="line">10 20 30</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h2 id="常量声明">2.常量声明</h2>
<blockquote>
<p>常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。常量的声明和变量声明非常类似，只是把 var 换成了 const，<strong>常量在定义的时候必须赋值</strong>。</p>
</blockquote>
<ul>
<li>定义常量：<code>const 常量名 = 常量值</code></li>
</ul>
<p><strong><font color="#985fff">iota</font> 是 Go 语言的常量计数器，只能在常量的表达式中使用</strong>。iota 在 const 关键字出现时将被重置为 0(const 内部的第一行之前)，<strong>const 中每新增一个常量声明将使 iota 计数一次</strong>(iota 可理解为 const 语句块中的行索引)。</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">代码</button><button type="button" class="tab " data-href="样例-2">预览</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">2.7182</span></span><br><span class="line"><span class="keyword">const</span> Pi = math.Pi</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时定义多个常量法1</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	n1 = <span class="number">100</span></span><br><span class="line">	n2 <span class="comment">//同时声明多个常量时，如果省略了值则表示和上面一行的值相同</span></span><br><span class="line">	n3</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时定义多个常量法2</span></span><br><span class="line"><span class="keyword">const</span> m1, m2, m3 = <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span> <span class="comment">//这样写，不可以省略重复值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	b1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">	b2 = <span class="literal">iota</span> <span class="comment">//1</span></span><br><span class="line">	b3 = b2   <span class="comment">//1</span></span><br><span class="line">	_</span><br><span class="line">	b5 = <span class="literal">iota</span> <span class="comment">//4 注意，这里是4，不是3！</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> c = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	fmt.Println(pi)</span><br><span class="line">	fmt.Println(Pi)</span><br><span class="line">	fmt.Println(n1, n2, n3)</span><br><span class="line">	fmt.Println(m1, m2, m3)</span><br><span class="line"></span><br><span class="line">	fmt.Println(a, b1, b2, b3, b5, c) <span class="comment">// 0 0 1 1 4 1</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">3.1415</span><br><span class="line">3.141592653589793</span><br><span class="line">100 100 100</span><br><span class="line">100 100 100</span><br><span class="line">0 0 1 1 4 1</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h2 id="打印语句">3.打印语句</h2>
<p>Go 中要打印一个值需要引入 fmt 包。fmt 包中常见的打印语句有以下三种：</p>
<ul>
<li><strong>Println</strong> ：一次输入多个值时，中间自动用空格隔开。如果连续使用多次 Println 语句，会自动换行。</li>
<li><strong>Print</strong> ：既不会自动用空格隔开，也不会自动换行。少用。</li>
<li><strong>Printf</strong> ：格式化输出，可用<a target="_blank" rel="noopener" href="https://blog.csdn.net/demored/article/details/123988566">占位符</a>设置输出样式。</li>
</ul>
<blockquote>
<p><strong>常用占位符</strong></p>
<table class="table-2 table-2-sm">
<thead class="thead-dark">
<tr>
<th width="15%">
占位符
</th>
<th align="center">
含义
</th>
</tr>
</thead>
<tbody>
<tr class="alert" role="alert">
<th scope="row" width="15%">
%d
</th>
<td align="center">
输出整型格式（十进制）
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
%v
</th>
<td align="center">
输出变量值 value
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
%#v
</th>
<td align="center">
以 Go 语法详细输出值，通常会显示类型信息和内部结构，让输出更具可读性和调试价值
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
%T
</th>
<td align="center">
输出变量类型 Type
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
%b
</th>
<td align="center">
输出变量的二进制数
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
%o
</th>
<td align="center">
输出变量的八进制
</td>
</tr><tr class="alert" role="alert">
<th scope="row">
%x
</th>
<td align="center">
输出变量的十六进制（小写）
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
%X
</th>
<td align="center">
输出变量的十六进制（大写）
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
%c
</th>
<td align="center">
以字符/byte形式输出（输出Unicode码对应的字符）
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
%t
</th>
<td align="center">
以bool形式输出
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
%p
</th>
<td align="center">
输出十六进制形式的变量地址
</td>
</tr>
</tbody>
</table>
</blockquote>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">代码</button><button type="button" class="tab " data-href="样例-2">预览</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">//打印数值</span></span><br><span class="line">	<span class="comment">//一次输入多个值的时候 Println 中间有空格 Print 没有</span></span><br><span class="line">	fmt.Println(<span class="string">"go"</span>, <span class="string">"python"</span>, <span class="string">"php"</span>, <span class="string">"javascript"</span>) <span class="comment">// go python php javascript</span></span><br><span class="line">	fmt.Print(<span class="string">"go"</span>, <span class="string">"python"</span>, <span class="string">"php"</span>, <span class="string">"javascript"</span>)   <span class="comment">// gopythonphpjavascript</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"world"</span>)</span><br><span class="line">	fmt.Print(<span class="string">"hello"</span>)</span><br><span class="line">	fmt.Print(<span class="string">"world"</span>)</span><br><span class="line"></span><br><span class="line">	a := <span class="number">10</span></span><br><span class="line">	b := <span class="number">20</span></span><br><span class="line">	c := <span class="number">30</span></span><br><span class="line">	fmt.Println(<span class="string">"a="</span>, a, <span class="string">",b="</span>, b, <span class="string">",c="</span>, c) <span class="comment">//a= 10 ,b= 20 ,c= 30</span></span><br><span class="line">	fmt.Printf(<span class="string">"a=%d,b=%d,c=%d"</span>, a, b, c)    <span class="comment">//a=10,b=20,c=30</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">go python php javascript</span><br><span class="line">gopythonphpjavascripthello</span><br><span class="line">world</span><br><span class="line">helloworlda= 10 ,b= 20 ,c= 30</span><br><span class="line">a=10,b=20,c=30</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h2 id="数据类型">4.数据类型</h2>
<blockquote>
<p>字节也叫 Byte，是计算机数据的基本存储单位。</p>
<p>8bit(位)=1Byte(字节) 。</p>
<p>1024Byte(字节)=1KB 1024KB=1MB 1024MB=1GB 1024GB=1TB 。</p>
<p>在电脑里一个中文字是占两个字节的。</p>
</blockquote>
<p>Go 中的数据类型可以分为<strong>基本数据类型</strong>（整型、浮点型、布尔型 和 字符串）和<strong>复合数据类型</strong>（数组、切片、结构体、函数、map、通道channel 和 接口等）。</p>
<p><strong>查看变量占用的字节数</strong>：<code>unsafe.Sizeof(变量名)</code></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">int8</span> = <span class="number">10</span></span><br><span class="line">	fmt.Printf(<span class="string">"a 的类型为%T， 占用的字节数为 %d"</span>, a, unsafe.Sizeof(a)) <span class="comment">//a 的类型为int8， 占用的字节数为 1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><font color="#4eb434"><strong>数字字面量语法</strong></font>（Number literals syntax）</p>
<p>数字字面量语法允许开发者二进制(0b)、八进制(0o)或十六进制(0x)格式定义数字。</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">代码</button><button type="button" class="tab " data-href="样例-2">预览</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num2 <span class="type">int16</span> = <span class="number">0</span>b101101  <span class="comment">//1+4+8+32=45</span></span><br><span class="line"><span class="keyword">var</span> num8 <span class="type">int16</span> = <span class="number">0</span>o377     <span class="comment">//7+56+64*3=255</span></span><br><span class="line"><span class="keyword">var</span> num16 <span class="type">float64</span> = <span class="number">0x1</span>p<span class="number">-2</span> <span class="comment">// 1/4=0.25</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	fmt.Printf(<span class="string">"%d\n"</span>, num2)</span><br><span class="line">	fmt.Println(num2)</span><br><span class="line">	fmt.Printf(<span class="string">"%b\n"</span>, num2)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"\n%d\n"</span>, num8)</span><br><span class="line">	fmt.Println(num8)</span><br><span class="line">	fmt.Printf(<span class="string">"%o\n"</span>, num8)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"\n%f\n"</span>, num16)</span><br><span class="line">	fmt.Println(num16)</span><br><span class="line">	fmt.Printf(<span class="string">"%x\n"</span>, num16)</span><br><span class="line">	fmt.Printf(<span class="string">"%X\n"</span>, num16)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">45</span><br><span class="line">45</span><br><span class="line">101101</span><br><span class="line"></span><br><span class="line">255</span><br><span class="line">255</span><br><span class="line">377</span><br><span class="line"></span><br><span class="line">0.250000</span><br><span class="line">0.25</span><br><span class="line">0x1p-02</span><br><span class="line">0X1P-02</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h3 id="整型">4.1.整型</h3>
<table class="table-2">
<thead class="thead-dark">
<tr>
<th>
类型
</th>
<th align="center">
范围
</th>
<th>
占用空间
</th>
<th>
有无符号
</th>
</tr>
</thead>
<tbody>
<tr class="alert" role="alert">
<th scope="row">
int8
</th>
<td align="center">
(-128 到 127) -2<sup>7</sup>到2<sup>7</sup>-1
</td>
<td>
1个字节
</td>
<td rowspan="4">
有
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
int16
</th>
<td align="center">
(-32768 到 32767) -2<sup>15</sup>到2<sup>15</sup>-1
</td>
<td>
2个字节
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
int32
</th>
<td align="center">
(-2147483648 到 2147483647) -2<sup>31</sup>到2<sup>31</sup>-1
</td>
<td>
4个字节
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
int64
</th>
<td align="center">
(-9223372036854775808 到 9223372036854775807) -2<sup>63</sup>到2<sup>63</sup>-1
</td>
<td>
8个字节
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
uint8
</th>
<td align="center">
(0 到 255) 0到2<sup>8</sup>-1
</td>
<td>
1个字节
</td>
<td rowspan="4">
无
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
uint16
</th>
<td align="center">
(0 到 65535) 0到2<sup>16</sup>-1
</td>
<td>
2个字节
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
uint32
</th>
<td align="center">
(0 到 4294967295) 0到2<sup>32</sup>-1
</td>
<td>
4个字节
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
uint64
</th>
<td align="center">
(0 到 18446744073709551615) 0到2<sup>64</sup>-1
</td>
<td>
8个字节
</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>特殊整型</strong></p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>uint</td>
<td>32位操作系统上就是 uint32，64位操作系统上是 uint64</td>
</tr>
<tr class="even">
<td>int</td>
<td>32位操作系统上就是 int32，64位操作系统上是 int64</td>
</tr>
<tr class="odd">
<td>uintptr</td>
<td>无符号整型，由于存放一个指针</td>
</tr>
</tbody>
</table>
<p>在使用 int 和 uint 类型时，不能假定它是 32 位或 64 位的整型，而是考虑 int 和 uint 可能在不同平台上的差异。</p>
<p><strong>注意事项：</strong>实际项目中整数类型、切片、 map 的元素数量等都可以用 int 来表示。<strong>在涉及到二进制传输、为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用 int 和 uint。</strong></p>
</blockquote>
<p><font color="#4eb434"><strong>不同 int 类型的转换</strong></font>：<code>新变量 := int类型(变量名)</code> (以局部变量为例)</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">int8</span> = <span class="number">10</span>_0 <span class="comment">//可以使用下划分割数字，相当于var a int8 = 100</span></span><br><span class="line">	b := <span class="type">int16</span>(a)</span><br><span class="line">	fmt.Printf(<span class="string">"b 的类型为%T， 占用的字节数为 %d"</span>, b, unsafe.Sizeof(b)) <span class="comment">// b 的类型为int16， 占用的字节数为 2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="浮点型">4.2.浮点型</h3>
<p>Go 语言支持两种浮点型数：float32 和 float64。<strong>Go 语言中浮点数默认是 float64</strong>。这两种浮点型数据格式遵循 IEEE 754 标准：</p>
<ul>
<li>float32 的浮点数的最大范围约为 3.4e38，可以使用常量定义：<strong>math.MaxFloat32</strong>。</li>
<li>float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：<strong>math.MaxFloat64</strong>。</li>
</ul>
<p><font color="#4eb434"><strong>浮点精度丢失问题</strong></font></p>
<p>和其他编程语言一样，Go 语言也存在精度丢失问题。我们可以通过引入第三方库 <a target="_blank" rel="noopener" href="https://github.com/shopspring/decimal">shopspring/decimal: Arbitrary-precision fixed-point decimal numbers in Go</a> 来解决该问题。</p>
<p>首先在终端输入 <code>go get github.com/shopspring/decimal</code> 安装第三方库，然后 import 引入即可。</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">代码</button><button type="button" class="tab " data-href="样例-2">预览</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"github.com/shopspring/decimal"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	num := <span class="number">1.1</span></span><br><span class="line">	fmt.Printf(<span class="string">"值：%v  类型:%T\n"</span>, num, num)</span><br><span class="line"></span><br><span class="line">	miss1 := <span class="number">1129.6</span></span><br><span class="line">	fmt.Println(miss1, miss1*<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> miss2 <span class="type">float64</span> = <span class="number">1129.6</span></span><br><span class="line">	fmt.Println(miss2, miss2*<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">	m1 := <span class="number">8.2</span></span><br><span class="line">	m2 := <span class="number">3.8</span></span><br><span class="line">	fmt.Println(m1 - m2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解决精度丢失问题</span></span><br><span class="line">	miss1_fixed := decimal.NewFromFloat(miss1)</span><br><span class="line">	miss2_fixed := decimal.NewFromFloat(miss2)</span><br><span class="line">	m1_fixed := decimal.NewFromFloat(m1)</span><br><span class="line">	m2_fixed := decimal.NewFromFloat(m2)</span><br><span class="line">	fmt.Println(miss1_fixed.Mul(decimal.NewFromInt(<span class="number">100</span>)))</span><br><span class="line">	fmt.Println(miss2_fixed.Mul(decimal.NewFromInt(<span class="number">100</span>)))</span><br><span class="line">	fmt.Println(m1_fixed.Sub(m2_fixed))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">值：1.1  类型:float64</span><br><span class="line">1129.6 112959.99999999999</span><br><span class="line">1129.6 112959.99999999999</span><br><span class="line">4.3999999999999995</span><br><span class="line">112960</span><br><span class="line">112960</span><br><span class="line">4.4</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><font color="#4eb434"><strong>科学计数法表示浮点型</strong></font></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	num8 := <span class="number">5.1234e2</span>  <span class="comment">// 5.1234 * 10 的 2 次方</span></span><br><span class="line">	num9 := <span class="number">5.1234e-2</span> <span class="comment">// 5.1234 / 10 的 2 次方 0.051234</span></span><br><span class="line">	fmt.Println(<span class="string">"num8="</span>, num8, <span class="string">"\nnum9="</span>, num9) <span class="comment">//num8= 512.34 num9= 0.051234</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="布尔型">4.3.布尔型</h3>
<p>Go 语言中以 bool 类型进行声明布尔型数据，布尔型数据只有 true（真）和 false（假）两个值。且</p>
<ul>
<li>布尔类型变量的默认值为 false。</li>
<li>字符串型可以被转换为布尔型（strconv.ParseBool）。</li>
<li>布尔型无法参与数值运算，也无法转换为其他类型。</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bool1 <span class="type">bool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> bool2 <span class="type">bool</span> = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> float1 <span class="type">float32</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	fmt.Printf(<span class="string">"bool1:%T,占用字节 %d, bool2:%T,占用字节 %d"</span>,</span><br><span class="line">		bool1, unsafe.Sizeof(bool1), bool2, unsafe.Sizeof(bool2)) <span class="comment">//bool1:bool,占用字节 1, bool2:bool,占用字节 1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="字符串">4.4.字符串</h3>
<p>Go 语言里的字符串的内部实现使用 UTF-8 编码。</p>
<ul>
<li><strong>单行字符串</strong>：字符串的值为双引号(")中的内容。</li>
<li><strong>多行字符串</strong>：定义时要使用反引号 " <strong>`</strong> " 括起来，反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</li>
</ul>
<p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等。如当我们要打印文件路径时，需要用到反斜杠转义符：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"str := \"c:\\Code\\demo\\go.exe\""</span>) <span class="comment">//str := "c:\Code\demo\go.exe"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>字符串有以下常用操作：</p>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 75%">
</colgroup>
<thead>
<tr class="header">
<th>操作</th>
<th>函数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>求字符串的字符长度</td>
<td>len( str )</td>
</tr>
<tr class="even">
<td>拼接字符串</td>
<td>"+" 或 fmt.Sprintf（如 s := fmt.Sprintf("%s is %d years old.", name, age)）</td>
</tr>
<tr class="odd">
<td>分割</td>
<td>strings.Split( str, "分隔符" )</td>
</tr>
<tr class="even">
<td>判断是否子串</td>
<td>strings.Contains( "父串", “子串” )</td>
</tr>
<tr class="odd">
<td>前缀 / 后缀判断</td>
<td>strings.HasPrefix( str, “前缀”) / strings.HasSuffix( str, “后缀”)</td>
</tr>
<tr class="even">
<td>子串出现位置</td>
<td>strings.Index( "父串", “子串” ) ——从前往后<br>strings.LastIndex( "父串", “子串” ) ——从后往前</td>
</tr>
<tr class="odd">
<td>通过分隔符连接字符串</td>
<td>string.Join( strs, “分隔符” ) ——其实就是Split的逆操作</td>
</tr>
</tbody>
</table>
<h4 id="go-语言字符串中的字符">4.4.1.Go 语言字符串中的字符</h4>
<p>组成每个字符串的元素叫做“<strong>字符</strong>”，可以通过遍历字符串元素获得字符。 <strong>字符用<font color="#985fff">单引号（’）</font>包裹起来</strong>，</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	a := <span class="string">'a'</span></span><br><span class="line">	b := <span class="string">'0'</span>       <span class="comment">//当我们直接输出 byte（字符）的时候输出的是这个字符对应的码值</span></span><br><span class="line">	fmt.Println(a) <span class="comment">//97</span></span><br><span class="line">	fmt.Println(b) <span class="comment">//48</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果我们要输出这个字符，需要格式化输出</span></span><br><span class="line">	fmt.Printf(<span class="string">"%c--%c"</span>, a, b) <span class="comment">//%c 相应 Unicode 码点所表示的字符; 输出 a--0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>注意！<strong>一个汉字占用 3 个字符长, 一个字母占用一个字符长. 一串字符串占用 16 个字节, 一个字符占用 4 个字节.</strong></p>
<p><strong>字节（byte）</strong>：是计算机中 数据处理 的基本单位，习惯上用大写 B 来表示,1B（byte,字节）= 8bit（位）。</p>
<p><strong>字符</strong>：是指计算机中使用的字母、数字、字和符号。字符长一般指的是 ASCII 码的码长，如一个汉字占用3个字符长表示一个汉字由3个ASCII码组成。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	a := <span class="string">"m"</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(a))           <span class="comment">//1</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(a)) <span class="comment">//16</span></span><br><span class="line">	b := <span class="string">"张三李四王五"</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(b))           <span class="comment">//18</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(b)) <span class="comment">//16</span></span><br><span class="line">	c := <span class="string">'n'</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(c)) <span class="comment">//4</span></span><br><span class="line">	d := <span class="string">'张'</span></span><br><span class="line">	fmt.Println(unsafe.Sizeof(d)) <span class="comment">//4</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Go</strong> <strong>语言的字符有以下两种：</strong></p>
<ol type="1">
<li>uint8 类型，或者叫 byte 型，代表了 ASCII 码的一个字符。</li>
<li>rune 类型，代表一个 UTF-8 字符。当需要处理中文、日文或者其他复合字符时，则需要用到 rune 类型。rune 类型实际是一个int32（4个字节）。</li>
</ol>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历字符串</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	s := <span class="string">"hello 张三"</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ { <span class="comment">//byte</span></span><br><span class="line">		fmt.Printf(<span class="string">"%v(%c) "</span>, s[i], s[i])</span><br><span class="line">    <span class="comment">//104(h) 101(e) 108(l) 108(l) 111(o) 32( ) 229(å) 188(¼) 160( ) 228(ä) 184(¸) 137()</span></span><br><span class="line">	}</span><br><span class="line">	fmt.Println()</span><br><span class="line">	<span class="keyword">for</span> _, r := <span class="keyword">range</span> s { <span class="comment">//rune</span></span><br><span class="line">		fmt.Printf(<span class="string">"%v(%c) "</span>, r, r)</span><br><span class="line">    <span class="comment">//104(h) 101(e) 108(l) 108(l) 111(o) 32( ) 24352(张) 19977(三) </span></span><br><span class="line">	}</span><br><span class="line">	fmt.Println()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>因为 UTF8 编码下一个中文汉字由 3 个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。</p>
<blockquote>
<p>字符串类型为 string，占用 16 个字节；字符类型为 int32，占用 4 个字节。</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">c3 := "营" </span><br><span class="line">c4 := '营' </span><br><span class="line">fmt.Printf("C3 的类型%T--C4 的类型%T", c3, c4) //C3 的类型 string--C4 的类型 int32</span><br></pre></td></tr></tbody></table></figure><p></p>
<p><strong>rune</strong> <strong>类型实际是一个</strong> <strong>int32</strong></p>
<p>rune 和 byte 都是类型别名，他们的底层定义如下：</p>
<p></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">byte</span> = <span class="type">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="type">rune</span> = <span class="type">int32</span></span><br></pre></td></tr></tbody></table></figure><p></p>
</blockquote>
<h4 id="字符串的修改">4.4.2.字符串的修改</h4>
<p>要修改字符串，需要先将其转换成 rune 类型（修改中文建议使用）或 byte 类型（修改英文建议使用），完成后再转换为 string。无论哪种转换，都会重新分配内存。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历字符串</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeString</span><span class="params">()</span></span> {</span><br><span class="line">	s1 := <span class="string">"big"</span></span><br><span class="line">	<span class="comment">// 强制类型转换</span></span><br><span class="line">	byteS1 := []<span class="type">byte</span>(s1)</span><br><span class="line">	byteS1[<span class="number">0</span>] = <span class="string">'p'</span></span><br><span class="line">	fmt.Println(<span class="type">string</span>(byteS1))	<span class="comment">//pig</span></span><br><span class="line">	s2 := <span class="string">"白萝卜"</span></span><br><span class="line">	runeS2 := []<span class="type">rune</span>(s2)</span><br><span class="line">	runeS2[<span class="number">0</span>] = <span class="string">'红'</span></span><br><span class="line">	fmt.Println(<span class="type">string</span>(runeS2)) <span class="comment">//红萝卜</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	changeString()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="数据类型转换">4.5.数据类型转换</h3>
<p><strong>Go 语言中只有强制类型转换，没有隐式类型转换。</strong>即数据要被转换成相同类型后才能进行运算等操作。<strong>转换的时候建议从低位转换成高位</strong>（如 int8 -&gt; int16），高位转换成低位（如 int16 -&gt; int8）的时候如果转换不成功就会溢出，和我们想的结果不一样。</p>
<p>注意：在 go 语言中数值类型没法直接转换成 bool 类型 bool 类型也没法直接转换成数值类型。</p>
<p><font color="#4eb434" size="5"><strong>其他类型 --&gt; 字符串型</strong></font></p>
<ul>
<li><p><strong>使用 Sprintf 函数</strong>，如：<code>s := fmt.Sprintf("%s is %d years old.\n", name, age)</code></p></li>
<li><p><strong>使用 strconv 包</strong></p>
<ul>
<li><p><strong>int 型</strong>：str := strconv.Itoa( int )</p></li>
<li><p><strong>float 型</strong>：str := strconv.FormatFloat( float, args2, args3, args4)，如：<code>str2 := strconv.FormatFloat(num2, 'f', 2, 64)</code></p>
<p>参数 2：格式化类型</p>
<p>​ 'f'（-ddd.dddd）、</p>
<p>​ 'b'（-ddddp±ddd，指数为二进制）、</p>
<p>​ 'e'（-d.dddde±dd，十进制指数）、</p>
<p>​ 'E'（-d.ddddE±dd，十进制指数）、</p>
<p>​ 'g'（指数很大时用'e'格式，否则'f'格式）、</p>
<p>​ 'G'（指数很大时用'E'格式，否则'f'格式）。</p>
<p>参数 3: 保留的小数点 ，-1（不对小数点格式化）</p>
<p>参数 4：格式化的类型</p></li>
<li><p><strong>bool 型</strong>：str := strconv.FormatBool( bool )</p></li>
<li><p><strong>int64 型</strong>：str := strconv.FormatInt( int, 进制 )，如：<code>str4 := strconv.FormatInt(num3, 10)</code></p></li>
</ul></li>
<li><p><strong>类型断言法，空接口型-&gt;字符串型</strong>：<code>value, ok := username.(string)</code></p></li>
</ul>
<p><font color="#4eb434" size="5"><strong>字符串型 --&gt; 其他类型</strong></font></p>
<ul>
<li><strong>int 型</strong>：int := strconv.ParseInt( str, 进制, int类型)，如：<code>i64, _ := strconv.ParseInt(s, 10, 64)</code></li>
<li><strong>float 型</strong>：float := strconv.ParseFloat( str, float类型 )，如：<code>v1, _ := strconv.ParseFloat(str, 32)</code></li>
<li><strong>bool 型</strong>：bool := strconv.ParseBool( str )，如：<code>b, _ := strconv.ParseBool("true")</code></li>
<li><strong>字符串转字符</strong>：for _, r := range str { char = r ...}，迭代得到的变量 r 即为字符串中单个字符</li>
</ul>
<h2 id="运算符">5.运算符</h2>
<p>Golang 中内置有五种运算符：<font color="#ef042a">算术运算符</font>、<font color="#df8400">关系运算符</font>、<font color="#4eb434">逻辑运算符</font>、<font color="#0091ff">位运算符</font>、<font color="#985fff">赋值运算符</font>。</p>
<p><strong>注意！++（自增）和--（自减）在 Go 语言中是单独的语句，并不是运算符。</strong>因此在 golang 中，++ 和 -- 只能独立使用，不能作为 “=” 后的赋值式。且<strong>只有 “i++” 和 “i--”</strong>，没有 “++i” 和 “--i” 。</p>
<p><strong>Go 语言中没有三目运算</strong>。</p>
<div class="table-3 ver1" style="margin-bottom: 50px;">
<div class="table-3-head">
<table class="table-3">
<thead>
<tr class="row100 head">
<th class="cell100 column1" width="13%" align="right">
运算符
</th>
<th class="cell100 column2">
描述
</th>
</tr>
</thead>
</table>
</div>
<div class="table-3-body js-pscroll">
<table class="table-3">
<tbody>
<tr class="row100 body">
<td class="cell100 column1" width="13%" align="center" style="color: #ef042a; font-weight: bold">
+
</td>
<td class="cell100 column2" style="color: #ef042a">
相加
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" width="13%" align="center" style="color: #ef042a; font-weight: bold">
-
</td>
<td class="cell100 column2" style="color: #ef042a">
相减
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" width="13%" align="center" style="color: #ef042a; font-weight: bold">
*
</td>
<td class="cell100 column2" style="color: #ef042a">
相乘
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" width="13%" align="center" style="color: #ef042a; font-weight: bold">
/
</td>
<td class="cell100 column2" style="color: #ef042a">
相除
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" width="13%" align="center" style="color: #ef042a; font-weight: bold">
%
</td>
<td class="cell100 column2" style="color: #ef042a">
求余=被除数-（被除数/除数）* 除数
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" align="center" style="color: #df8400; font-weight: bold">
==
</td>
<td class="cell100 column2" style="color: #df8400">
检查两个值是否相等，如果相等返回 True 否则返回 False。
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" align="center" style="color: #df8400; font-weight: bold">
!=
</td>
<td class="cell100 column2" style="color: #df8400">
检查两个值是否不相等，如果不相等返回 True 否则返回 False。
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" align="center" style="color: #df8400; font-weight: bold">
&gt;
</td>
<td class="cell100 column2" style="color: #df8400">
检查左边值是否大于右边值，如果是返回 True 否则返回 False。
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" align="center" style="color: #df8400; font-weight: bold">
&gt;=
</td>
<td class="cell100 column2" style="color: #df8400">
检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" align="center" style="color: #df8400; font-weight: bold">
&lt;
</td>
<td class="cell100 column2" style="color: #df8400">
检查左边值是否小于右边值，如果是返回 True 否则返回 False。
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" align="center" style="color: #df8400; font-weight: bold">
&lt;=
</td>
<td class="cell100 column2" style="color: #df8400">
检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" align="center" style="color: #4eb434; font-weight: bold">
&amp;&amp;
</td>
<td class="cell100 column2" style="color: #4eb434">
逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" align="center" style="color: #4eb434; font-weight: bold">
||
</td>
<td class="cell100 column2" style="color: #4eb434">
逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" align="center" style="color: #4eb434; font-weight: bold">
!
</td>
<td class="cell100 column2" style="color: #4eb434">
逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" align="center" style="color: #0091ff; font-weight: bold">
=
</td>
<td class="cell100 column2" style="color: #0091ff">
简单的赋值运算符，将一个表达式的值赋给一个左值
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" align="center" style="color: #0091ff; font-weight: bold">
+=
</td>
<td class="cell100 column2" style="color: #0091ff">
相加后再赋值
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" align="center" style="color: #0091ff; font-weight: bold">
-=
</td>
<td class="cell100 column2" style="color: #0091ff">
相减后再赋值
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" align="center" style="color: #0091ff; font-weight: bold">
*=
</td>
<td class="cell100 column2" style="color: #0091ff">
相乘后再赋值
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" align="center" style="color: #0091ff; font-weight: bold">
/=
</td>
<td class="cell100 column2" style="color: #0091ff">
相除后再赋值
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" align="center" style="color: #0091ff; font-weight: bold">
%=
</td>
<td class="cell100 column2" style="color: #0091ff">
求余后再赋值
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" align="center" style="color: #985fff; font-weight: bold">
&amp;
</td>
<td class="cell100 column2" style="color: #985fff">
参与运算的两数各对应的二进位相与。 （两位均为 1 才为 1）
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" align="center" style="color: #985fff; font-weight: bold">
|
</td>
<td class="cell100 column2" style="color: #985fff">
参与运算的两数各对应的二进位相或。 （两位有一个为 1 就为 1）
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" align="center" style="color: #985fff; font-weight: bold">
^
</td>
<td class="cell100 column2" style="color: #985fff">
参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为 1。（两位不一样则为 1）
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" align="center" style="color: #985fff; font-weight: bold">
&lt;&lt;
</td>
<td class="cell100 column2" style="color: #985fff">
左移 n 位就是乘以 2 的 n 次方。 "a&lt;&lt;b"是把 a 的各二进位全部左移 b 位，高位丢弃，低位补 0。
</td>
</tr>
<tr class="row100 body">
<td class="cell100 column1" align="center" style="color: #985fff; font-weight: bold">
&gt;&gt;
</td>
<td class="cell100 column2" style="color: #985fff">
右移 n 位就是除以 2 的 n 次方。 "a&gt;&gt;b"是把 a 的各二进位全部右移 b 位。
</td>
</tr>
</tbody>
</table>
</div>
</div>
<h2 id="流程控制">6.流程控制</h2>
<p>Go 语言中最常用的流程控制有 if 和 for，而 switch 和 goto 主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p>
<h3 id="分支结构-if-else">6.1.分支结构 if else</h3>
<p>Go 语言中 if 条件判断的格式如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式 <span class="number">1</span> {</span><br><span class="line">	分支 <span class="number">1</span></span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> 表达式 <span class="number">2</span> {</span><br><span class="line">	分支 <span class="number">2</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">	分支 <span class="number">3</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>注意：</strong>Go 语言规定与 if 匹配的左括号必须与 if 和 表达式放在同一行，放在其他位置会触发编译错误。 同理，与 else 匹配的左括号也必须与 else 写在同一行，else 也必须与上一个 if 或 else if 的右括号在同一行。</p>
<p>if 条件判断还有一种特殊的写法，<strong>可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断</strong>，举个例子：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">if</span> score := <span class="number">56</span>; score &gt;= <span class="number">90</span> {</span><br><span class="line">		fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">	} <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">75</span> {</span><br><span class="line">		fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		fmt.Println(<span class="string">"C"</span>)</span><br><span class="line">	} <span class="comment">//C</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="循环结构-for">6.2.循环结构 for</h3>
<p><strong>注意：Go 语言中是没有</strong> <strong>while</strong> <strong>语句的，我们可以通过</strong> <strong>for ; ;</strong> <strong>代替</strong></p>
<p>Go 语言中 for 循环的格式如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始语句;条件表达式;执行语句{</span><br><span class="line">	循环体语句</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>for 循环可以通过 break、goto、return、panic 语句强制退出循环。</p>
<h3 id="键值循环-for-range">6.3.键值循环 for range</h3>
<p>Go 语言中可以使用 for range 遍历数组、切片、字符串、map 及通道（channel）。 通过 for range 遍历的返回值有以下规律：</p>
<ol type="1">
<li><p>数组、切片、字符串返回索引和值。</p></li>
<li><p>map 返回键和值。</p></li>
<li><p>通道（channel）只返回通道内的值。</p></li>
</ol>
<p>Go 语言中 for range循环的格式如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> idx/key, value := <span class="keyword">range</span> A {</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>下面是一个例子:</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	str := <span class="string">"abc 上海"</span></span><br><span class="line">	<span class="keyword">for</span> index, val := <span class="keyword">range</span> str {</span><br><span class="line">		fmt.Printf(<span class="string">"index=%d, val=%c \n"</span>, index, val)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, val := <span class="keyword">range</span> str {</span><br><span class="line">		fmt.Printf(<span class="string">"val=%c \n"</span>, val)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="条件分支-switch-case">6.4.条件分支 switch case</h3>
<p><strong>使用</strong> <strong>switch</strong> <strong>语句可方便地对大量的值进行条件判断。</strong></p>
<p>switch 的一个 case 可以有多个值，多个 case 值中间使用英文逗号分隔。Go 语言中每个 case 语句中可以不写 break，不加 break 也不会出现穿透的现象。</p>
<p>Go 中 switch 语句有两种写法：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//不用表达式</span></span><br><span class="line"><span class="keyword">switch</span> varName:=value; varName {	<span class="comment">//这里也可以拆开写</span></span><br><span class="line">  <span class="keyword">case</span> ...:</span><br><span class="line">  	...</span><br><span class="line">  <span class="keyword">case</span> ...:</span><br><span class="line">  	...</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  	...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用表达式</span></span><br><span class="line"><span class="keyword">switch</span> {	<span class="comment">//这里也可以拆开写</span></span><br><span class="line">  <span class="keyword">case</span> varName的判断式:</span><br><span class="line">  	...</span><br><span class="line">  <span class="keyword">case</span> varName的判断式:</span><br><span class="line">  	...</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  	...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><font color="#4eb434" size="4"><strong>switch 的穿透 fallthrough</strong></font></p>
<p><strong>fallthrough语法可以执行满足条件的 case 的下一个 case（无论下一个 case 是否满足）</strong>，是为了兼容 C 语言中的 case 设计的。注意，默认只能穿透一层！</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> num <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">	<span class="keyword">switch</span> num {</span><br><span class="line">	<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">		fmt.Println(<span class="string">"ok1"</span>)</span><br><span class="line">		<span class="keyword">fallthrough</span> <span class="comment">//默认只能穿透一层</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">20</span>:</span><br><span class="line">		fmt.Println(<span class="string">"ok2"</span>)</span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">30</span>:</span><br><span class="line">		fmt.Println(<span class="string">"ok3"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"没有匹配到.."</span>)</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 输出：</span></span><br><span class="line">	<span class="comment">// ok1</span></span><br><span class="line">	<span class="comment">// ok2</span></span><br><span class="line">	<span class="comment">// ok3</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="跳出循环-break">6.5.跳出循环 break</h3>
<p>break 用于循环语句中跳出循环，并开始执行循环之后的语句。Go 语言中，在多重循环里可以用标号 label 标出想 break 的循环（否则默认只跳出一层循环），如：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">lable2:</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ {</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ {</span><br><span class="line">			<span class="keyword">if</span> j == <span class="number">2</span> {</span><br><span class="line">				<span class="keyword">break</span> lable2</span><br><span class="line">			}</span><br><span class="line">			fmt.Println(<span class="string">"i j 的值"</span>, i, <span class="string">"-"</span>, j)</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">// i j 的值 0 - 0</span></span><br><span class="line"><span class="comment">// i j 的值 0 - 1</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="继续下次循环-continue">6.6.继续下次循环 continue</h3>
<p>continue 语句可以结束当前循环，开始下一次的循环迭代过程，<strong>仅限在 for 循环内使用</strong>。</p>
<p><strong>在</strong> <strong>continue</strong> <strong>语句后添加标签时，表示开始标签对应的循环。如：</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">here:</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ {</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">4</span>; j++ {</span><br><span class="line">			<span class="keyword">if</span> j == <span class="number">2</span> {</span><br><span class="line">				<span class="keyword">continue</span> here</span><br><span class="line">			}</span><br><span class="line">			fmt.Println(<span class="string">"i j 的值"</span>, i, <span class="string">"-"</span>, j)</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">// i j 的值 0 - 0</span></span><br><span class="line"><span class="comment">// i j 的值 0 - 1</span></span><br><span class="line"><span class="comment">// i j 的值 1 - 0</span></span><br><span class="line"><span class="comment">// i j 的值 1 - 1</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="跳转到指定标签-goto">6.7.跳转到指定标签 goto</h3>
<p>goto 语句通过标签进行代码间的无条件跳转。Go 语言中使用 goto 语句能简化一些代码的实现过程。如：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ {</span><br><span class="line">			<span class="keyword">if</span> j == <span class="number">2</span> {</span><br><span class="line">				<span class="comment">// 设置退出标签</span></span><br><span class="line">				<span class="keyword">goto</span> breakTag</span><br><span class="line">			}</span><br><span class="line">			fmt.Printf(<span class="string">"%v-%v\n"</span>, i, j)</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">breakTag:</span><br><span class="line">	fmt.Println(<span class="string">"结束 for 循环"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">// 0-0</span></span><br><span class="line"><span class="comment">// 0-1</span></span><br><span class="line"><span class="comment">// 结束 for 循环</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="数组-array">7.数组 Array</h2>
<p>数组是指一系列同一类型数据的集合。数组中包含的每个数据被称为数组元素 (element)，这种类型可以是任意的原始类型，比如 int、string 等，也可以是用户自定义的类型。一个数组包含的元素个数被称为数组的长度。在 Golang 中数组是一个长度固定的数据类型，<strong>数组的长度是类型的一部分</strong>，也就是说 [5]int 和 [10]int 是两个不同的类型。Golang中数组的另一个特点是<strong>占用内存的连续性</strong>，也就是说数组中的元素是被分配到连续的内存地址中的，因而索引数组元素的速度非常快。</p>
<p>数组可以通过下标进行访问，下标是从 0 开始，最后一个元素下标是：len-1，访问越界（下标在合法范围之外），则触发访问越界，会 panic。</p>
<p>和数组对应的类型是 Slice（切片），Slice 是可以增长和收缩的动态序列，功能也更灵活。</p>
<h3 id="数组的初始化">7.1.数组的初始化</h3>
<ul>
<li><code>var 数组变量名 [元素数量]数组数据类型</code>：如 <code>var arr1 [3]int</code> 会自动初始化一个有3个0元素的数组。</li>
<li><code>var 数组变量名 = [元素数量]数组数据类型{初始值}</code>：使用指定的初始值初始化数组，如果初始值数量比元素数量少，将自动赋值给前面的元素，后面的元素按默认初始化。</li>
<li><code>var 数组变量名 = [...]数组数据类型{初始值}</code>：省略号表示编译器根据初始值的个数自动推断数组的长度。</li>
<li><code>var 数组变量名 = [...]数组数据类型{索引值1:初始值1, 索引值2:初始值2, ...}</code>：指定索引值方式初始化数组，未指定的索引处按默认初始化。</li>
</ul>
<h3 id="数组是值类型">7.2.数组是值类型</h3>
<p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyArray</span><span class="params">(x [3]<span class="type">int</span>)</span></span> {</span><br><span class="line">	x[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyArray2</span><span class="params">(x [3][2]<span class="type">int</span>)</span></span> {</span><br><span class="line">	x[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	a := [<span class="number">3</span>]<span class="type">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>}</span><br><span class="line">	modifyArray(a) <span class="comment">//在 modify 中修改的是 a 的副本 x</span></span><br><span class="line">	fmt.Println(a) <span class="comment">//[10 20 30]</span></span><br><span class="line">	b := [<span class="number">3</span>][<span class="number">2</span>]<span class="type">int</span>{</span><br><span class="line">		{<span class="number">1</span>, <span class="number">1</span>}, {<span class="number">1</span>, <span class="number">1</span>}, {<span class="number">1</span>, <span class="number">1</span>}}</span><br><span class="line">	modifyArray2(b) <span class="comment">//在 modify 中修改的是 b 的副本 x</span></span><br><span class="line">	fmt.Println(b)  <span class="comment">//[[1 1] [1 1] [1 1]]</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="多维数组">7.3.多维数组</h3>
<p>以二维数组为例，多维数组初始化有以下常见形式：</p>
<ul>
<li><code>var 数组变量名 [元素数量][元素数量]数组数据类型</code></li>
<li><code>var 数组变量名 = [元素数量][元素数量]数组数据类型{ {初始值}{初始值}{初始值}... }</code>：注意！多维数组只有第一层可以使用省略号来让编译器推导数组长度。</li>
</ul>
<h2 id="切片-slice">8.切片 Slice</h2>
<p><strong>切片（Slice）</strong>是一个拥有<strong>相同类型元素</strong>的<strong>可变长度</strong>的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p>
<p>切片是一个<strong>引用类型</strong>（切片之间不能直接比较，只能和 nil 比较判断是否默认初始值），它的内部结构包含<strong>地址</strong>、<strong>长度</strong>和<strong>容量</strong>。<font color="#ef042a"><strong>由于切片是引用类型，当两个切片共享底层数组时，对一个切片的修改会影响另一个切片的内容。</strong></font></p>
<h3 id="切片的初始化">8.1.切片的初始化</h3>
<p>声明切片类型的一般语法为：</p>
<ul>
<li><code>var 切片变量名 []切片变量类型</code>：注意初始化切片时括号为空！</li>
<li><code>var 切片变量名 []切片变量类型{初始值}</code>：通过指定初始值初始化切片。</li>
<li><code>var 切片变量名 = 数组变量名[数组索引范围]</code>：基于数组定义切片。和其他语言的切片类似，索引是“左开右闭”的。</li>
<li><code>var 新切片变量名 = 旧切片变量名[数组索引范围]</code>：若旧切片是基于数组定义的，还能通过切片再切片的方式定义新切片。但是注意对旧切片进行再切片时，索引不能超出原数组的长度！</li>
<li><code>var 切片变量名 = make([]切片变量类型, 切片长度, 切片容量)</code>：使用 make 函数动态创建切片。</li>
</ul>
<h3 id="切片的长度和容量">8.2.切片的长度和容量</h3>
<p><strong>切片拥有自己的长度和容量，我们可以通过使用内置的 len(slice) 函数求长度，使用内置的 cap(slice) 函数求切片的容量</strong>。</p>
<ul>
<li><strong>切片的长度</strong>就是它所包含的元素个数。</li>
<li><strong>切片的容量</strong>是从它的第一个元素开始数，到其底层数组元素末尾的个数（切片的本质是对底层数组的封装，其容量就是被封装数组的长度）。切片的容量决定了该切片能动态新增多少元素。</li>
</ul>
<blockquote>
<p>注：一个 nil 值的切片并没有底层数组，一个 nil 值的切片的长度和容量都是 0。但是一个长度和容量都是 0 的切片不一定是 nil！空的切片长度和容量都为 0，但均不等于 nil（如 <code>var s1 []int</code> 初始化得到的 s1 == nil，但 <code>s2 := []int{}</code> 和 <code>s3 := make([]int, 0)</code> c初始化得到的 s2 和 s3 均不等于 nil ）。因此<strong>要判断一个切片是否是空的，要用 len(s) == 0 来判断</strong>，不应该使用 s == nil 来判断。</p>
</blockquote>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">代码</button><button type="button" class="tab " data-href="样例-2">预览</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	s := []<span class="type">int</span>{<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>}</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">	fmt.Printf(<span class="string">"长度:%v 容量 %v\n"</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">	c := s[:<span class="number">2</span>]</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">	fmt.Printf(<span class="string">"长度:%v 容量 %v\n"</span>, <span class="built_in">len</span>(c), <span class="built_in">cap</span>(c))</span><br><span class="line">	d := c[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">	fmt.Println(d)</span><br><span class="line">	fmt.Printf(<span class="string">"长度:%v 容量 %v"</span>, <span class="built_in">len</span>(d), <span class="built_in">cap</span>(d))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[2 3 5 7 11 13]</span><br><span class="line">长度:6 容量 6</span><br><span class="line">[2 3]</span><br><span class="line">长度:2 容量 6</span><br><span class="line">[3 5]</span><br><span class="line">长度:2 容量 5</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h3 id="增加切片元素-append">8.3.增加切片元素 append()</h3>
<p>Go 语言的内建函数 append() 可以为切片动态添加元素，每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”（一般情况下按照 1，2，4，8，16 ... 的规则自动进行扩容，每次扩容后容量都是扩容前的 2 倍），此时该切片指向的底层数组就会更换。“扩容”操作往往发生在 append() 函数调用时，所以我们通常都需要用原变量接收 append 函数的返回值。</p>
<p>增加切片的一般形式为：</p>
<ul>
<li><code>切片变量名 = append( 切片变量名, 新元素1, 新元素2, ... )</code>：append 函数支持一次性追加多个元素。</li>
<li><code>var 切片变量名3 = append( 切片变量名1, 切片变量名2...)</code>：切片后加切片得到新切片。注意这里的省略号是格式，不可省略！</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">//append()添加元素和切片扩容</span></span><br><span class="line">	<span class="keyword">var</span> numSlice []<span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">		numSlice = <span class="built_in">append</span>(numSlice, i)</span><br><span class="line">		fmt.Printf(<span class="string">"%v len:%d cap:%d ptr:%p\n"</span>,</span><br><span class="line">			numSlice, <span class="built_in">len</span>(numSlice), <span class="built_in">cap</span>(numSlice), numSlice)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="number">0</span>] <span class="built_in">len</span>:<span class="number">1</span> <span class="built_in">cap</span>:<span class="number">1</span> ptr:<span class="number">0xc0000a8000</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span>] <span class="built_in">len</span>:<span class="number">2</span> <span class="built_in">cap</span>:<span class="number">2</span> ptr:<span class="number">0xc0000a8040</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>] <span class="built_in">len</span>:<span class="number">3</span> <span class="built_in">cap</span>:<span class="number">4</span> ptr:<span class="number">0xc0000b2020</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>] <span class="built_in">len</span>:<span class="number">4</span> <span class="built_in">cap</span>:<span class="number">4</span> ptr:<span class="number">0xc0000b2020</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>] <span class="built_in">len</span>:<span class="number">5</span> <span class="built_in">cap</span>:<span class="number">8</span> ptr:<span class="number">0xc0000b6000</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>] <span class="built_in">len</span>:<span class="number">6</span> <span class="built_in">cap</span>:<span class="number">8</span> ptr:<span class="number">0xc0000b6000</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>] <span class="built_in">len</span>:<span class="number">7</span> <span class="built_in">cap</span>:<span class="number">8</span> ptr:<span class="number">0xc0000b6000</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>] <span class="built_in">len</span>:<span class="number">8</span> <span class="built_in">cap</span>:<span class="number">8</span> ptr:<span class="number">0xc0000b6000</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>] <span class="built_in">len</span>:<span class="number">9</span> <span class="built_in">cap</span>:<span class="number">16</span> ptr:<span class="number">0xc0000b8000</span></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>] <span class="built_in">len</span>:<span class="number">10</span> <span class="built_in">cap</span>:<span class="number">16</span> ptr:<span class="number">0xc0000b8000</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><font color="black" size="4"><strong>切片的扩容策略</strong></font></p>
<p>查看$GOROOT/src/runtime/slice.go 源码，其中扩容相关代码如下：</p>
<p></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap {</span><br><span class="line">		newcap = <span class="built_in">cap</span></span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		<span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> {</span><br><span class="line">			newcap = doublecap</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			<span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line">			<span class="comment">// and prevent an infinite loop. for 0 &lt; newcap &amp;&amp; newcap &lt; cap {</span></span><br><span class="line">			newcap += newcap / <span class="number">4</span></span><br><span class="line">		}</span><br><span class="line">		<span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line">		<span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line">		<span class="keyword">if</span> newcap &lt;= <span class="number">0</span> {</span><br><span class="line">			newcap = <span class="built_in">cap</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>可以看出：</p>
<ol type="1">
<li>首先判断，如果新申请容量（cap）大于 2 倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）</li>
<li>否则判断，如果旧切片的长度小于 1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap）</li>
<li>否则判断，如果旧切片长度大于等于 1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li>
<li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）</li>
</ol>
<p>需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如 int 和 string 类型的处理方式就不一样。</p>
</blockquote>
<h3 id="复制切片-copy">8.4.复制切片 copy()</h3>
<p>前面我们知道，当两个切片共享同一个底层数组（软复制）时，修改一个切片的值会使另一个切片的值也发生变化，因为这两个切片指向同一块内存地址。</p>
<p>而Go 语言内建的 copy() 函数可以迅速地将一个切片的数据复制到另外一个切片空间中（硬复制），copy() 函数的使用格式如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">copy</span>( 切片变量名<span class="number">2</span>, 切片变量名<span class="number">1</span> ) <span class="comment">//将切片1中的元素复制到切片2</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="删除切片元素">8.5.删除切片元素</h3>
<p>Go 语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除索引为 index 的元素：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">切片变量名 = <span class="built_in">append</span>( 切片变量名[:index], 切片变量名[index+<span class="number">1</span>:]...) <span class="comment">//这里的省略号表示切片后追加切片，不可省略</span></span><br></pre></td></tr></tbody></table></figure>
<p>例子如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 从切片中删除元素</span></span><br><span class="line">	a := []<span class="type">int</span>{<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>}</span><br><span class="line">	<span class="comment">// 要删除索引为 2 的元素</span></span><br><span class="line">	a = <span class="built_in">append</span>(a[:<span class="number">2</span>], a[<span class="number">3</span>:]...)</span><br><span class="line">	fmt.Println(a) <span class="comment">//[30 31 33 34 35 36 37]</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="数组和切片的排序">9.数组和切片的排序？？</h2>
<p>对于 int 、float64 和 string 数组或是切片的排序， go 分别提供了 sort.Ints() 、sort.Float64s() 和 sort.Strings() 函数， 默认都是从小到大排序（升序排序）且原地修改原数组 或 切片。</p>
<p>Golang 的 sort 包 可 以 使 用 sort.Reverse(slice) 来将数组或切片反向，所以， int 、float64 和 string的降序排序函数（以 int 型为例）可以这么写：<code>sort.Sort(sort.Reverse(sort.IntSlice(intList)))</code></p>
<h2 id="键值对-map">10.键值对 map</h2>
<p>map 是一种无序的基于 key-value 的数据结构，Go 语言中的 map 是引用类型，必须初始化才能使用（如果想按指定键顺序遍历 map，需要先将 map 中所有键存放到切片，对切片排序后，遍历键切片时打印 map 的键值对）。</p>
<p>定义 map 的一般语法为：</p>
<ul>
<li><code>maps := make( map[键数据类型]值数据类型, [cap] )</code> ：map 类型的变量默认初始值为 nil，需要使用 make()函数来分配内存。其中 cap 表示 map 的容量，该参数为可选参数。</li>
<li><code>maps := map[键数据类型]值数据类型{键1:值1,键2:值2,}</code>：使用指定值初始化。最后一个键值对后要加上逗号(否则右括号必须与最后一个键值对同行)。</li>
</ul>
<p><strong>注意</strong>：获取 map 的容量不能使用 cap, cap 返回的是数组切片分配的空间大小, 根本不能用于 map。要获取 map 的容量，可以用 len 函数。</p>
<p><font color="#4eb434"><strong>判断某个键是否存在</strong></font></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">格式：要判断的键对应的值, 判断键是否存在的布尔变量 := map[要判断的键]</span><br><span class="line"></span><br><span class="line">如果键存在，布尔变量为 true，值为键对应的值；</span><br><span class="line">如果键不存在，布尔变量为 false，值为值类型的零值。</span><br></pre></td></tr></tbody></table></figure>
<p><font color="#4eb434"><strong>map 的遍历</strong></font></p>
<p><strong>注意：</strong> 遍历 map 时的元素顺序与添加键值对的顺序无关。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//法1，同时遍历键和值</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	scoreMap[<span class="string">"张三"</span>] = <span class="number">90</span></span><br><span class="line">	scoreMap[<span class="string">"小明"</span>] = <span class="number">100</span></span><br><span class="line">	scoreMap[<span class="string">"娜扎"</span>] = <span class="number">60</span></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> scoreMap {</span><br><span class="line">		fmt.Println(k, v)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//法2，只想遍历键</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	scoreMap[<span class="string">"张三"</span>] = <span class="number">90</span></span><br><span class="line">	scoreMap[<span class="string">"小明"</span>] = <span class="number">100</span></span><br><span class="line">	scoreMap[<span class="string">"娜扎"</span>] = <span class="number">60</span></span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> scoreMap {</span><br><span class="line">		fmt.Println(k)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><font color="#4eb434" size="5"><strong>删除键值对 delete()</strong></font></p>
<p>一般格式为：<code>delete( map, key )</code>。删除键值对时只需要知道键值即可，且该函数将原地修改数据。</p>
<details class="toggle"><summary class="toggle-button" style="">map 小练习</summary><div class="toggle-content"><p>写一个程序，统计一个字符串中每个单词出现的次数。比如：”how do you do”中 how=1 do=2 you=1。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> wordMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">20</span>)</span><br><span class="line">	<span class="keyword">var</span> str = <span class="string">"how do you do"</span></span><br><span class="line">	<span class="keyword">var</span> arrSlice = strings.Split(str, <span class="string">" "</span>)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arrSlice {</span><br><span class="line">		wordMap[v]++</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> wordMap {</span><br><span class="line">		fmt.Println(k, v)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//how 1</span></span><br><span class="line"><span class="comment">//do 2</span></span><br><span class="line"><span class="comment">//you 1</span></span><br></pre></td></tr></tbody></table></figure>
</div></details>
<h2 id="函数-func">11.函数 func</h2>
<p>函数是组织好的、可重复使用的、用于执行指定任务的代码块。Go 语言中支持函数、匿名函数和闭包三种类型。</p>
<p>一般函数定义格式为：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数)</span></span> (返回值) {</span><br><span class="line">  函数体</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>函数名</strong>：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名。</li>
<li><strong>参数</strong>（可选）：参数由<strong>参数变量</strong>和<strong>参数变量的类型</strong>组成，多个参数之间使用逗号分隔。</li>
<li><strong>返回值</strong>（可选）：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用()包裹，并用逗号分隔。单个返回值不需要加()。<font color="#985fff"><strong>注意！命名返回值在函数开始时就已初始化（零值）</strong></font>。</li>
</ul>
<p>注：如果相邻参数/返回值的类型相同，可以省略类型，如 <code>x int, y int</code> 可以简写为 <code>x, y int</code> 。</p>
<p><font color="#4eb434" size="5"><strong>可变参数</strong></font></p>
<p>可变参数是指函数的参数数量不固定（数量可以是0）。Go 语言中的可变参数通过在参数名、参数类型之前后加 <code>...</code> 来标识。<strong>可变参数通常要作为函数的最后一个参数</strong>（固定参数搭配可变参数使用时，可变参数要放在固定参数的后面）。</p>
<blockquote>
<p>本质上，函数的可变参数是通过切片来实现的。所有属于该可变参数的传入参数将作为切片的元素。</p>
</blockquote>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSum3</span><span class="params">(x <span class="type">int</span>, y ...<span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">	fmt.Println(x, y)</span><br><span class="line">	sum := x</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> y {</span><br><span class="line">		sum = sum + v</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	ret5 := intSum3(<span class="number">100</span>)                <span class="comment">//100 []</span></span><br><span class="line">	ret6 := intSum3(<span class="number">100</span>, <span class="number">10</span>)            <span class="comment">//100 [10]</span></span><br><span class="line">	ret7 := intSum3(<span class="number">100</span>, <span class="number">10</span>, <span class="number">20</span>)        <span class="comment">//100 [10 20]</span></span><br><span class="line">	ret8 := intSum3(<span class="number">100</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)    <span class="comment">//100 [10 20 30]</span></span><br><span class="line">	fmt.Println(ret5, ret6, ret7, ret8) <span class="comment">//100 110 130 160</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="函数类型与变量">11.1.函数类型与变量</h3>
<p><strong>可以通过 type 关键字来定义一个函数类型 （函数类型包括传入参数和返回值）</strong>，以定义 calculation 类型为例：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> calculation <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></tbody></table></figure>
<p>上面语句定义了一个 calculation 类型，它是一种函数类型，这种函数接收两个 int 类型的参数并且返回一个 int 类型的返回值。凡是满足这个条件的函数都是 calculation 类型，例如<font color="#985fff">下面的 add 和 sub 是 calculation 类型，我们可以声明 calculation 类型的变量，然后用 add 函数和 sub 函数为该变量赋值（该变量赋值后即为一个函数）</font>：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> calculation <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">	<span class="keyword">return</span> x - y</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> c calculation</span><br><span class="line">	c = add           <span class="comment">// add 和 sub 都能赋值给 calculation 类型的变量</span></span><br><span class="line">	result := c(<span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 若c声明后未使用将导致编译错误</span></span><br><span class="line">	<span class="built_in">println</span>(result)	  <span class="comment">// 8 </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="高阶函数">11.2.高阶函数</h3>
<p>高阶函数分为函数作为参数和函数作为返回值两部分。</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">函数作为传入参数</button><button type="button" class="tab " data-href="样例-2">函数作为返回值</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(x, y <span class="type">int</span>, op <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span>) <span class="type">int</span> {</span><br><span class="line">	<span class="keyword">return</span> op(x, y)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	ret2 := calc(<span class="number">10</span>, <span class="number">20</span>, add)</span><br><span class="line">	fmt.Println(ret2) <span class="comment">//30</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">	<span class="keyword">return</span> x - y</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span> { <span class="comment">// 这里 func(int, int) int 是返回值的类型</span></span><br><span class="line">	<span class="keyword">switch</span> s {</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">		<span class="keyword">return</span> add</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">		<span class="keyword">return</span> sub</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> a = do(<span class="string">"+"</span>)</span><br><span class="line">	fmt.Println(a(<span class="number">10</span>, <span class="number">20</span>)) <span class="comment">//30</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h3 id="匿名函数">11.3.匿名函数</h3>
<p><strong>在 Go 语言中函数内部只能定义匿名函数（没有函数名的函数，匿名函数体在函数内部）</strong>，或通过定义函数体在函数外部的函数变量来实现函数内的函数变量。匿名函数常用于实现闭包和回调函数。匿名函数的定义格式为：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(参数)</span></span> (返回值) {		<span class="comment">//这里没有函数名</span></span><br><span class="line">  函数体</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>匿名函数因为没有函数名，没办法像普通函数那样调用，所以<strong>匿名函数需要保存到某个变量或者作为立即执行函数</strong>:</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 1.将匿名函数保存到变量</span></span><br><span class="line">	add := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> {</span><br><span class="line">		fmt.Println(x + y)</span><br><span class="line">	}</span><br><span class="line">	add(<span class="number">10</span>, <span class="number">20</span>) <span class="comment">// 通过变量调用匿名函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.自执行函数：匿名函数定义完加()直接执行</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> {</span><br><span class="line">		fmt.Println(x + y)</span><br><span class="line">	}(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="闭包">11.4.闭包</h3>
<p><strong>闭包</strong>可以理解成“<strong>定义在一个函数内部的函数，且该闭包函数引用了其外部作用域的变量</strong>“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。或者说“<strong>闭包=函数+引用环境</strong>”。闭包函数的返回值通常是匿名函数。</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">例子1</button><button type="button" class="tab " data-href="样例-2">例子2</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">	<span class="keyword">var</span> x <span class="type">int</span> <span class="comment">// 全局变量 x 将被自动初始化为0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">		x += y</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> f = adder() <span class="comment">/* 变量 f 是一个函数并且它引用了其外部作用域中的 x 变量，此时 f 就是一个闭包。</span></span><br><span class="line"><span class="comment">	在 f 的生命周期内，变量 x 也一直有效。*/</span></span><br><span class="line">	fmt.Println(f(<span class="number">10</span>)) <span class="comment">//10</span></span><br><span class="line">	fmt.Println(f(<span class="number">20</span>)) <span class="comment">//30</span></span><br><span class="line">	fmt.Println(f(<span class="number">30</span>)) <span class="comment">//60</span></span><br><span class="line">	f1 := adder()</span><br><span class="line">	fmt.Println(f1(<span class="number">40</span>)) <span class="comment">//40</span></span><br><span class="line">	fmt.Println(f1(<span class="number">50</span>)) <span class="comment">//90</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(base <span class="type">int</span>)</span></span> (<span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>, <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>) {</span><br><span class="line">	add := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">		base += i</span><br><span class="line">		<span class="keyword">return</span> base</span><br><span class="line">	}</span><br><span class="line">	sub := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">		base -= i <span class="comment">// 注意这里的 base 和上面的 base 是同一个变量</span></span><br><span class="line">		<span class="keyword">return</span> base</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> add, sub</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	f1, f2 := calc(<span class="number">10</span>)</span><br><span class="line">	fmt.Println(f1(<span class="number">1</span>), f2(<span class="number">2</span>)) <span class="comment">//11 9</span></span><br><span class="line">	fmt.Println(f1(<span class="number">3</span>), f2(<span class="number">4</span>)) <span class="comment">//12 8</span></span><br><span class="line">	fmt.Println(f1(<span class="number">5</span>), f2(<span class="number">6</span>)) <span class="comment">//13 7</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h3 id="defer-语句">11.5.defer 语句</h3>
<p>Go 语言中的 defer 语句会将其后面跟随的语句进行延迟处理。<strong>在 defer 归属的函数即将返回时，将延迟处理的语句按 defer 定义的<font color="#ef042a">逆序</font>进行执行(后进先出)</strong>，也就是说，先被 defer 的语句最后被执行，最后被 defer 的语句最先被执行。</p>
<p><font color="#ef042a"><strong>注意！defer 语句的参数在声明时就会求值，而不是等到最后一起延迟求值！</strong></font></p>
<blockquote>
<p><font size="4"><strong>defer 执行的时机</strong></font></p>
<p>在 Go 语言的函数中 return 语句在底层并不是原子操作，它分为给返回值赋值和 RET 指令两步。而 defer 语句执行的时机就在返回值赋值操作后，RET 指令执行前。具体如下图所示：</p>
<p><img src="/img/load5.gif" data-original="https://cdn.jsdelivr.net/gh/hahahaha5606/blogImage/images/image-20250516154224231.png" alt="image-20250516154224231" style="zoom:80%;"></p>
<p>因此 defer 注册要延迟执行的语句时该函数所有的参数都需要确定其值。defer 执行时机的相关例子如下：</p>
<p></p><div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">例子1</button><button type="button" class="tab " data-href="样例-2">例子2</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><blockquote>
<p></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> <span class="type">int</span> {</span><br><span class="line">	x := <span class="number">5</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		x++</span><br><span class="line">	}()</span><br><span class="line">	<span class="keyword">return</span> x <span class="comment">// 5（defer 语句中的闭包捕获的是 x 的副本）</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span></span> (x <span class="type">int</span>) {</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		x++</span><br><span class="line">	}()</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span> <span class="comment">// 6（函数声明了命名返回值 x，defer 语句中的闭包捕获的是返回值 x 的引用）</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">()</span></span> (y <span class="type">int</span>) {</span><br><span class="line">	x := <span class="number">5</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		x++</span><br><span class="line">	}()</span><br><span class="line">	<span class="keyword">return</span> x <span class="comment">//5（虽然函数声明了命名返回值 y，但函数内声明了新的局部变量 x，defer 语句中的闭包捕获的是 x 的副本）</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f4</span><span class="params">()</span></span> (x <span class="type">int</span>) {</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> { <span class="comment">//此 x 非彼 x</span></span><br><span class="line">		x++</span><br><span class="line">		fmt.Println(x) <span class="comment">//1</span></span><br><span class="line">	}(x)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span> <span class="comment">// 5（当执行 defer 语句时， x 的值是0，因为此时 x 未被赋值，之后执行 return 5）</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	fmt.Println(f1()) <span class="comment">// 5</span></span><br><span class="line">	fmt.Println(f2()) <span class="comment">// 6</span></span><br><span class="line">	fmt.Println(f3()) <span class="comment">// 5</span></span><br><span class="line">	fmt.Println(f4()) <span class="comment">// 5</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
</blockquote></div><div class="tab-item-content" id="样例-2"><blockquote>
<p></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(index <span class="type">string</span>, a, b <span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">	ret := a + b</span><br><span class="line">	fmt.Println(index, a, b, ret)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	x := <span class="number">1</span></span><br><span class="line">	y := <span class="number">2</span></span><br><span class="line">	<span class="keyword">defer</span> calc(<span class="string">"AA"</span>, x, calc(<span class="string">"A"</span>, x, y)) <span class="comment">// defer 语句的参数在声明时就会求值</span></span><br><span class="line">	x = <span class="number">10</span></span><br><span class="line">	<span class="keyword">defer</span> calc(<span class="string">"BB"</span>, x, calc(<span class="string">"B"</span>, x, y))</span><br><span class="line">	y = <span class="number">20</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">A 1 2 3</span></span><br><span class="line"><span class="comment">B 10 2 12</span></span><br><span class="line"><span class="comment">BB 10 12 22</span></span><br><span class="line"><span class="comment">AA 1 3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p></p>
</blockquote></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p></p>
</blockquote>
<p>由于 defer 语句延迟调用的特性，所以 defer 语句能非常方便的处理<strong>资源释放问题</strong>。比如：资源清理、文件关闭、解锁及记录时间等。</p>
<h3 id="常见内置函数">11.6.常见内置函数</h3>
<table class="table-2 table-2-sm">
<thead class="thead-dark">
<tr>
<th width="25%">
内置函数
</th>
<th align="center">
介绍
</th>
</tr>
</thead>
<tbody>
<tr class="alert" role="alert">
<th scope="row" width="25%">
close
</th>
<td align="left">
主要用来关闭 channel
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row" width="16%">
len
</th>
<td align="left">
用来求长度，比如 string、array、slice、map、channel
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row" width="16%">
new
</th>
<td align="left">
用来分配内存，可以用来分配值类型，比如 int、struct，或引用类型，比如指针。返回的是指针
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row" width="16%">
make
</th>
<td align="left">
用来分配内存，主要用来分配引用类型，比如 channel、map、slice
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row" width="16%">
append
</th>
<td align="left">
用来追加元素到数组、slice 中
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row" width="16%">
panic 和 recover
</th>
<td align="left">
用来做错误处理
</td>
</tr>
</tbody>
</table>
<p><font color="#4eb434" size="5"><strong>new 函数分配内存</strong></font></p>
<p>new 是一个内置的函数，它的函数签名如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span></span> *Type</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>new 函数只接受一个参数，这个参数是一个类型（Type）</li>
<li>new 函数返回一个指向该类型内存地址的指针</li>
</ul>
<p><font color="#ef042a">实际上开发中 new 函数不太常用</font>，<strong>使用 new 函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值</strong>。举个例子：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	a := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">	b := <span class="built_in">new</span>(<span class="type">bool</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"%T\n"</span>, a) <span class="comment">// *int</span></span><br><span class="line">	fmt.Printf(<span class="string">"%T\n"</span>, b) <span class="comment">// *bool</span></span><br><span class="line">	fmt.Println(*a)       <span class="comment">// 0</span></span><br><span class="line">	fmt.Println(*b)       <span class="comment">// false</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当代码中 var a *int 只是声明了一个指针变量 a 但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> a *<span class="type">int</span>	<span class="comment">// 这里没有初始化，后续需要使用new函数分配内存完成初始化后才能赋值</span></span><br><span class="line">	a = <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">	*a = <span class="number">10</span></span><br><span class="line">	fmt.Println(*a) <span class="comment">// 10</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><font color="#4eb434" size="5"><strong>make 函数分配内存</strong></font></p>
<p>make 也是用于内存分配的，区别于 new，它<strong>只用于 slice、map 以及 channel 的内存创建，而且它返回的类型就是这三个类型本身</strong>，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make 函数的函数签名如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span></span> Type</span><br></pre></td></tr></tbody></table></figure>
<p>我们在使用 slice、map 以及 channel 的时候，如果声明后未赋值（对于引用类型未完成初始化），都需要使用 make 进行初始化，然后才可以对它们进行操作，如：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> userinfo <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">	userinfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">	userinfo[<span class="string">"username"</span>] = <span class="string">"张三"</span></span><br><span class="line">	fmt.Println(userinfo) <span class="comment">// map[username:张三]</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><font color="#4eb434" size="5"><strong>panic / recover 函数</strong></font></p>
<p>Go 语言中使用 panic / recover 模式来处理错误。 <strong>panic 可以在任何地方引发，但 recover 只有在 defer 调用的函数中有效，且 defer 一定要在可能引发 panic 的语句之前定义</strong>。 例子如下：</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">例子1</button><button type="button" class="tab " data-href="样例-2">例子2</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"func A"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcB</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		err := <span class="built_in">recover</span>()</span><br><span class="line">		<span class="comment">//如果程序出出现了 panic 错误,可以通过 recover 恢复过来，但此函数中之后的语句不再执行</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> { <span class="comment">//这里也可以写成：if err := recover(); err != nil {</span></span><br><span class="line">			fmt.Println(<span class="string">"recover in B"</span>)</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		}</span><br><span class="line">	}()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"panic in B"</span>)	<span class="comment">//如果不写 recover，程序将在执行到 panic 语句时引发崩溃退出</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcC</span><span class="params">()</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"func C"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	funcA()</span><br><span class="line">	funcB()</span><br><span class="line">	funcC()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span></span></span><br><span class="line"><span class="built_in">recover</span> in B</span><br><span class="line"><span class="built_in">panic</span> in B</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">C</span></span></span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(fileName <span class="type">string</span>)</span></span> <span class="type">error</span> {</span><br><span class="line">	<span class="keyword">if</span> fileName == <span class="string">"main.go"</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> errors.New(<span class="string">"读取文件错误"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn3</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		err := <span class="built_in">recover</span>()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			fmt.Println(<span class="string">"抛出异常给管理员发送邮件"</span>)</span><br><span class="line">		}</span><br><span class="line">	}()</span><br><span class="line">	<span class="keyword">var</span> err = readFile(<span class="string">"xxx.go"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(<span class="string">"继续执行"</span>) <span class="comment">// recover 后函数中的语句不再执行</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	fn3()</span><br><span class="line">	fmt.Println(<span class="string">"继续执行 main "</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">读取文件错误</span><br><span class="line">抛出异常给管理员发送邮件</span><br><span class="line">继续执行 main </span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h2 id="time-包及日期函数">12.time 包及日期函数</h2>
<p>Go 语言中 time 包提供了时间的显示和测量用的函数。</p>
<p><font color="#4eb434" size="4"><strong>获取当前时间 time.Now() 并按格式输出</strong></font></p>
<p>先通过 time.Now() 函数获取当前的时间对象，然后获取时间对象的年月日时分秒等信</p>
<p>息，最后定义时间对象的输出格式 Format 打印时间：</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">代码</button><button type="button" class="tab " data-href="样例-2">预览</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	now := time.Now() <span class="comment">//获取当前时间</span></span><br><span class="line">	fmt.Printf(<span class="string">"current time:%v\n"</span>, now)</span><br><span class="line">	year := now.Year()     <span class="comment">//年</span></span><br><span class="line">	month := now.Month()   <span class="comment">//月</span></span><br><span class="line">	day := now.Day()       <span class="comment">//日</span></span><br><span class="line">	hour := now.Hour()     <span class="comment">//小时</span></span><br><span class="line">	minute := now.Minute() <span class="comment">//分钟</span></span><br><span class="line">	second := now.Second() <span class="comment">//秒</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 格式化的模板为 Go 的出生时间 2006 年 1 月 2 号 15 点 04 分 Mon Jan，更改时间模板将导致输出时间错误</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"格式1 "</span>, now)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*%02d 中的 2 表示宽度，如果整数不够 2 列就补上 0*/</span></span><br><span class="line">	fmt.Printf(<span class="string">"格式2 %d-%02d-%02d %02d:%02d:%02d\n"</span>, year, month, day, hour, minute, second)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*24 小时制*/</span></span><br><span class="line">	fmt.Println(<span class="string">"格式3 "</span>, now.Format(<span class="string">"2006-01-02 15:04:05"</span>))</span><br><span class="line">	fmt.Println(<span class="string">"格式4 "</span>, now.Format(<span class="string">"2006/01/02 15:04"</span>))</span><br><span class="line">	fmt.Println(<span class="string">"格式5 "</span>, now.Format(<span class="string">"15:04 2006/01/02"</span>))</span><br><span class="line">	<span class="comment">/*小数点后会输出毫秒*/</span></span><br><span class="line">	fmt.Println(<span class="string">"格式6 "</span>, now.Format(<span class="string">"2006-01-02 15:04:05.000 Mon Jan"</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*12 小时制*/</span></span><br><span class="line">	fmt.Println(<span class="string">"格式7 "</span>, now.Format(<span class="string">"2006-01-02 03:04:05 PM"</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*只获取年月日*/</span></span><br><span class="line">	fmt.Println(<span class="string">"格式8 "</span>, now.Format(<span class="string">"2006-01-02"</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*只获取时分秒*/</span></span><br><span class="line">	fmt.Println(<span class="string">"格式9 "</span>, now.Format(<span class="string">"15:04:05"</span>))</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">current time:<span class="number">2025</span><span class="number">-05</span><span class="number">-17</span> <span class="number">10</span>:<span class="number">43</span>:<span class="number">25.1108014</span> +<span class="number">0800</span> CST m=+<span class="number">0.000549101</span></span><br><span class="line">格式<span class="number">1</span>  <span class="number">2025</span><span class="number">-05</span><span class="number">-17</span> <span class="number">10</span>:<span class="number">43</span>:<span class="number">25.1108014</span> +<span class="number">0800</span> CST m=+<span class="number">0.000549101</span></span><br><span class="line">格式<span class="number">2</span> <span class="number">2025</span><span class="number">-05</span><span class="number">-17</span> <span class="number">10</span>:<span class="number">43</span>:<span class="number">25</span></span><br><span class="line">格式<span class="number">3</span>  <span class="number">2025</span><span class="number">-05</span><span class="number">-17</span> <span class="number">10</span>:<span class="number">43</span>:<span class="number">25</span></span><br><span class="line">格式<span class="number">4</span>  <span class="number">2025</span>/<span class="number">05</span>/<span class="number">17</span> <span class="number">10</span>:<span class="number">43</span></span><br><span class="line">格式<span class="number">5</span>  <span class="number">10</span>:<span class="number">43</span> <span class="number">2025</span>/<span class="number">05</span>/<span class="number">17</span></span><br><span class="line">格式<span class="number">6</span>  <span class="number">2025</span><span class="number">-05</span><span class="number">-17</span> <span class="number">10</span>:<span class="number">43</span>:<span class="number">25.110</span> Sat May</span><br><span class="line">格式<span class="number">7</span>  <span class="number">2025</span><span class="number">-05</span><span class="number">-17</span> <span class="number">10</span>:<span class="number">43</span>:<span class="number">25</span> AM</span><br><span class="line">格式<span class="number">8</span>  <span class="number">2025</span><span class="number">-05</span><span class="number">-17</span></span><br><span class="line">格式<span class="number">9</span>  <span class="number">10</span>:<span class="number">43</span>:<span class="number">25</span></span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><font color="#4eb434" size="4"><strong>时间戳</strong></font></p>
<blockquote>
<p>Unix纪元，即1970年1月1日 00:00:00 UTC，被广泛采用为计算机系统中的标准时间起点。该时间点是在Unix操作系统开发时期选择的，可以覆盖大多数计算机系统的使用时间。这个时间点之后的时间戳不会出现负数，简化了时间计算。32位系统可以表示到2038年，64位系统可以表示到更远的未来。</p>
<p>需要注意的是，由于32位系统的时间戳限制，在2038年1月19日 03:14:07 UTC 时会出现所谓的"2038年问题"（Year 2038 problem）。不过，现代系统大多使用64位时间戳，可以表示到更远的未来，所以这个问题已经得到了解决。</p>
</blockquote>
<p>时间戳是自 1970 年 1 月 1 日（08:00:00GMT）至当前时间的<strong>总毫秒数</strong>。它也被称为 Unix 时间戳（UnixTimestamp）。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用 time.Unix()函数可以将时间戳转为时间格式：年-月-日 时:分:秒*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unixToTime</span><span class="params">(timestamp <span class="type">int64</span>)</span></span> {</span><br><span class="line">	timeObj := time.Unix(timestamp, <span class="number">0</span>) <span class="comment">//将时间戳转为时间格式, 第一个参数是秒数，第二个参数是纳秒数</span></span><br><span class="line">	fmt.Println(<span class="string">"UnixToTime 1:"</span>, timeObj.Format(<span class="string">"2006-01-02 15:04:05"</span>))</span><br><span class="line"></span><br><span class="line">	year := timeObj.Year()     <span class="comment">//年</span></span><br><span class="line">	month := timeObj.Month()   <span class="comment">//月</span></span><br><span class="line">	day := timeObj.Day()       <span class="comment">//日</span></span><br><span class="line">	hour := timeObj.Hour()     <span class="comment">//小时</span></span><br><span class="line">	minute := timeObj.Minute() <span class="comment">//分钟</span></span><br><span class="line">	second := timeObj.Second() <span class="comment">//秒</span></span><br><span class="line">	fmt.Printf(<span class="string">"UnixToTime 2:%d-%02d-%02d %02d:%02d:%02d\n"</span>, year, month, day, hour, minute, second)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将时间字符串格式转化为时间戳*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeStrToUnix</span><span class="params">(timeStr <span class="type">string</span>)</span></span> {</span><br><span class="line">	timeTemplate := <span class="string">"2006-01-02 15:04:05"</span> <span class="comment">//常规类型</span></span><br><span class="line">	stamp, _ := time.ParseInLocation(timeTemplate, timeStr, time.Local)</span><br><span class="line">	fmt.Println(<span class="string">"TimeStrToUnix:"</span>, stamp.Unix())</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	now := time.Now()                                 <span class="comment">//获取当前时间</span></span><br><span class="line">	timestamp1 := now.Unix()                          <span class="comment">//时间戳</span></span><br><span class="line">	timestamp2 := now.UnixNano()                      <span class="comment">//纳秒时间戳</span></span><br><span class="line">	fmt.Printf(<span class="string">"current timestamp1:%v\n"</span>, timestamp1) <span class="comment">//current timestamp1:1747463390</span></span><br><span class="line">	fmt.Printf(<span class="string">"current timestamp2:%v\n"</span>, timestamp2) <span class="comment">//current timestamp2:1747463390352237200</span></span><br><span class="line"></span><br><span class="line">	unixToTime(timestamp1)</span><br><span class="line">	<span class="comment">/*UnixToTime 1: 2025-05-17 14:29:50</span></span><br><span class="line"><span class="comment">	nixToTime 2:2025-05-17 14:29:50*/</span></span><br><span class="line"></span><br><span class="line">	unixToTime(timestamp2)</span><br><span class="line">	<span class="comment">/*UnixToTime 1: 55374912397-02-05 17:53:20</span></span><br><span class="line"><span class="comment">	UnixToTime 2:55374912397-02-05 17:53:20*/</span></span><br><span class="line"></span><br><span class="line">	timeStrToUnix(<span class="string">"2025-05-17 10:53:24"</span>) <span class="comment">//TimeStrToUnix: 1747450404</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><font color="#4eb434" size="4"><strong>时间间隔</strong></font></p>
<p>time.Duration 是 time 包定义的一个类型，它代表两个时间点之间经过的时间，以纳秒为单位。time.Duration 表示一段时间间隔，可表示的最长时间段大约 290 年。</p>
<p>time 包中定义的时间间隔类型的常量如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Nanosecond  Duration = <span class="number">1</span>		<span class="comment">// time.Duration 表示 1 纳秒</span></span><br><span class="line">	Microsecond          = <span class="number">1000</span> * Nanosecond</span><br><span class="line">	Millisecond          = <span class="number">1000</span> * Microsecond</span><br><span class="line">	Second               = <span class="number">1000</span> * Millisecond	<span class="comment">//time.Second 表示 1 秒</span></span><br><span class="line">	Minute               = <span class="number">60</span> * Second</span><br><span class="line">	Hour                 = <span class="number">60</span> * Minute</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p><font color="#4eb434" size="4"><strong>时间操作函数</strong></font></p>
<blockquote>
<p>常见使用场景：<strong>计算程序运行耗时</strong></p>
<p></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">start := time.Now().Unix()</span><br><span class="line">...</span><br><span class="line">end := time.Now().Unix()</span><br><span class="line">fmt.Println(<span class="string">"方法耗时 = "</span>, end-start) <span class="comment">// 毫秒数</span></span><br></pre></td></tr></tbody></table></figure><p></p>
</blockquote>
<p>假设现在的时间：<code>now := time.Now()</code></p>
<ol type="1">
<li>时间相加（加上两小时后的时间）：<code>now.Add(time.Hour * 2)</code></li>
<li>时间相减（减去一小时后的时间）：<code>now.Add(-time.Hour * 2)</code></li>
<li>两时间段之间的差值：<code>timeA.Sub(timeB)</code>，以 x<strong>h</strong>x<strong>m</strong>x<strong>s</strong>的形式返回持续时间 / 这里直接用 “-” 号也可</li>
<li>判断两时区的时间是否相同：<code>timeA.Equal(timeB)</code></li>
<li>判断A时间是否在B时间之前：<code>timeA.Before(timeB)</code></li>
<li>判断A时间是否在B时间之后：<code>timeA.After(timeB)</code></li>
</ol>
<blockquote>
<p><strong>实际代码中的函数：</strong></p>
<ol type="1">
<li>时间相加：<code>func (t Time) Add(d Duration) Time</code></li>
<li>两时间段之间的差值 t - u：<code>func (t Time) Sub(u Time) Duration</code></li>
<li>判断两时区的时间是否相同 t == u：<code>func (t Time) Equal(u Time) bool</code></li>
<li>判断 t 时间是否在 u 时间之前：<code>func (t Time) Before(u Time) bool</code></li>
<li>判断 t 时间是否在 u 时间之后：<code>func (t Time) After(u Time) bool</code></li>
</ol>
</blockquote>
<p>时间操作的使用示例如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	now := time.Now()                  <span class="comment">//获取当前时间</span></span><br><span class="line">	later := now.Add(time.Hour * <span class="number">24</span>)   <span class="comment">//加24小时</span></span><br><span class="line">	before := now.Add(-time.Hour * <span class="number">24</span>) <span class="comment">//减24小时</span></span><br><span class="line"></span><br><span class="line">	duration1 := later.Sub(before)</span><br><span class="line">	duration2 := before.Sub(later)</span><br><span class="line"></span><br><span class="line">	bool1 := duration1 &gt; duration2</span><br><span class="line">	bool2 := later.Equal(before)</span><br><span class="line">	bool3 := later.Before(before)</span><br><span class="line">	bool4 := later.After(before)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"later:"</span>, later)         <span class="comment">//later: 2025-05-18 14:48:30.470298 +0800 CST m=+86400.000000001</span></span><br><span class="line">	fmt.Println(<span class="string">"before:"</span>, before)       <span class="comment">//before: 2025-05-16 14:48:30.470298 +0800 CST m=-86399.999999999</span></span><br><span class="line">	fmt.Println(<span class="string">"duration1:"</span>, duration1) <span class="comment">//duration1: 48h0m0s</span></span><br><span class="line">	fmt.Println(<span class="string">"duration2:"</span>, duration2) <span class="comment">//duration2: -48h0m0s</span></span><br><span class="line">	fmt.Println(<span class="string">"bool1:"</span>, bool1)         <span class="comment">//bool1: true</span></span><br><span class="line">	fmt.Println(<span class="string">"bool2:"</span>, bool2)         <span class="comment">//bool2: false</span></span><br><span class="line">	fmt.Println(<span class="string">"bool3:"</span>, bool3)         <span class="comment">//bool3: false</span></span><br><span class="line">	fmt.Println(<span class="string">"bool4:"</span>, bool4)         <span class="comment">//bool4: true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><font color="#985fff" size="4"><strong>定时器</strong></font></p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">time.NewTicker(时间间隔)设置定时器</button><button type="button" class="tab " data-href="样例-2">time.Sleep(time.Second) 实现定时器</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	ticker := time.NewTicker(time.Second) <span class="comment">//定义一个 1 秒间隔的定时器</span></span><br><span class="line">	n := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> ticker.C {	<span class="comment">//ticker.C 是 time.Ticker 类型的一个通道（channel）。它会在每个设定的时间间隔（这里是1秒）到达时，将当前时间值传递到这个通道中</span></span><br><span class="line">		fmt.Println(i) <span class="comment">//每秒都会执行的任务</span></span><br><span class="line">		n++</span><br><span class="line">		<span class="keyword">if</span> n &gt; <span class="number">5</span> {</span><br><span class="line">			ticker.Stop()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 2025-05-17 14:58:14.9935697 +0800 CST m=+1.000000001</span></span><br><span class="line"><span class="comment">// 2025-05-17 14:58:15.9935697 +0800 CST m=+2.000000001</span></span><br><span class="line"><span class="comment">// 2025-05-17 14:58:16.9935697 +0800 CST m=+3.000000001</span></span><br><span class="line"><span class="comment">// 2025-05-17 14:58:17.9935697 +0800 CST m=+4.000000001</span></span><br><span class="line"><span class="comment">// 2025-05-17 14:58:18.9935697 +0800 CST m=+5.000000001</span></span><br><span class="line"><span class="comment">// 2025-05-17 14:58:19.9935697 +0800 CST m=+6.000000001</span></span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">for</span> {		<span class="comment">// 无限循环，每隔一秒更新输出一次</span></span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		fmt.Println(<span class="string">"我在定时执行任务"</span>)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h2 id="指针">13.指针</h2>
<p>我们知道变量是用来存储数据的，变量的本质是给存储数据的内存地址起了一个好记的别名。比如我们定义了一个变量 a := 10 ,这个时候可以直接通过 a 这个变量名来读取内存地址中保存的 10 这个值。在计算机底层 a 这个变量其实对应了一个内存地址，这个内存地址存储的值 10 就是变量 a 的值。</p>
<p><strong>指针</strong>也是一个变量，但它是一种特殊的变量，它存储的数据不是一个普通的值，而是<strong>另一个变量的内存地址</strong>（如下图）。</p>
<p><img src="/img/load4.gif" data-original="https://cdn.jsdelivr.net/gh/hahahaha5606/blogImage/images/image-20250517151014309.png" alt="image-20250517151014309" style="zoom:80%;"></p>
<p><strong>Go</strong> <strong>语言中的指针操作非常简单，我们只需要记住两个符号</strong>：<strong>&amp;（取地址）和 *（根据地址取值）</strong>。在上图中，*int 得到的是变量 p 的值，&amp;a 得到的是变量 a 的地址，合起来就表示“将 a 的地址作为 p 的值”。</p>
<p>定义变量X指针的一般格式为：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ptr *T = &amp;X （这里的 T 是指针变量的类型） 或	</span><br><span class="line">ptr := &amp;X</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</li>
<li>指针变量的值是指针指向的地址。</li>
<li>对指针变量进行取值（*）操作，可以获得指针变量指向的地址的值。（注意，取值操作只能对指针变量进行）</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">	<span class="keyword">var</span> ptrA *<span class="type">int</span> = &amp;a</span><br><span class="line">	fmt.Println(ptrA)  <span class="comment">// a 的内存地址 0xc00000a0e8</span></span><br><span class="line">	fmt.Println(*ptrA) <span class="comment">// a 的值 10</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> A = &amp;a</span><br><span class="line">	fmt.Println(A)  <span class="comment">// a 的内存地址 0xc00000a0e8</span></span><br><span class="line">	fmt.Println(*A) <span class="comment">// a 的值 10</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><font color="#ef042a"><strong>可以利用指针传值的特性在函数中修改变量值</strong></font>：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify1</span><span class="params">(x <span class="type">int</span>)</span></span> {</span><br><span class="line">	x = <span class="number">100</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify2</span><span class="params">(x *<span class="type">int</span>)</span></span> {</span><br><span class="line">	*x = <span class="number">100</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	a := <span class="number">10</span></span><br><span class="line">	modify1(a)</span><br><span class="line">	fmt.Println(a) <span class="comment">// 10</span></span><br><span class="line">	modify2(&amp;a)</span><br><span class="line">	fmt.Println(a) <span class="comment">// 100</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="结构体">14.结构体</h2>
<p>Golang 中没有“类”的概念，Golang 中的结构体和其他语言中的类有点相似。和其他面向对象语言中的类相比，Golang 中的结构体具有更高的扩展性和灵活性。</p>
<p>Golang 中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型就无法满足需求了，Golang 提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称 struct。也就是我们可以通过 struct 来定义自己的类型了。</p>
<p>Golang 中不仅可以通过 type 关键词定义函数类型、数据类型，还能定义一个结构体。</p>
<blockquote>
<p>type 关键词定义数据类型</p>
<ul>
<li>自定义数据类型：<code>type 新类型名称 数据类型</code></li>
<li>定义数据类型别名：<code>type 数据类型别名 = 数据类型</code></li>
</ul>
<p></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型定义</span></span><br><span class="line"><span class="keyword">type</span> newInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">type</span> myInt = <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> a newInt</span><br><span class="line">	<span class="keyword">var</span> b myInt</span><br><span class="line">	fmt.Printf(<span class="string">"type of a:%T\n"</span>, a) <span class="comment">//type of a:main.newInt (main 包下定义的 newInt 类型)</span></span><br><span class="line">	fmt.Printf(<span class="string">"type of b:%T\n"</span>, b) <span class="comment">//type of b:int (还是 int 类型)</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
</blockquote>
<h3 id="结构体的定义">14.1.结构体的定义</h3>
<p>一般使用 type 和 struct 关键字来定义结构体，具体代码格式如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> {</span><br><span class="line">  字段名 字段类型	<span class="comment">// 不需要加逗号</span></span><br><span class="line">  字段名 字段类型</span><br><span class="line">  …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>类型名</strong>：表示自定义结构体的名称，在同一个包内不能重复。首字母可以大写也可以小写，<strong>大写表示这个结构体是公有的</strong>，在其他的包里面可以使用。小写表示这个结构体是私有的，只有这个包里面才能使用。</li>
<li><strong>字段名</strong>：表示结构体字段名。结构体中的字段名必须唯一。</li>
<li><strong>字段类型</strong>：表示结构体字段的具体类型。</li>
</ul>
<p>注：同样类型的字段也可以写在一行，如 <code>name, city string</code></p>
<h3 id="结构体实例化的几种方法">14.2.结构体实例化的几种方法</h3>
<p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。除最后一种实例化方法外，没有初始值的字段，函数将为其自动赋予字段类型的默认值。</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">声明变量法</button><button type="button" class="tab " data-href="样例-2">new关键字法</button><button type="button" class="tab " data-href="样例-3">取地址法</button><button type="button" class="tab " data-href="样例-4">键值对初始化法</button><button type="button" class="tab " data-href="样例-5">结构体指针+键值对法</button><button type="button" class="tab " data-href="样例-6">值列表初始化法</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><p>结构体本身也是一种类型，我们可以像声明内置类型一样使用 var 关键字声明结构体类型：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例 结构体类型</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> {</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	city <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> p1 person <span class="comment">// 结构体的实例</span></span><br><span class="line">	p1.name = <span class="string">"张三"</span></span><br><span class="line">	p1.city = <span class="string">"北京"</span></span><br><span class="line">	p1.age = <span class="number">18</span></span><br><span class="line">	fmt.Printf(<span class="string">"p1=%v\n"</span>, p1)  <span class="comment">//p1={张三 北京 18}</span></span><br><span class="line">	fmt.Printf(<span class="string">"p1=%#v\n"</span>, p1) <span class="comment">//p1=main.person{name:"张三", city:"北京", age:18}</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><p>我们还可以通过使用 new 关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> {</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	city <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> p2 = <span class="built_in">new</span>(person) <span class="comment">// new 函数返回的是指针</span></span><br><span class="line">	p2.name = <span class="string">"张三"</span></span><br><span class="line">	p2.age = <span class="number">20</span></span><br><span class="line">	p2.city = <span class="string">"北京"</span></span><br><span class="line">	fmt.Printf(<span class="string">"%T\n"</span>, p2)     <span class="comment">//*main.person</span></span><br><span class="line">	fmt.Printf(<span class="string">"p2=%#v\n"</span>, p2) <span class="comment">//p2=&amp;main.person{name:"张三", city:"北京", age:20}</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从打印的结果中我们可以看出 p2 是一个结构体指针。</p>
<p><strong>注意</strong>：在 Golang 中支持对<strong>结构体指针</strong>的直接使用，来访问结构体的成员属性。p2.name = "张三" 其实在底层是(*p2).name = "张三。</p></div><div class="tab-item-content" id="样例-3"><p>使用&amp;对结构体进行取地址操作相当于对该结构体类型进行了一次 new 实例化操作。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> {</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	city <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	p3 := &amp;person{}            <span class="comment">// p3 相当于一个结构体指针</span></span><br><span class="line">	fmt.Printf(<span class="string">"%T\n"</span>, p3)     <span class="comment">//*main.person</span></span><br><span class="line">	fmt.Printf(<span class="string">"p3=%#v\n"</span>, p3) <span class="comment">//p3=&amp;main.person{name:"", city:"", age:0}</span></span><br><span class="line">	p3.name = <span class="string">"zhangsan"</span></span><br><span class="line">	p3.age = <span class="number">30</span></span><br><span class="line">	p3.city = <span class="string">"深圳"</span></span><br><span class="line">	(*p3).age = <span class="number">40</span>             <span class="comment">//这样也是可以的</span></span><br><span class="line">	fmt.Printf(<span class="string">"p3=%#v\n"</span>, p3) <span class="comment">//p3=&amp;main.person{name:"zhangsan", city:"深圳", age:40}</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-4"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> {</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	city <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	p4 := person{</span><br><span class="line">		name: <span class="string">"zhangsan"</span>,</span><br><span class="line">		city: <span class="string">"北京"</span>,</span><br><span class="line">		age:  <span class="number">18</span>, <span class="comment">// 即使最后一个属性也要加上逗号！否则会报错</span></span><br><span class="line">	}</span><br><span class="line">	fmt.Printf(<span class="string">"p4=%#v\n"</span>, p4) <span class="comment">//p4=main.person{name:"zhangsan", city:"北京", age:18}</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-5"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> {</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	city <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	p5 := &amp;person{</span><br><span class="line">		name: <span class="string">"zhangsan"</span>,</span><br><span class="line">		city: <span class="string">"上海"</span>, <span class="comment">// 没有初始值的字段可以不写，函数将自动赋值</span></span><br><span class="line">	}</span><br><span class="line">	fmt.Printf(<span class="string">"p5=%#v\n"</span>, p5) <span class="comment">//p5=&amp;main.person{name:"zhangsan", city:"上海", age:0}</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-6"><p>初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值。但是该写法需要注意：</p>
<ul>
<li>必须初始化结构体的所有字段。</li>
<li>初始值的填充顺序必须与字段在结构体中的声明顺序一致。</li>
<li>该方式不能和键值初始化方式混用。</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> {</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	city <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：</span></span><br><span class="line">	p7 := &amp;person{<span class="string">"zhangsan"</span>, <span class="string">"北京"</span>, <span class="number">28</span>}</span><br><span class="line">	fmt.Printf(<span class="string">"p7=%#v\n"</span>, p7) <span class="comment">//p7=&amp;main.person{name:"zhangsan", city:"北京", age:28}</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h3 id="结构体方法和接收者">14.3.结构体方法和接收者</h3>
<p>在 go 语言中，没有类的概念但是可以给类型（结构体，自定义类型）定义方法。所谓方法就是定义了接收者的函数。接收者的概念就类似于其他语言中的 this 或者 self。</p>
<p>格式如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span></span> 方法名(参数列表) (返回参数) {</span><br><span class="line">	函数体</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>接收者变量：</strong>接收者中的参数变量名在命名时，官方建议使用接收者类型名的第一个小写字母，而不是 self、this 之类的命名。例如，Person 类型的接收者变量应该命名为 p，Connector 类型的接收者变量应该命名为 c 等。</li>
<li><strong>接收者类型</strong>：接收者类型和参数类似，可以是指针类型和非指针类型。</li>
<li><strong>方法名、参数列表、返回参数</strong>：具体格式与函数定义相同。</li>
</ul>
<details class="toggle"><summary class="toggle-button" style="">一个简单的例子</summary><div class="toggle-content"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> {</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int8</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> printInfo() {</span><br><span class="line">	fmt.Printf(<span class="string">"姓名:%v 年龄:%v"</span>, p.name, p.age)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	p1 := Person{</span><br><span class="line">		name: <span class="string">"小王子"</span>,</span><br><span class="line">		age:  <span class="number">25</span>,</span><br><span class="line">	}</span><br><span class="line">	p1.printInfo() <span class="comment">// 姓名:小王子 年龄:25</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</div></details>
<p><strong>1、值类型的接收者</strong></p>
<p>当方法作用于值类型接收者时，Go 语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</p>
<p><strong>2、指针类型的接收者</strong></p>
<p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的 this 或者 self。</p>
<p><font color="#985fff"><strong>因此当我们希望该方法能直接修改传入参数的值时，应该使用传入参数的指针变量 (&amp; 传入参数，* 接收传入参数) !</strong></font></p>
<blockquote>
<p>事实上，在 Go 语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法（非本地类型不能定义方法，也就是说<u>我们不能给别的包的类型定义方法</u>）。</p>
<p>举个例子，我们基于内置的 int 类型使用 type 关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。</p>
<p></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m myInt)</span></span> SayHello() {</span><br><span class="line">	fmt.Println(<span class="string">"Hello, 我是一个 int。"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> m1 myInt</span><br><span class="line">	m1.SayHello() <span class="comment">//Hello, 我是一个 int。</span></span><br><span class="line">	m1 = <span class="number">100</span></span><br><span class="line">	fmt.Printf(<span class="string">"%#v %T\n"</span>, m1, m1) <span class="comment">//100 main.MyInt</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
</blockquote>
<h3 id="结构体的匿名字段">14.4.结构体的匿名字段</h3>
<p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。匿名字段默认采用类型名作为字段名，又由于结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person 结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> {</span><br><span class="line">	<span class="type">string</span></span><br><span class="line">	<span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	p1 := Person{<span class="string">"小王子"</span>, <span class="number">18</span>}</span><br><span class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, p1)        <span class="comment">//main.Person{string:"小王子", int:18}</span></span><br><span class="line">	fmt.Println(p1.<span class="type">string</span>, p1.<span class="type">int</span>) <span class="comment">//小王子 18</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="嵌套结构体">14.5.嵌套结构体</h3>
<p>一个结构体中可以嵌套包含另一个结构体或结构体指针。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> {</span><br><span class="line">	Province <span class="type">string</span></span><br><span class="line">	City     <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">	Name    <span class="type">string</span></span><br><span class="line">	Gender  <span class="type">string</span></span><br><span class="line">	Address Address</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	user1 := User{</span><br><span class="line">		Name:   <span class="string">"张三"</span>,</span><br><span class="line">		Gender: <span class="string">"男"</span>,</span><br><span class="line">		Address: Address{</span><br><span class="line">			Province: <span class="string">"广东"</span>,</span><br><span class="line">			City:     <span class="string">"深圳"</span>, <span class="comment">//记得最后一个字段的逗号</span></span><br><span class="line">		}, <span class="comment">//记得最后一个字段的逗号</span></span><br><span class="line">	}</span><br><span class="line">	fmt.Printf(<span class="string">"user1=%#v\n"</span>, user1)</span><br><span class="line">	<span class="comment">//user1=main.User{Name:" 张三 ", Gender:" 男 ", Address:main.Address{Province:"广东", City:"深圳"}}</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><font color="#4eb434" size="5"><strong>嵌套匿名结构体</strong></font></p>
<p>当访问结构体成员时会先直接在结构体中查找该字段，找不到再去匿名结构体中查找。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> {</span><br><span class="line">	Province <span class="type">string</span></span><br><span class="line">	City     <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">	Name    <span class="type">string</span></span><br><span class="line">	Gender  <span class="type">string</span></span><br><span class="line">	Address <span class="comment">// 匿名结构体</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 这样写仍然可行</span></span><br><span class="line">	user1 := User{</span><br><span class="line">		Name:   <span class="string">"张三"</span>,</span><br><span class="line">		Gender: <span class="string">"男"</span>,</span><br><span class="line">		Address: Address{</span><br><span class="line">			Province: <span class="string">"广东"</span>,</span><br><span class="line">			City:     <span class="string">"深圳"</span>, <span class="comment">//记得最后一个字段的逗号</span></span><br><span class="line">		}, <span class="comment">//记得最后一个字段的逗号</span></span><br><span class="line">	}</span><br><span class="line">	fmt.Printf(<span class="string">"user1=%#v\n"</span>, user1)</span><br><span class="line">	<span class="comment">//user1=main.User{Name:" 张三 ", Gender:" 男 ", Address:main.Address{Province:"广东", City:"深圳"}}</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> user2 User</span><br><span class="line">	user2.Name = <span class="string">"张三"</span></span><br><span class="line">	user2.Gender = <span class="string">"男"</span></span><br><span class="line">	user2.Address.Province = <span class="string">"广东"</span> <span class="comment">//通过匿名结构体.字段名访问</span></span><br><span class="line">	user2.City = <span class="string">"深圳"</span>             <span class="comment">//直接访问匿名结构体的字段名</span></span><br><span class="line">	fmt.Printf(<span class="string">"user2=%#v\n"</span>, user2)</span><br><span class="line">	<span class="comment">//user2=main.User{Name:" 张三 ", Gender:" 男 ", Address:main.Address{Province:"广东", City:"深圳"}}</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><font color="#4eb434" size="5"><strong>嵌套结构体的字段名冲突</strong></font></p>
<p>嵌套结构体内部可能存在相同的字段名。这个时候为了避免歧义需要指定具体的内嵌结构体的字段。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> {</span><br><span class="line">	Province   <span class="type">string</span></span><br><span class="line">	City       <span class="type">string</span></span><br><span class="line">	CreateTime <span class="type">string</span> <span class="comment">// 冲突字段</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Email 邮箱结构体</span></span><br><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> {</span><br><span class="line">	Account    <span class="type">string</span></span><br><span class="line">	CreateTime <span class="type">string</span> <span class="comment">// 冲突字段</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">	Name   <span class="type">string</span></span><br><span class="line">	Gender <span class="type">string</span></span><br><span class="line">	Address</span><br><span class="line">	Email</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> user3 User</span><br><span class="line">	user3.Name = <span class="string">"张三"</span></span><br><span class="line">	user3.Gender = <span class="string">"男"</span></span><br><span class="line">	<span class="comment">// user3.CreateTime = "2020" // 将报错 ambiguous selector user3.CreateTime</span></span><br><span class="line">	user3.Address.CreateTime = <span class="string">"2020"</span> <span class="comment">//指定 Address 结构体中的 CreateTime</span></span><br><span class="line">	user3.Email.CreateTime = <span class="string">"2021"</span>   <span class="comment">//指定 Email 结构体中的 CreateTime</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="结构体的继承">14.6.结构体的继承</h3>
<p>Go 语言中使用嵌套匿名结构体也可以实现其他编程语言中的继承。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Animal 动物（相当于父类）</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> {</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span></span> run() {</span><br><span class="line">	fmt.Printf(<span class="string">"%s 会运动！\n"</span>, a.name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗（继承父类 Animal 的属性）</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> {</span><br><span class="line">	Age     <span class="type">int8</span></span><br><span class="line">	*Animal <span class="comment">//通过嵌套匿名结构体的指针实现继承（这里用不用指针都可以）</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> wang() {</span><br><span class="line">	fmt.Printf(<span class="string">"%s 会汪汪汪~\n"</span>, d.name)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	d1 := &amp;Dog{</span><br><span class="line">		Age: <span class="number">4</span>,</span><br><span class="line">		Animal: &amp;Animal{ <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">			name: <span class="string">"阿奇"</span>,</span><br><span class="line">		},</span><br><span class="line">	}</span><br><span class="line">	d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">	d1.run()  <span class="comment">//乐乐会运动！</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="结构体和-json-相互转换">14.7.结构体和 JSON 相互转换</h3>
<p>当我们使用 Golang 要给 App 或者小程序提供 Api 接口数据，这个时候就需要涉及到结构体和 Json 之间的相互转换。</p>
<p>JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。<strong>Json</strong> <strong>的基本格式如下：</strong></p>
<ul>
<li><strong>对象（Object）</strong>：由一组键值对组成，使用大括号 <code>{}</code> 包含。</li>
<li><strong>数组（Array）</strong>：有序的值的集合，使用方括号 <code>[]</code> 包含。</li>
<li><strong>键（Key）</strong>：必须是字符串（用双引号 <code>" "</code> 包裹）。在同一个对象中，键不能重复，否则后面的会覆盖前面的。</li>
<li><strong>值（Value）</strong>：支持字符串（必须用双引号 <code>" "</code> 包裹）、数字（无需引号）、布尔值（true 或 false）、null（表示空值）、对象和数组。</li>
</ul>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"Alice"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"age"</span><span class="punctuation">:</span> <span class="number">30</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"isStudent"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"courses"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">"Math"</span><span class="punctuation">,</span> <span class="string">"Science"</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"address"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"city"</span><span class="punctuation">:</span> <span class="string">"New York"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"zip"</span><span class="punctuation">:</span> <span class="string">"10001"</span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"phone"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>结构体数据转化成 JSON 格式的字符串又称“<strong>Golang JSON</strong> <strong>序列化</strong>”，把 JSON 数据转化成 Golang 中的结构体对象即“<strong>Golang JSON</strong> <strong>的反序列化</strong>”。Golang 中 的序列化 和 反序列化 主要通过 "<strong>encoding/json</strong>" 包 中 的 <code>json.Marshal(结构体)</code> 和 <code>json.Unmarshal(JSON序列)</code> 方法实现。</p>
<blockquote>
<p>Map 和切片也可以进行序列化和反序列化。</p>
</blockquote>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">结构体对象转化成JSON字符串（序列化）</button><button type="button" class="tab " data-href="样例-2">JSON字符串转换成结构体对象（反序列化）</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><p>注意！小写的字段名（私有属性）不能被 json 包访问！</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> {</span><br><span class="line">	ID     <span class="type">int</span></span><br><span class="line">	Gender <span class="type">string</span></span><br><span class="line">  name   <span class="type">string</span> <span class="comment">//私有属性(小写)不能被 json 包访问</span></span><br><span class="line">	Sno    <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> s1 = Student{</span><br><span class="line">		ID:     <span class="number">1</span>,</span><br><span class="line">		Gender: <span class="string">"男"</span>,</span><br><span class="line">		name:   <span class="string">"李四"</span>,</span><br><span class="line">		Sno:    <span class="string">"s0001"</span>,</span><br><span class="line">	}</span><br><span class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, s1)     <span class="comment">// main.Student{ID:1, Gender:"男", name:"李四", Sno:"s0001"}</span></span><br><span class="line">	<span class="keyword">var</span> s, _ = json.Marshal(s1) <span class="comment">// 将结构体转换为 json 字符串 (序列化)</span></span><br><span class="line">	jsonStr := <span class="type">string</span>(s)</span><br><span class="line">	fmt.Println(jsonStr) <span class="comment">// {"ID":1,"Gender":"男","Sno":"s0001"}</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> {</span><br><span class="line">	ID     <span class="type">int</span></span><br><span class="line">	Gender <span class="type">string</span></span><br><span class="line">	Name   <span class="type">string</span></span><br><span class="line">	Sno    <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">/*写法1 (两种写法均可)*/</span></span><br><span class="line">	<span class="comment">/*var jsonStr = "{\"ID\":1,\"Gender\":\"男\",\"Name\":\"李四\",\"Sno\":\"s0001\"}"*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*写法2*/</span></span><br><span class="line">	<span class="keyword">var</span> jsonStr = <span class="string">`{"ID":1,"Gender":"男","Name":"李四","Sno":"s0001"}`</span> <span class="comment">//定义一个 Monster 实例</span></span><br><span class="line">	<span class="keyword">var</span> student Student</span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(jsonStr), &amp;student)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Printf(<span class="string">"unmarshal err=%v\n"</span>, err)</span><br><span class="line">	}</span><br><span class="line">	fmt.Printf(<span class="string">"反序列化后 student=%#v student.Name=%v \n"</span>, student, student.Name)</span><br><span class="line">	<span class="comment">// 反序列化后 student=main.Student{ID:1, Gender:"男", Name:"李四", Sno:"s0001"} student.Name=李四</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><font color="#4eb434" size="5"><strong>结构体标签 Tag</strong></font></p>
<p>Tag 是结构体的元信息，可以在运行的时候通过反射的机制读取出来。我们可以通过指定 Tag 实现 json 序列化该字段时的 key。Tag 在结构体字段的后方定义，由一对<strong>反引号</strong>包裹起来，具体的格式如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">`key1:"value1" key2:"value2"`</span></span><br></pre></td></tr></tbody></table></figure>
<p>结构体标签 Tag 由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对 Tag，不同的键值对之间使用空格分隔。</p>
<p><strong>注意事项：</strong> 为结构体编写 Tag 时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如<strong>不要在 key 和 value 之间添加空格</strong>。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> {</span><br><span class="line">	ID     <span class="type">int</span>    <span class="string">`json:"id"`</span> <span class="comment">//通过指定 tag 实现 json 序列化该字段时的 key</span></span><br><span class="line">	Gender <span class="type">string</span> <span class="string">`json:"gender"`</span></span><br><span class="line">	Name   <span class="type">string</span></span><br><span class="line">	Sno    <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> s1 = Student{</span><br><span class="line">		ID:     <span class="number">1</span>,</span><br><span class="line">		Gender: <span class="string">"男"</span>,</span><br><span class="line">		Name:   <span class="string">"李四"</span>,</span><br><span class="line">		Sno:    <span class="string">"s0001"</span>,</span><br><span class="line">	}</span><br><span class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, s1) <span class="comment">// main.Student{ID:1, Gender:"男", Name:"李四", Sno:"s0001"}</span></span><br><span class="line">	<span class="keyword">var</span> s, _ = json.Marshal(s1)</span><br><span class="line">	jsonStr := <span class="type">string</span>(s)</span><br><span class="line">	fmt.Println(jsonStr) <span class="comment">// {"id":1,"gender":"男","Name":"李四","Sno":"s0001"}</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> s2 Student</span><br><span class="line">	<span class="keyword">var</span> str = <span class="string">"{\"id\":1,\"gender\":\"男\",\"Name\":\"李四\",\"Sno\":\"s0001\"}"</span></span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(str), &amp;s2)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	}</span><br><span class="line">	fmt.Printf(<span class="string">"%#v"</span>, s2) <span class="comment">// main.Student{ID:1, Gender:"男", Name:"李四", Sno:"s0001"}</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><font color="#4eb434" size="5"><strong>嵌套结构体中的</strong> <strong>JSON</strong> <strong>序列化反序列化</strong></font></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> {</span><br><span class="line">	ID     <span class="type">int</span></span><br><span class="line">	Gender <span class="type">string</span></span><br><span class="line">	Name   <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class 班级</span></span><br><span class="line"><span class="keyword">type</span> Class <span class="keyword">struct</span> {</span><br><span class="line">	Title    <span class="type">string</span></span><br><span class="line">	Students []Student <span class="comment">// 学生切片</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	c := &amp;Class{ <span class="comment">// 指针实例化结构体法</span></span><br><span class="line">		Title:    <span class="string">"001"</span>,</span><br><span class="line">		Students: <span class="built_in">make</span>([]Student, <span class="number">0</span>, <span class="number">200</span>)}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">		stu := Student{</span><br><span class="line">			Name:   fmt.Sprintf(<span class="string">"stu%02d"</span>, i),</span><br><span class="line">			Gender: <span class="string">"男"</span>,</span><br><span class="line">			ID:     i}</span><br><span class="line">		c.Students = <span class="built_in">append</span>(c.Students, stu)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//JSON 序列化：结构体--&gt;JSON 格式的字符串</span></span><br><span class="line">	data, err := json.Marshal(c)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(<span class="string">"json marshal failed"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	}</span><br><span class="line">	fmt.Printf(<span class="string">"json:%s\n"</span>, data)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//JSON 反序列化：JSON 格式的字符串--&gt;结构体</span></span><br><span class="line">	str := <span class="string">`{"Title":"001",</span></span><br><span class="line"><span class="string">	"Students":[{"ID":0,"Gender":" 男 ","Name":"stu00"},{"ID":1,"Gender":" 男 ","Name":"stu01"},</span></span><br><span class="line"><span class="string">	{"ID":2,"Gender":" 男 ","Name":"stu02"},{"ID":3,"Gender":" 男","Name":"stu03"},</span></span><br><span class="line"><span class="string">	{"ID":4,"Gender":" 男 ","Name":"stu04"},{"ID":5,"Gender":" 男","Name":"stu05"},</span></span><br><span class="line"><span class="string">	{"ID":6,"Gender":" 男 ","Name":"stu06"},{"ID":7,"Gender":" 男","Name":"stu07"},</span></span><br><span class="line"><span class="string">	{"ID":8,"Gender":" 男 ","Name":"stu08"},{"ID":9,"Gender":" 男","Name":"stu09"}]}`</span></span><br><span class="line">	c1 := &amp;Class{} <span class="comment">// 指针实例化结构体法</span></span><br><span class="line">	err1 := json.Unmarshal([]<span class="type">byte</span>(str), c1)</span><br><span class="line">	<span class="keyword">if</span> err1 != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(<span class="string">"json unmarshal failed!"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	}</span><br><span class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, c1)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出:</span></span><br><span class="line"><span class="comment">json:{"Title":"001","Students":[{"ID":0,"Gender":"男","Name":"stu00"},{"ID":1,"Gender":"男","Name":"stu01"},{"ID":2,"Gender":"男","Name":"stu02"},{"ID":3,"Gender":"男","Name":"stu03"},{"ID":4,"Gender":"男","Name":"stu04"},{"ID":5,"Gender":"男","Name":"stu05"},{"ID":6,"Gender":"男","Name":"stu06"},{"ID":7,"Gender":"男","Name":"stu07"},{"ID":8,"Gender":"男","Name":"stu08"},{"ID":9,"Gender":"男","Name":"stu09"}]}</span></span><br><span class="line"><span class="comment">&amp;main.Class{Title:"001", Students:[]main.Student{main.Student{ID:0, Gender:" 男 ", Name:"stu00"}, main.Student{ID:1, Gender:" 男 ", Name:"stu01"}, main.Student{ID:2, Gender:" 男 ", Name:"stu02"}, main.Student{ID:3, Gender:" 男", Name:"stu03"}, main.Student{ID:4, Gender:" 男 ", Name:"stu04"}, main.Student{ID:5, Gender:" 男", Name:"stu05"}, main.Student{ID:6, Gender:" 男 ", Name:"stu06"}, main.Student{ID:7, Gender:" 男", Name:"stu07"}, main.Student{ID:8, Gender:" 男 ", Name:"stu08"}, main.Student{ID:9, Gender:" 男", Name:"stu09"}}}</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="接口-interface">15.接口 interface</h2>
<blockquote>
<p><strong>关于接口需要注意的是：</strong>只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。不要为了接口而写接口，那样只会增加不必要的抽象，导致不必要的运行时损耗。</p>
</blockquote>
<p>接口是一种<strong>抽象类型</strong>，接口定义了对象的行为规范，只定义规范不实现。接口中定义的规范由具体的对象来实现。接口体现了程序设计的多态和高内聚低耦合的思想。</p>
<p>通俗讲<strong>接口</strong>就是一个<strong>标准</strong>，它是对一个对象的行为和规范进行约定，约定实现接口的对象必须得按照接口的规范，即实现接口中定义的所有抽象方法。（只要某对象实现了某接口中的所有方法，我们就可以称该对象实现了该接口。）</p>
<p>Go 语言中接口（interface）是<strong>一组函数 method 的集合</strong>，而不能包含任何变量。在 Golang 中接口中的所有方法 (method) 都没有方法体——接口定义了一个对象的行为规范，只定义规范不实现。Golang 中每个接口由数个方法组成，接口的定义格式如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口名 <span class="keyword">interface</span>{</span><br><span class="line">  方法名 <span class="number">1</span>( 参数列表 <span class="number">1</span> ) 返回值列表 <span class="number">1</span></span><br><span class="line">  方法名 <span class="number">2</span>( 参数列表 <span class="number">2</span> ) 返回值列表 <span class="number">2</span> </span><br><span class="line">  …</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">注：空接口写法 <span class="keyword">var</span> x <span class="keyword">interface</span>{}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>接口名</strong>：使用 type 将接口定义为自定义的类型名。Go 语言的接口在命名时，一般会在单词后面添加 er，如有写操作的接口叫 Writer，有字符串功能的接口叫 Stringer 等。接口名最好要能突出该接口的类型含义。</li>
<li><strong>方法名</strong>：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li>
<li><strong>参数列表、返回值列表</strong>：参数列表和返回值列表中的参数变量名可以省略。实现接口时，实际的方法参数和返回值必须和接口中定义的一致（数量、类型等），参数名称和返回值名称可以不一致。</li>
</ul>
<p>实现接口的对象必须实现/重写接口中定义的所有方法，如以下例子:</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Usber <span class="keyword">interface</span> { <span class="comment">// 接口</span></span><br><span class="line">	Start()</span><br><span class="line">	Stop()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span> { <span class="comment">// 实现接口的结构体</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span></span> Start() { <span class="comment">// 该结构体必须实现接口定义的所有方法</span></span><br><span class="line">	fmt.Println(p.Name, <span class="string">"开始工作"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span></span> Stop() {</span><br><span class="line">	fmt.Println(<span class="string">"phone 停止"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Camera <span class="keyword">struct</span> { <span class="comment">// 实现接口的结构体</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Camera)</span></span> Start() {</span><br><span class="line">	fmt.Println(<span class="string">"相机 开始工作"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Camera)</span></span> Stop() {</span><br><span class="line">	fmt.Println(<span class="string">"相机 停止工作"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 电脑的结构体</span></span><br><span class="line"><span class="keyword">type</span> Computer <span class="keyword">struct</span> {</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 电脑的 Work 方法要求必须传入 Usb 接口类型数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Computer)</span></span> Work(usb Usber) {</span><br><span class="line">	usb.Start()</span><br><span class="line">	usb.Stop()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	phone := Phone{Name: <span class="string">"小米手机"</span>}</span><br><span class="line">	<span class="keyword">var</span> p Usber = phone <span class="comment">//phone 实现了 Usb 接口</span></span><br><span class="line">	p.Start()</span><br><span class="line"></span><br><span class="line">	camera := Camera{}</span><br><span class="line">	<span class="keyword">var</span> c Usber = camera <span class="comment">//camera 实现了 Usb 接口</span></span><br><span class="line">	c.Start()</span><br><span class="line"></span><br><span class="line">	computer := Computer{}</span><br><span class="line">	<span class="comment">//把手机插入电脑的 Usb 接口开始工作</span></span><br><span class="line">	computer.Work(phone)</span><br><span class="line">	<span class="comment">//把相机插入电脑的 Usb 接口开始工作</span></span><br><span class="line">	computer.Work(camera)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="空接口">15.1.空接口</h3>
<p>Golang 中的接口可以不定义任何方法，<strong>没有定义任何方法的接口就是空接口</strong>。空接口表示没有任何约束，因此任何类型变量都可以实现空接口。</p>
<p>空接口在实际项目中用的是非常多的，<font color="#ef042a"><strong>用空接口可以表示任意数据类型</strong></font>。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 定义一个空接口 x, x 变量可以接收任意的数据类型</span></span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">interface</span>{}</span><br><span class="line"></span><br><span class="line">	s := <span class="string">"你好 golang"</span></span><br><span class="line">	x = s</span><br><span class="line">	fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, x, x) <span class="comment">// type:string value:你好 golang</span></span><br><span class="line"></span><br><span class="line">	i := <span class="number">100</span></span><br><span class="line">	x = i</span><br><span class="line">	fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, x, x) <span class="comment">// type:int value:100</span></span><br><span class="line"></span><br><span class="line">	b := <span class="literal">true</span></span><br><span class="line">	x = b</span><br><span class="line">	fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, x, x) <span class="comment">// type:bool value:true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>正是由于空接口的这个特性，我们可以利用空接口做到：</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">接受任意类型函数参数</button><button type="button" class="tab " data-href="样例-2">实现保存任意值的字典</button><button type="button" class="tab " data-href="样例-3">存储任意值的切片</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(a <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">	fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, a, a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 定义一个空接口 x, x 变量可以接收任意的数据类型</span></span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">interface</span>{}</span><br><span class="line"></span><br><span class="line">	s := <span class="string">"你好 golang"</span></span><br><span class="line">	x = s</span><br><span class="line">	show(x) <span class="comment">// type:string value:你好 golang</span></span><br><span class="line"></span><br><span class="line">	i := <span class="number">100</span></span><br><span class="line">	x = i</span><br><span class="line">	show(x) <span class="comment">// type:int value:100</span></span><br><span class="line"></span><br><span class="line">	b := <span class="literal">true</span></span><br><span class="line">	x = b</span><br><span class="line">	show(x) <span class="comment">// type:bool value:true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 空接口作为 map 值</span></span><br><span class="line">	<span class="keyword">var</span> studentInfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{})</span><br><span class="line">	studentInfo[<span class="string">"name"</span>] = <span class="string">"张三"</span></span><br><span class="line">	studentInfo[<span class="string">"age"</span>] = <span class="number">18</span></span><br><span class="line">	studentInfo[<span class="string">"married"</span>] = <span class="literal">false</span></span><br><span class="line">	fmt.Println(studentInfo) <span class="comment">// map[age:18 married:false name:张三]</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-3"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> slice = []<span class="keyword">interface</span>{}{<span class="string">"张三"</span>, <span class="number">20</span>, <span class="literal">true</span>, <span class="number">32.2</span>}</span><br><span class="line">	fmt.Println(slice) <span class="comment">// [张三 20 true 32.2]</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h3 id="类型断言">15.2.类型断言</h3>
<p>一个接口的值（简称接口值）是由一个实现该接口的结构/变量的具体类型和具体类型的值两部分组成的。这两部分分别称为<strong>接口的动态类型</strong>和<strong>动态值</strong>。</p>
<p>如果我们想要<strong>判断空接口中值的类型</strong>，那么这个时候就可以使用<strong>类型断言</strong>，其语法格式：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">类型为空接口的变量x.(类型T)</span><br></pre></td></tr></tbody></table></figure>
<p>该语法返回两个参数，第一个参数是 x 转化为 T 类型后的变量，第二个值是一个布尔值，若为 true 则表示断言成功，为 false 则表示断言失败。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">justifyType</span><span class="params">(x <span class="keyword">interface</span>{})</span></span> { <span class="comment">// 注意，该函数声明不能嵌套在 main 函数中</span></span><br><span class="line">	<span class="keyword">switch</span> v := x.(<span class="keyword">type</span>) {</span><br><span class="line">	<span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">		fmt.Printf(<span class="string">"x is a string，value is %v\n"</span>, v)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">		fmt.Printf(<span class="string">"x is a int is %v\n"</span>, v)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">		fmt.Printf(<span class="string">"x is a bool is %v\n"</span>, v)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"unsupport type！"</span>)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">interface</span>{}</span><br><span class="line">	x = <span class="number">100</span></span><br><span class="line">	y := x.(<span class="type">int</span>)</span><br><span class="line">	fmt.Println(y) <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">	v, ok := x.(<span class="type">int</span>)</span><br><span class="line">	<span class="keyword">if</span> ok {</span><br><span class="line">		fmt.Println(v) <span class="comment">// 100</span></span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		fmt.Println(<span class="string">"类型断言失败"</span>)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*上面的示例中如果要断言多次就需要写多个 if 判断，这个时候我们可以使用 switch 语句来</span></span><br><span class="line"><span class="comment">	实现：</span></span><br><span class="line"><span class="comment">		注意：类型.(type)只能结合 switch 语句使用*/</span></span><br><span class="line">	justifyType(x) <span class="comment">// x is a int is 100</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="结构体的方法是值接收者或指针接收者实现接口的区别">15.3.结构体的方法是值接收者或指针接收者实现接口的区别</h3>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">值接收者</button><button type="button" class="tab " data-href="样例-2">指针接收者</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><p>如果结构体中的方法是值接收者，那么实例化后的结构体值类型和结构体指针类型都可以赋值给接口变量，如：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Usb <span class="keyword">interface</span> {</span><br><span class="line">	Start()</span><br><span class="line">	Stop()</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span> {</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span></span> Start() {</span><br><span class="line">	fmt.Println(p.Name, <span class="string">"开始工作"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span></span> Stop() {</span><br><span class="line">	fmt.Println(<span class="string">"phone 停止"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	phone1 := Phone{Name: <span class="string">"小米手机"</span>}</span><br><span class="line">	<span class="keyword">var</span> p1 Usb = phone1 <span class="comment">//phone1 实现了 Usb 接口， phone1 是 Phone 类型</span></span><br><span class="line">	p1.Start()          <span class="comment">//小米手机 开始工作</span></span><br><span class="line"></span><br><span class="line">	phone2 := &amp;Phone{Name: <span class="string">"苹果手机"</span>}</span><br><span class="line">	<span class="keyword">var</span> p2 Usb = phone2 <span class="comment">//phone2 实现了 Usb 接口 phone2 是 *Phone 类型</span></span><br><span class="line">	p2.Start()          <span class="comment">//苹果手机 开始工作</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><p>如果结构体中的方法是指针接收者，那么实例化后结构体指针类型都可以赋值给接口变量，结构体值类型没法赋值给接口变量。如：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Usb <span class="keyword">interface</span> {</span><br><span class="line">	Start()</span><br><span class="line">	Stop()</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span> {</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Phone)</span></span> Start() {</span><br><span class="line">	fmt.Println(p.Name, <span class="string">"开始工作"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Phone)</span></span> Stop() {</span><br><span class="line">	fmt.Println(<span class="string">"phone 停止"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	phone1 := Phone{Name: <span class="string">"小米手机"</span>}</span><br><span class="line">	<span class="comment">/* 这样写会报错</span></span><br><span class="line"><span class="comment">	var p1 Usb = phone1</span></span><br><span class="line"><span class="comment">	p1.Start()</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	phone1.Start() <span class="comment">// 小米手机 开始工作 （这样写正常运行）</span></span><br><span class="line"></span><br><span class="line">	phone2 := &amp;Phone{Name: <span class="string">"苹果手机"</span>}</span><br><span class="line">	<span class="keyword">var</span> p2 Usb = phone2 <span class="comment">//phone2 实现了 Usb 接口 phone2 是 *Phone 类型</span></span><br><span class="line">	p2.Start()          <span class="comment">//苹果手机 开始工作</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h3 id="一个结构体实现多个接口">15.4.一个结构体实现多个接口</h3>
<p>Golang 中一个结构体也可以实现多个接口，只要该结构体实现了这些接口中定义的所有方法即可，如：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AInterface <span class="keyword">interface</span> {</span><br><span class="line">	GetInfo() <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BInterface <span class="keyword">interface</span> {</span><br><span class="line">	SetInfo(<span class="type">string</span>, <span class="type">int</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> {</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p People)</span></span> GetInfo() <span class="type">string</span> {</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"姓名:%v 年龄:%d"</span>, p.Name, p.Age)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span></span> SetInfo(name <span class="type">string</span>, age <span class="type">int</span>) {</span><br><span class="line">	p.Name = name</span><br><span class="line">	p.Age = age</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> people = &amp;People{</span><br><span class="line">		Name: <span class="string">"张三"</span>,</span><br><span class="line">		Age:  <span class="number">20</span>}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// people 实现了 AInterface 和 BInterface</span></span><br><span class="line">	<span class="keyword">var</span> p1 AInterface = people</span><br><span class="line">	<span class="keyword">var</span> p2 BInterface = people</span><br><span class="line">	fmt.Println(p1.GetInfo()) <span class="comment">// 姓名:张三 年龄:20</span></span><br><span class="line">	p2.SetInfo(<span class="string">"李四"</span>, <span class="number">30</span>)</span><br><span class="line">	fmt.Println(p1.GetInfo()) <span class="comment">// 姓名:李四 年龄:30</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="接口嵌套">15.5.接口嵌套</h3>
<p>接口与接口间可以通过嵌套创造出新的接口，嵌套时只需要在接口体中写上被嵌套的接口名即可，如：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SayInterface <span class="keyword">interface</span> {</span><br><span class="line">	say(age <span class="type">int</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MoveInterface <span class="keyword">interface</span> {</span><br><span class="line">	move()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口嵌套</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> {</span><br><span class="line">	SayInterface</span><br><span class="line">	MoveInterface</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> {</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span></span> say(ages <span class="type">int</span>) { <span class="comment">// 变量名可以和接口中定义的不一样</span></span><br><span class="line">	fmt.Println(<span class="string">"喵喵喵"</span>, <span class="string">" 我"</span>, ages, <span class="string">"岁了"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span></span> move() {</span><br><span class="line">	fmt.Println(<span class="string">"猫会动"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> x Animal</span><br><span class="line">	x = Cat{name: <span class="string">"花花"</span>}</span><br><span class="line">	x.move() <span class="comment">// 猫会动</span></span><br><span class="line">	x.say(<span class="number">3</span>) <span class="comment">// 喵喵喵 我 3 岁了</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="并发和并行">16.并发和并行</h2>
<blockquote>
<p><font size="5">引入</font></p>
<p><strong>需求</strong>：要统计 1-120000 的数字中那些是素数，并打印这些素数</p>
<p><strong>素数：</strong>就是除了 1 和它本身不能被其他数整除的数</p>
<p><strong>实现方法：</strong></p>
<p>1、传统方法，通过一个 for 循环判断各个数是不是素数</p>
<p></p><details class="toggle"><summary class="toggle-button" style="">代码</summary><div class="toggle-content"><blockquote>
<p></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	start := time.Now().Unix()</span><br><span class="line">	<span class="keyword">for</span> num := <span class="number">1</span>; num &lt;= <span class="number">120000</span>; num++ {</span><br><span class="line">		flag := <span class="literal">true</span> <span class="comment">//假设是素数</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">2</span>; i &lt; num; i++ {</span><br><span class="line">			<span class="keyword">if</span> num%i == <span class="number">0</span> { <span class="comment">//说明该 num 不是素数</span></span><br><span class="line">				flag = <span class="literal">false</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> flag {</span><br><span class="line">			<span class="comment">// fmt.Println(num)</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	end := time.Now().Unix()</span><br><span class="line">	fmt.Println(<span class="string">"普通的方法耗时="</span>, end-start) <span class="comment">// 普通的方法耗时= 5</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
</blockquote>
</div></details><p></p>
<p>2、使用并发或者并行的方式，将统计素数的任务分配给多个 goroutine 去完成</p>
<p></p><details class="toggle"><summary class="toggle-button" style="">代码</summary><div class="toggle-content"><blockquote>
<p></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn1</span><span class="params">(n <span class="type">int</span>)</span></span> {</span><br><span class="line">	<span class="keyword">for</span> num := (n<span class="number">-1</span>)*<span class="number">30000</span> + <span class="number">1</span>; num &lt;= n*<span class="number">30000</span>; num++ {</span><br><span class="line">		flag := <span class="literal">true</span> <span class="comment">//假设是素数</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">2</span>; i &lt; num; i++ {</span><br><span class="line">			<span class="keyword">if</span> num%i == <span class="number">0</span> {</span><br><span class="line">				flag = <span class="literal">false</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> flag {</span><br><span class="line">			<span class="comment">//fmt.Println(num)</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	wg.Done()</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	start := time.Now().Unix()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++ {</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> fn1(i) <span class="comment">// 开启4个协程，每个协程计算30000个数</span></span><br><span class="line">	}</span><br><span class="line">	wg.Wait()</span><br><span class="line">	end := time.Now().Unix()</span><br><span class="line">	fmt.Println(<span class="string">"普通的方法耗时="</span>, end-start) <span class="comment">// 普通的方法耗时 = 3</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
</blockquote>
</div></details><p></p>
<p>3、goroutine 结合 channel</p>
<p></p><details class="toggle"><summary class="toggle-button" style="">代码</summary><div class="toggle-content"><blockquote>
<p>使用了 goroutine 已经能大大的提升新能了，但是如果我们想统计数据和打印数据同时进行，这个时候我们就可以使用管道。</p>
<p></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 intChan 放入 1-120000 个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">putNum</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>)</span></span> {</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">120000</span>; i++ {</span><br><span class="line">		intChan &lt;- i</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//关闭 intChan</span></span><br><span class="line">	<span class="built_in">close</span>(intChan)</span><br><span class="line">	wg.Done()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 intChan 取出数据，并判断是否为素数,如果是，就放入到 primeChan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">primeNum</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>, primeChan <span class="keyword">chan</span> <span class="type">int</span>, exitChan <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> {</span><br><span class="line">	<span class="keyword">for</span> num := <span class="keyword">range</span> intChan {</span><br><span class="line">		<span class="keyword">var</span> flag <span class="type">bool</span> = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">2</span>; i &lt; num; i++ {</span><br><span class="line">			<span class="keyword">if</span> num%i == <span class="number">0</span> { <span class="comment">//说明该 num 不是素数</span></span><br><span class="line">				flag = <span class="literal">false</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> flag {</span><br><span class="line">			<span class="comment">//将这个数就放入到 primeChan</span></span><br><span class="line">			primeChan &lt;- num</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//判断关闭</span></span><br><span class="line">	exitChan &lt;- <span class="literal">true</span></span><br><span class="line">	wg.Done()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印素数的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printPrime</span><span class="params">(primeChan <span class="keyword">chan</span> <span class="type">int</span>)</span></span> {</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> primeChan {</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	}</span><br><span class="line">	wg.Done()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	start := time.Now().Unix()</span><br><span class="line">	intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1000</span>)</span><br><span class="line">	primeChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">20000</span>) <span class="comment">//放入结果</span></span><br><span class="line">	<span class="comment">//标识退出的管道</span></span><br><span class="line">	exitChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">8</span>) <span class="comment">// 8 个</span></span><br><span class="line">	<span class="comment">//开启一个协程，向 intChan 放入 1-8000 个数</span></span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> putNum(intChan)</span><br><span class="line">	<span class="comment">//开启 8 个并行协程，从 intChan 取出数据，并判断是否为素数,如果是，就放入到 primeChan</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ {</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> primeNum(intChan, primeChan, exitChan)</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//打印素数</span></span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> printPrime(primeChan)</span><br><span class="line">	<span class="comment">//判断什么时候退出</span></span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ {</span><br><span class="line">			&lt;-exitChan</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">// 由于primeChan 需要调用多次，不好判断何时关闭 primeChan,因此每个 primeNum 协程执行完后都给 exitChan 发送一个信号</span></span><br><span class="line">		<span class="comment">/*如果有部分 primeNum goroutine 还没完成， exitChan 还没收到全部 8 个信号，</span></span><br><span class="line"><span class="comment">		主程序就会在循环中等待，直到所有信号都到齐。*/</span></span><br><span class="line">		<span class="comment">//当我们从 exitChan 取出了 8 个结果，就可以放心的关闭 primeChan（不关闭将会报错）</span></span><br><span class="line">		<span class="built_in">close</span>(primeChan)</span><br><span class="line">		wg.Done()</span><br><span class="line">	}()</span><br><span class="line">	wg.Wait()</span><br><span class="line">	end := time.Now().Unix()</span><br><span class="line">	fmt.Println(<span class="string">"时间: "</span>, end-start) <span class="comment">//时间:  1</span></span><br><span class="line">	fmt.Println(<span class="string">"main 线程退出"</span>)       <span class="comment">// main 线程退出</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
</blockquote>
</div></details><p></p>
</blockquote>
<h3 id="进程和线程">16.1.进程和线程</h3>
<p><strong>进程</strong>（Process）就是程序在操作系统中的一次执行过程，是系统进行资源分配和调度的基本单位，进程是一个动态概念，是程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间。一个进程至少有 5 种基本状态：初始态，执行态，等待状态，就绪状态，终止状态。</p>
<p>通俗的讲，进程就是一个正在执行的程序。</p>
<p><strong>线程</strong> 是进程的一个执行实例，是程序执行的最小单元，它是比进程更小的能独立运行的基本单位。</p>
<p><strong>一个进程可以创建多个线程，同一个进程中的多个线程可以并发执行，一个程序要运行的话至少有一个进程</strong>。</p>
<p><img src="/img/load3.gif" data-original="https://cdn.jsdelivr.net/gh/hahahaha5606/blogImage/images/image-20250518171322117.png" alt="image-20250518171322117" style="zoom:67%;"></p>
<h3 id="并发和并行-1">16.2.并发和并行</h3>
<p>并发和并行的概念都是相当于<strong>线程</strong>而言，取决于线程数和CPU核数的大小。</p>
<ul>
<li><strong>并发</strong>：多个线程同时竞争一个位置，竞争到的才可以执行，每一个时间段只有一个线程在执行。</li>
<li><strong>并行 (要求是多核CPU)</strong>：多个线程可以同时执行，每一个时间段，可以有多个线程同时执行。</li>
</ul>
<p>通俗的讲，多线程程序在单核 CPU 上面运行就是<strong>并发</strong>，多线程程序在多核 CPU 上运行就是<strong>并行</strong>，如果线程数大于 CPU 核数，则多线程程序在多个 CPU 上面运行<strong>既有并行又有并发</strong>。</p>
<h3 id="主线程和协程goroutine">16.3.主线程和协程（goroutine）</h3>
<p><strong>golang</strong> <strong>中的主线程：</strong>（可以理解为线程/也可以理解为进程），在一个 Golang 程序的主线程上可以起多个协程。Golang 中多协程可以实现并行或者并发。</p>
<p><strong>协程( Coroutine )：</strong>可以理解为用户级线程，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的。Golang 的一大特色就是从语言层面原生支持协程，<font color="#985fff"><strong>在函数或者方法前面加 go 关键字就可创建一个协程</strong></font>。可以说 <strong>Golang 中的协程就是 goroutine</strong> 。</p>
<blockquote>
<p><strong>Golang 中的多协程有点类似其他语言中的多线程</strong>。</p>
<p><strong>多协程和多线程：</strong>Golang 中每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少。OS 线程（操作系统线程）一般都有固定的栈内存（通常为 2MB 左右）,一个 goroutine (协程) 占用内存非常小，只有 2KB 左右，<strong>多协程 goroutine 切换调度开销方面远比线程要少</strong>。这也是为什么越来越多的大公司使用 Golang 的原因之一。</p>
</blockquote>
<h3 id="goroutine-的使用和-sync.waitgroup">16.4.Goroutine 的使用和 sync.WaitGroup</h3>
<p>首先看一个 goroutine 的使用案例：</p>
<p>在主线程(可以理解成进程)中，开启一个 goroutine, 该协程每隔 50 毫秒秒输出 "你好 golang" 。同时在主线程中也每隔 50 毫秒输出"你好 golang", 输出 10 次后，退出程序，要求主线程和 goroutine 并行执行。</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">代码</button><button type="button" class="tab " data-href="样例-2">预览</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++ {</span><br><span class="line">		fmt.Println(<span class="string">"tesst () hello,world "</span> + strconv.Itoa(i)) <span class="comment">// strconv.Itoa 函数表示将 i 转换为 string 型 </span></span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">go</span> test() <span class="comment">// 开启了一个协程</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ {</span><br><span class="line">		fmt.Println(<span class="string">" main() hello,golang"</span> + strconv.Itoa(i))</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"> main() hello,golang7</span><br><span class="line">tesst () hello,world <span class="number">7</span></span><br><span class="line">tesst () hello,world <span class="number">8</span></span><br><span class="line"> main() hello,golang8</span><br><span class="line"> main() hello,golang9</span><br><span class="line">tesst () hello,world <span class="number">9</span></span><br><span class="line">tesst () hello,world <span class="number">10</span></span><br><span class="line"> main() hello,golang10</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><strong>可以看到主线程执行完毕后，即使协程并没有执行完毕，程序也会退出。为避免这种情况，我们可以使用 sync.WaitGroup 函数使主线程等待协程执行完毕</strong>。sync.WaitGroup 函数使用时有以下注意事项：</p>
<ul>
<li>Add() 和 Done() 的调用次数必须匹配；</li>
<li>每个 goroutine 启动前调用一次 Add(1)，每个 goroutine 结束时调用一次 Done()；</li>
<li>Wait() 会阻塞直到计数器变为 0。</li>
</ul>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">代码</button><button type="button" class="tab " data-href="样例-2">预览</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup <span class="comment">//定义全局的 WaitGroup</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">defer</span> wg.Done() <span class="comment">// 写法1：在函数结束时执行 Done</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++ {</span><br><span class="line">		fmt.Println(<span class="string">"tesst () hello,world "</span> + strconv.Itoa(i))</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//wg.Done() // 写法2：在函数结束时执行 Done</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	wg.Add(<span class="number">1</span>) <span class="comment">// 启动一个 goroutine ，就登记+1（wg.Done() 则在 goroutine 结束就登记-1）</span></span><br><span class="line">  <span class="comment">// Add 括号内的数字表示开启了几个协程</span></span><br><span class="line">	<span class="keyword">go</span> test() <span class="comment">// 开启了一个协程</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ {</span><br><span class="line">		fmt.Println(<span class="string">" main() hello,golang"</span> + strconv.Itoa(i))</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	}</span><br><span class="line">	wg.Wait() <span class="comment">// 等待所有登记的 goroutine 都结束才退出程序</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">tesst () hello,world <span class="number">14</span></span><br><span class="line">tesst () hello,world <span class="number">15</span></span><br><span class="line">tesst () hello,world <span class="number">16</span></span><br><span class="line">tesst () hello,world <span class="number">17</span></span><br><span class="line">tesst () hello,world <span class="number">18</span></span><br><span class="line">tesst () hello,world <span class="number">19</span></span><br><span class="line">tesst () hello,world <span class="number">20</span></span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p><strong>启动多个 goroutine</strong>:</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">代码</button><button type="button" class="tab " data-href="样例-2">预览</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="type">int</span>)</span></span> {</span><br><span class="line">	<span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine 结束就登记-1</span></span><br><span class="line">	fmt.Println(<span class="string">"Hello Goroutine!"</span>, i)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">		wg.Add(<span class="number">1</span>) <span class="comment">// 启动一个 goroutine 就登记+1</span></span><br><span class="line">		<span class="keyword">go</span> hello(i)</span><br><span class="line">	}</span><br><span class="line">	wg.Wait() <span class="comment">// 等待所有登记的 goroutine 都结束</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">Hello Goroutine! <span class="number">9</span></span><br><span class="line">Hello Goroutine! <span class="number">1</span></span><br><span class="line">Hello Goroutine! <span class="number">0</span></span><br><span class="line">Hello Goroutine! <span class="number">3</span></span><br><span class="line">Hello Goroutine! <span class="number">2</span></span><br><span class="line">Hello Goroutine! <span class="number">4</span></span><br><span class="line">Hello Goroutine! <span class="number">8</span></span><br><span class="line">Hello Goroutine! <span class="number">7</span></span><br><span class="line">Hello Goroutine! <span class="number">6</span></span><br><span class="line">Hello Goroutine! <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。<strong>这是因为 10 个 goroutine是并发执行的，而 goroutine 的调度是随机的。</strong></p>
<h3 id="设置并行时占用-cpu-数量">16.5.设置并行时占用 CPU 数量</h3>
<p>Go 运行时的调度器使用 GOMAXPROCS 参数来确定需要使用多少个 OS 线程来同时执行 Go代码。<strong>默认值是机器上的 CPU 核心数</strong>。例如在一个 8 核心的机器上，调度器会把 Go 代码同时调度到 8 个 OS 线程上。</p>
<p>Go 语言中可以通过 <strong>runtime.GOMAXPROCS()</strong> 函数设置当前程序并发时占用的 CPU 逻辑核心数。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">//获取当前计算机上面的 Cpu 个数</span></span><br><span class="line">	cpuNum := runtime.NumCPU()</span><br><span class="line">	fmt.Println(<span class="string">"cpuNum ="</span>, cpuNum)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//可以自己设置使用多个 cpu</span></span><br><span class="line">	runtime.GOMAXPROCS(cpuNum - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前的 GOMAXPROCS 设置值</span></span><br><span class="line">	currentProcs := runtime.GOMAXPROCS(<span class="number">0</span>) <span class="comment">//调用会返回当前设置的值（如果传 0，不会做修改，只返回当前值）。</span></span><br><span class="line">	fmt.Println(<span class="string">"GOMAXPROCS after setting:"</span>, currentProcs)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">cpuNum = <span class="number">8</span></span><br><span class="line">GOMAXPROCS after setting: <span class="number">7</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="并发安全和锁">16.6.并发安全和锁</h3>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">互斥锁</button><button type="button" class="tab " data-href="样例-2">读写锁</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><p>互斥锁是传统并发编程中对共享资源进行访问控制的主要手段，它由标准库 sync 中的 Mutex 结构体类型表示。sync.Mutex 类型只有两个公开的指针方法，Lock 和 Unlock。Lock 锁定当前的共享资源，Unlock 进行解锁。</p>
<p>使用互斥锁能够保证同一时间有且只有一个 goroutine 进入临界区（进行读或写），其他的 goroutine 则在等待锁；当互斥锁释放后，等待的 goroutine 才可以获取锁进入临界区，多个 goroutine 同时等待一个锁时，唤醒的策略是随机的。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> {</span><br><span class="line">	count++ <span class="comment">// 并发修改 count 值可能引发潜在问题</span></span><br><span class="line">	fmt.Println(<span class="string">"the count is : "</span>, count)</span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">for</span> r := <span class="number">0</span>; r &lt; <span class="number">100</span>; r++ {</span><br><span class="line">		<span class="keyword">go</span> test()</span><br><span class="line">	}</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>go build -race main.go</strong> <strong>然后我们运行</strong> <strong>main.exe</strong> <strong>就知道到底哪里存在互斥</strong>。通过互斥锁解决问题如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> {</span><br><span class="line">	mu.Lock()	<span class="comment">//上锁</span></span><br><span class="line">	count++ </span><br><span class="line">	fmt.Println(<span class="string">"the count is : "</span>, count)</span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line">	mu.Unlock()	<span class="comment">//解锁</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">for</span> r := <span class="number">0</span>; r &lt; <span class="number">100</span>; r++ {</span><br><span class="line">		<span class="keyword">go</span> test()</span><br><span class="line">	}</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>虽然使用互斥锁能解决资源争夺问题，但是并不完美，通过全局变量加锁同步来实现通讯，并不利于多个协程对全局变量的读写操作。这个时候我们也可以通过另一种方式来实现上面的功能管道(Channel)，即“读写锁”。</p></div><div class="tab-item-content" id="样例-2"><p>互斥锁的本质是当一个 goroutine 访问的时候，其他 goroutine 都不能访问。这样在资源同步，避免竞争的同时也降低了程序的并发性能。程序由原来的并行执行变成了串行执行。</p>
<p>其实，当我们对一个不会变化的数据只做“读”操作的话，是不存在资源竞争的问题的。因为数据是不变的，不管怎么读取，多少 goroutine 同时读取，都是可以的。所以问题不是出在“读”上，主要是修改，也就是“写”。修改的数据要同步，这样其他 goroutine 才可以感知到。所以<strong>真正的互斥应该是读取和修改、修改和修改之间</strong>，读和读是没有互斥操作的必要的。因此，衍生出另外一种锁，叫做<strong>读写锁</strong>。</p>
<p>读写锁可以让多个读操作并发，同时读取；但是对于写操作是完全互斥的。也就是说，<strong>当一个 goroutine 进行写操作的时候，其他 goroutine 既不能进行读操作，也不能进行写操作</strong>。</p>
<p>GO 中的读写锁由结构体类型 sync.RWMutex 表示。此类型的方法集合中包含两对方法：</p>
<ul>
<li><p><strong>一组是对写操作的锁定和解锁，简称“写锁定”和“写解锁”：</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*RWMutex)</span></span>Lock()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*RWMutex)</span></span>Unlock()</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>另一组表示对读操作的锁定和解锁，简称为“读锁定”与“读解锁”：</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*RWMutex)</span></span>RLock()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*RWMutex)</span></span>RUnlock()</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>示例如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> mutex sync.RWMutex</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> {</span><br><span class="line">	mutex.Lock()</span><br><span class="line">	fmt.Println(<span class="string">"执行写操作"</span>)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">	mutex.Unlock()</span><br><span class="line">	wg.Done()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> {</span><br><span class="line">	mutex.RLock()</span><br><span class="line">	fmt.Println(<span class="string">"执行读操作"</span>)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">	mutex.RUnlock()</span><br><span class="line">	wg.Done()</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 开启 10 个协程执行写操作</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> read()</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//开启 10 个协程执行读操作</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> write()</span><br><span class="line">	}</span><br><span class="line">	wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h3 id="recover-解决协程中出现的-panic">16.7.Recover 解决协程中出现的 Panic</h3>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：打印10次 hello,world</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		fmt.Println(<span class="string">"hello,world"</span>)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">//这里我们可以使用 defer + recover</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		<span class="comment">//捕获 test 抛出的 panic</span></span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> {</span><br><span class="line">			fmt.Println(<span class="string">"test() 发生错误"</span>, err)</span><br><span class="line">		}</span><br><span class="line">	}()</span><br><span class="line">	<span class="comment">//定义了一个 map</span></span><br><span class="line">	<span class="keyword">var</span> myMap <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span> <span class="comment">//没完成初始化的引用类型 map 不能直接使用</span></span><br><span class="line">  <span class="comment">//myMap = make(map[int]string, 10)</span></span><br><span class="line">	myMap[<span class="number">0</span>] = <span class="string">"golang"</span>      <span class="comment">//error</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">go</span> sayHello()</span><br><span class="line">	<span class="keyword">go</span> test()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ {</span><br><span class="line">		fmt.Println(<span class="string">"main() ok="</span>, i)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">main() ok= <span class="number">0</span></span><br><span class="line">test() 发生错误 assignment to entry in <span class="literal">nil</span> <span class="keyword">map</span></span><br><span class="line">main() ok= <span class="number">1</span></span><br><span class="line">hello,world</span><br><span class="line">hello,world</span><br><span class="line">main() ok= <span class="number">2</span></span><br><span class="line">hello,world</span><br></pre></td></tr></tbody></table></figure>
<h2 id="管道-channel">17.管道 Channel</h2>
<p><strong>管道是 Golang 在语言级别上提供的 goroutine 间的通讯方式</strong>，我们可以使用 channel 在多个 goroutine 之间传递消息。如果说 goroutine 是 Go 程序并发的执行体，channel 就是它们之间的连接。channel 是可以让一个 goroutine 发送特定值到另一个 goroutine 的通信机制。</p>
<p>Golang 的并发模型是 CSP（Communicating Sequential Processes），提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存而实现通信</strong>。</p>
<p>Go 语言中的管道（channel）是一种特殊的类型。管道像一个传送带或者队列，总是遵循<strong>先入先出（First In First Out）</strong>的规则，保证收发数据的顺序。每一个管道都是一个具体类型的导管，也就是声明 channel 的时候需要为其指定元素类型。</p>
<h3 id="管道的定义">17.1.管道的定义</h3>
<p><strong>Channel 是一种引用类型，声明后需要使用 make 函数分配内存</strong>。声明管道类型的格式如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量 <span class="keyword">chan</span> 元素类型</span><br><span class="line"></span><br><span class="line">举几个例子：</span><br><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">// 声明一个传递整型的管道</span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="type">bool</span> <span class="comment">// 声明一个传递布尔型的管道</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span> []<span class="type">int</span> <span class="comment">// 声明一个传递 int 切片的管道</span></span><br></pre></td></tr></tbody></table></figure>
<p>声明的管道后需要使用 make 函数初始化之后才能使用，格式为:</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> 元素类型, 容量)</span><br><span class="line"></span><br><span class="line">举几个例子：</span><br><span class="line"><span class="comment">//创建一个能存储 10 个 int 类型数据的管道</span></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">//创建一个能存储 4 个 bool 类型数据的管道</span></span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">//创建一个能存储 3 个[]int 切片类型数据的管道</span></span><br><span class="line">ch3 := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="管道的操作">17.2.管道的操作</h3>
<p>管道有发送（send）、接收(receive）和关闭（close）三种操作。其中，发送和接收都使用 <code>&lt;-</code>符号。</p>
<p>假设我们已经初始化了一个管道：<code>ch := make(chan int, 3)</code></p>
<p><font color="#4eb434" size="5"><strong>发送（将数据放在管道内）</strong></font></p>
<p>将一个值发送到管道中：<code>&lt;-</code></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">ch &lt;- <span class="number">10</span> <span class="comment">// 把 10 发送到 ch 中</span></span><br></pre></td></tr></tbody></table></figure>
<p><font color="#4eb434" size="5"><strong>接收（从管道内取值）</strong></font></p>
<p>从管道中接收值：<code>&lt;-</code> （注意！在接收通道数据时，如果没有数据可以接收将会发生阻塞，可以利用该特性设置通道变量，判断某些操作是否全部完成。）</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">x := &lt;- ch <span class="comment">// 从 ch 中接收值并赋值给变量 x</span></span><br><span class="line">&lt;-ch <span class="comment">// 从 ch 中接收值，忽略结果</span></span><br></pre></td></tr></tbody></table></figure>
<p><font color="#4eb434" size="5"><strong>关闭管道</strong></font></p>
<p>调用内置的 close 函数来关闭管道。<strong>关闭后的管道有以下特点：</strong></p>
<ol type="1">
<li>对一个关闭的管道再发送值就会导致 panic。</li>
<li>对一个关闭的管道进行接收会会先取完管道中的值，再然后取到的值一直都是对应类型的零值。</li>
<li>关闭一个已经关闭的管道会导致 panic。</li>
</ol>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></tbody></table></figure>
<p>关于关闭管道需要注意的事情是，只有在通知接收方 goroutine 所有的数据都发送完毕的时候才需要关闭管道。管道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭管道不是必须的。</p>
<p>注意！<strong>在使用 for 循环遍历管道<font color="#985fff">存放数据并接收数据</font>时，必须要在发送完数据后关闭管道</strong>，否则将报错死锁（接收管道数据时，如果没有数据接收将发生阻塞）：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环遍历管道数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> ch1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line">		ch1 &lt;- i + <span class="number">1</span></span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">close</span>(ch1) <span class="comment">//关闭管道</span></span><br><span class="line">	<span class="comment">//使用 for range 遍历管道，当管道被关闭的时候就会退出 for range,如果没有关闭管道</span></span><br><span class="line">	<span class="comment">//就会报个错误 fatal error: all goroutines are asleep - deadlock!</span></span><br><span class="line">	<span class="comment">//通过 for range 来遍历管道数据 管道没有 key</span></span><br><span class="line">	<span class="keyword">for</span> val := <span class="keyword">range</span> ch1 {</span><br><span class="line">		fmt.Println(val)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="管道阻塞">17.3.管道阻塞</h3>
<p>如果创建管道的时候没有指定容量，那么我们可以叫这个管道为<strong>无缓冲的管道</strong> / 阻塞的管道。往无缓冲的管道（如 <code>ch := make(chan int)</code>）中发送值在运行时将导致错误，因此我们在使用 make 函数初始化管道时必须指定管道容量！</p>
<p><strong>只要管道的容量大于零，那么该管道就是有缓冲的管道，管道的容量表示管道中能存放元素的数量</strong>。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。例子如下：</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">管道阻塞</button><button type="button" class="tab " data-href="样例-2">解决办法</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">	ch &lt;- <span class="number">10</span></span><br><span class="line">	ch &lt;- <span class="number">12</span></span><br><span class="line">	fmt.Println(<span class="string">"发送成功"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">fatal <span class="type">error</span>: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [<span class="keyword">chan</span> send]:</span><br><span class="line">main.main()</span><br><span class="line">	c:/Users/LENOVO/Desktop/<span class="keyword">go</span>/<span class="number">01</span><span class="number">-05</span>/temp.<span class="keyword">go</span>:<span class="number">10</span> +<span class="number">0x47</span></span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">	ch &lt;- <span class="number">10</span> <span class="comment">//放进去</span></span><br><span class="line">	&lt;-ch     <span class="comment">//取走</span></span><br><span class="line">	ch &lt;- <span class="number">12</span> <span class="comment">//放进去</span></span><br><span class="line">	&lt;-ch     <span class="comment">//取走</span></span><br><span class="line">	ch &lt;- <span class="number">17</span> <span class="comment">//还可以放进去</span></span><br><span class="line">	fmt.Println(<span class="string">"发送成功"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">发送成功</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h3 id="goroutine-与-channnel-结合">17.4.Goroutine 与 Channnel 结合</h3>
<p>假设现在要求定义两个方法，一个方法给管道里面写数据，一个给管道里面读取数据。要求同步进行。这时我们可以用 goroutine 实现前者，用 channnel 实现后者。</p>
<ol type="1">
<li>开启一个 fn1 的的协程给向管道 inChan 中写入 10 条数据</li>
<li>开启一个 fn2 的协程读取 inChan 中写入的数据</li>
</ol>
<p>注意：fn1 和 fn2 同时操作一个管道，且主线程必须等待操作完成后才可以退出</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn1</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>)</span></span> {</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">		intChan &lt;- i + <span class="number">1</span></span><br><span class="line">		fmt.Println(<span class="string">"writeData 写入数据-"</span>, i+<span class="number">1</span>)</span><br><span class="line">		time.Sleep(time.Millisecond * <span class="number">100</span>)</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">close</span>(intChan)</span><br><span class="line">	wg.Done()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn2</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>)</span></span> {</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> intChan {</span><br><span class="line">		fmt.Printf(<span class="string">"readData 读到数据=%v\n"</span>, v)</span><br><span class="line">		time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">	}</span><br><span class="line">	wg.Done()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	allChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> fn1(allChan)</span><br><span class="line">	<span class="comment">//wg.Add(1)</span></span><br><span class="line">	<span class="keyword">go</span> fn2(allChan)</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">"读取完毕..."</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">writeData 写入数据- <span class="number">1</span></span><br><span class="line">readData 读到数据=<span class="number">1</span></span><br><span class="line">writeData 写入数据- <span class="number">2</span></span><br><span class="line">readData 读到数据=<span class="number">2</span></span><br><span class="line">writeData 写入数据- <span class="number">3</span></span><br><span class="line">readData 读到数据=<span class="number">3</span></span><br><span class="line">writeData 写入数据- <span class="number">4</span></span><br><span class="line">readData 读到数据=<span class="number">4</span></span><br><span class="line">writeData 写入数据- <span class="number">5</span></span><br><span class="line">readData 读到数据=<span class="number">5</span></span><br><span class="line">writeData 写入数据- <span class="number">6</span></span><br><span class="line">readData 读到数据=<span class="number">6</span></span><br><span class="line">writeData 写入数据- <span class="number">7</span></span><br><span class="line">readData 读到数据=<span class="number">7</span></span><br><span class="line">writeData 写入数据- <span class="number">8</span></span><br><span class="line">readData 读到数据=<span class="number">8</span></span><br><span class="line">writeData 写入数据- <span class="number">9</span></span><br><span class="line">readData 读到数据=<span class="number">9</span></span><br><span class="line">writeData 写入数据- <span class="number">10</span></span><br><span class="line">readData 读到数据=<span class="number">10</span></span><br><span class="line">读取完毕...</span><br></pre></td></tr></tbody></table></figure>
<h3 id="单向管道">17.5.单向管道</h3>
<p>有的时候我们会将管道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用管道都会对其进行限制，比如限制管道在函数中只能发送或只能接收。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">//1. 在默认情况下下，管道是双向</span></span><br><span class="line">	<span class="comment">//var chan1 chan int //可读可写</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2 声明为只写</span></span><br><span class="line">	<span class="keyword">var</span> chan2 <span class="keyword">chan</span>&lt;- <span class="type">int</span> <span class="comment">//先声明一个只写管道</span></span><br><span class="line">	chan2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>) <span class="comment">//再make为其分配内存</span></span><br><span class="line">	chan2 &lt;- <span class="number">20</span></span><br><span class="line">	<span class="comment">//num := &lt;-chan2 //error</span></span><br><span class="line">	fmt.Println(<span class="string">"只写 chan2 "</span>, chan2) <span class="comment">// 只写 chan2  0xc000016180</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3. 声明为只读</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>) <span class="comment">//先make一个双向的管道</span></span><br><span class="line">	ch &lt;- <span class="number">10</span></span><br><span class="line">	<span class="keyword">var</span> chan3 &lt;-<span class="keyword">chan</span> <span class="type">int</span> = ch <span class="comment">//再将双向管道ch转换为只读管道</span></span><br><span class="line">	num := &lt;-chan3</span><br><span class="line">	<span class="comment">//chan3&lt;- 30 //err</span></span><br><span class="line">	fmt.Println(<span class="string">"只读 chan3 "</span>, num) <span class="comment">// 只读 chan3  10</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="多路复用-select">17.5.多路复用 select</h3>
<p>在某些场景下我们需要同时从多个通道接收数据。这个时候就可以用到 golang 中给我们提供的 select 多路复用。</p>
<p>Go 内置的 select 关键字可以<strong><font color="#985fff">同时响应</font>多个管道的操作</strong>。select 的使用类似于 switch 语句，它有一系列 case 分支和一个默认的分支。每个 case 会对应一个管道的通信（接收或发送）过程。<strong>select 会一直等待，直到某个 case 的通信操作完成时，就会执行 case 分支对应的语句</strong>。具体格式如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>{</span><br><span class="line">  <span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">  	... <span class="comment">// 当ch1有数据可以接收时，执行这里</span></span><br><span class="line">  <span class="keyword">case</span> data := &lt;-ch2:</span><br><span class="line">  	... </span><br><span class="line">  <span class="keyword">case</span> ch3&lt;-data:</span><br><span class="line">  	...	<span class="comment">// 当ch3可以发送数据时，执行这里</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  	默认操作 <span class="comment">// 如果上面都没有准备好，执行这里</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>例子如下：</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">代码</button><button type="button" class="tab " data-href="样例-2">预览</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">//1.定义一个管道 10 个数据 int</span></span><br><span class="line">	intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">		intChan &lt;- i</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.定义一个管道 5 个数据 string</span></span><br><span class="line">	stringChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ {</span><br><span class="line">		stringChan &lt;- <span class="string">"hello"</span> + fmt.Sprintf(<span class="string">"%d"</span>, i)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> {</span><br><span class="line">		<span class="keyword">select</span> {</span><br><span class="line">		<span class="keyword">case</span> v := &lt;-intChan:</span><br><span class="line">			fmt.Printf(<span class="string">"从 intChan 读取的数据%d\n"</span>, v)</span><br><span class="line">		<span class="keyword">case</span> v := &lt;-stringChan:</span><br><span class="line">			fmt.Printf(<span class="string">"从 stringChan 读取的数据%s\n"</span>, v)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Printf(<span class="string">"都取不到了，不玩了, 程序员可以加入逻辑\n"</span>)</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">从 intChan 读取的数据<span class="number">0</span></span><br><span class="line">从 intChan 读取的数据<span class="number">1</span></span><br><span class="line">从 intChan 读取的数据<span class="number">2</span></span><br><span class="line">从 intChan 读取的数据<span class="number">3</span></span><br><span class="line">从 intChan 读取的数据<span class="number">4</span></span><br><span class="line">从 stringChan 读取的数据hello0</span><br><span class="line">从 stringChan 读取的数据hello1</span><br><span class="line">从 intChan 读取的数据<span class="number">5</span></span><br><span class="line">从 intChan 读取的数据<span class="number">6</span></span><br><span class="line">从 intChan 读取的数据<span class="number">7</span></span><br><span class="line">从 intChan 读取的数据<span class="number">8</span></span><br><span class="line">从 stringChan 读取的数据hello2</span><br><span class="line">从 stringChan 读取的数据hello3</span><br><span class="line">从 intChan 读取的数据<span class="number">9</span></span><br><span class="line">从 stringChan 读取的数据hello4</span><br><span class="line">都取不到了，不玩了, 程序员可以加入逻辑</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h2 id="反射">18.反射</h2>
<blockquote>
<p><font size="5">引入</font></p>
<p>有时我们需要写一个函数，这个函数有能力统一处理各种值类型，而这些类型可能无法共享同一个接口，也可能布局未知，也有可能这个类型在我们设计函数时还不存在，这个时候我们就可以用到反射。</p>
<p>1、空接口可以存储任意类型的变量，那我们如何知道这个空接口保存数据的类型是什么？值是什么呢？</p>
<p>​ 1.可以使用类型断言</p>
<p>​ 2.可以使用反射实现，也就是在程序运行时动态的获取一个变量的类型信息和值信息。</p>
<p>2、把结构体序列化成 json 字符串，自定义结构体 Tag 标签的时候就用到了反射。</p>
<p>3、ORM 框架就用到了反射技术。</p>
<p><strong>ORM:</strong>对象关系映射（Object Relational Mapping，简称 ORM）是通过使用描述对象和数据库之间映射的元数据，将面向对象语言程序中的对象自动持久化到关系数据库中。</p>
<p>此外，虽然反射是一个强大并富有表现力的工具，能让我们写出更灵活的代码。但是反射不应该被滥用。首先基于反射的代码是极其脆弱的，反射中的类型错误会在真正运行的时候才会引发 panic，那很可能是在代码写完的很长时间之后。同时大量使用反射的代码通常难以理解。</p>
</blockquote>
<p><font color="#ef042a"><strong>反射是指在程序运行期间对程序本身进行访问和修改的能力</strong></font>。<strong>正常情况</strong>程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。<strong>支持反射的语言</strong>可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。</p>
<p><strong>Go</strong> <strong>语言中的变量是分为两部分的</strong>:</p>
<p>• <strong>类型信息</strong>：预先定义好的元信息。</p>
<p>• <strong>值信息</strong>：程序运行过程中可动态变化的。</p>
<p>在 GoLang 的反射机制中，任何接口值都由是一个<strong>具体类型</strong>和<strong>具体类型的值</strong>两部分组成的。</p>
<p>在 GoLang 中，反射的相关功能由内置的 reflect 包提供，任意接口值在反射中都可以理解为由 reflect.Type 和 reflect.Value 两 部 分 组 成 ， 并 且 reflect 包 提 供 了 <strong>reflect.TypeOf</strong> 和 <strong>reflect.ValueOf</strong> 两个重要函数来获取任意对象的 Value 和 Type。</p>
<h3 id="reflect.typeof-获取任意值的类型对象">18.1.reflect.TypeOf() 获取任意值的类型对象</h3>
<p>在 Go 语言中，使用 reflect.TypeOf()函数可以接受任意 interface{}参数，可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectType</span><span class="params">(x <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">	T := reflect.TypeOf(x)</span><br><span class="line">	fmt.Printf(<span class="string">"type:%v\n"</span>, T)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">float32</span> = <span class="number">12.5</span></span><br><span class="line">	reflectType(a) <span class="comment">// type:float32</span></span><br><span class="line">	<span class="keyword">var</span> b <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line">	reflectType(b) <span class="comment">// type:int64</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><font color="#4eb434" size="5"><strong>Name 和 Kind</strong></font></p>
<p><strong>在反射中关于类型还划分为两种：</strong>类型（Type）和种类（Kind）。因为在 Go 语言中我们可以使用 type 关键字构造很多自定义类型，而<strong>种类（Kind）就是指底层的类型</strong>。但在反射中，当需要区分指针、结构体等大品种的类型时，<strong>就会用到种类（Kind）</strong>。 例如：</p>
<blockquote>
<p>注：Go 语言的反射中像数组、切片、Map、指针等类型的变量，（除有别名外）它们的.Name()都是返回空。</p>
</blockquote>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectType</span><span class="params">(x <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">	t := reflect.TypeOf(x)</span><br><span class="line">	fmt.Printf(<span class="string">"TypeOf:%v Name:%v Kind:%v\n"</span>, t, t.Name(), t.Kind())</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myInt <span class="type">int64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> {</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> {</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> a *<span class="type">float32</span> <span class="comment">// 指针</span></span><br><span class="line">	<span class="keyword">var</span> b myInt    <span class="comment">// 自定义类型</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="type">rune</span>     <span class="comment">// 类型别名</span></span><br><span class="line"></span><br><span class="line">	reflectType(a) <span class="comment">// TypeOf:*float32 Name:   Kind:ptr</span></span><br><span class="line">	reflectType(b) <span class="comment">// TypeOf:main.myInt Name:myInt Kind:int64</span></span><br><span class="line">	reflectType(c) <span class="comment">// TypeOf:int32 Name:int32 Kind:int32</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> d = Person{</span><br><span class="line">		Name: <span class="string">"itying"</span>,</span><br><span class="line">		Age:  <span class="number">18</span>}</span><br><span class="line">	<span class="keyword">var</span> e = Animal{Name: <span class="string">"小花"</span>}</span><br><span class="line"></span><br><span class="line">	reflectType(d) <span class="comment">// TypeOf:main.Person Name:Person Kind:struct</span></span><br><span class="line">	reflectType(e) <span class="comment">// TypeOf:main.Animal Name:Animal Kind:struct</span></span><br><span class="line">	<span class="keyword">var</span> f = []<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}</span><br><span class="line">	reflectType(f) <span class="comment">//TypeOf:[]int Name: Kind:slice</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//在 reflect 包中定义的 Kind 类型如下：</span></span><br><span class="line">	<span class="keyword">type</span> Kind <span class="type">uint</span></span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		Invalid       Kind = <span class="literal">iota</span> <span class="comment">// 非法类型</span></span><br><span class="line">		Bool                      <span class="comment">// 布尔型</span></span><br><span class="line">		Int                       <span class="comment">// 有符号整型</span></span><br><span class="line">		Int8                      <span class="comment">// 有符号 8 位整型</span></span><br><span class="line">		Int16                     <span class="comment">// 有符号 16 位整型</span></span><br><span class="line">		Int32                     <span class="comment">// 有符号 32 位整型</span></span><br><span class="line">		Int64                     <span class="comment">// 有符号 64 位整型</span></span><br><span class="line">		Uint                      <span class="comment">// 无符号整型</span></span><br><span class="line">		Uint8                     <span class="comment">// 无符号 8 位整型</span></span><br><span class="line">		Uint16                    <span class="comment">// 无符号 16 位整型</span></span><br><span class="line">		Uint32                    <span class="comment">// 无符号 32 位整型</span></span><br><span class="line">		Uint64                    <span class="comment">// 无符号 64 位整型</span></span><br><span class="line">		Uintptr                   <span class="comment">// 指针</span></span><br><span class="line">		Float32                   <span class="comment">// 单精度浮点数</span></span><br><span class="line">		Float64                   <span class="comment">// 双精度浮点数</span></span><br><span class="line">		Complex64                 <span class="comment">// 64 位复数类型</span></span><br><span class="line">		Complex128                <span class="comment">// 128 位复数类型</span></span><br><span class="line">		Array                     <span class="comment">// 数组</span></span><br><span class="line">		Chan                      <span class="comment">// 通道</span></span><br><span class="line">		Func                      <span class="comment">// 函数</span></span><br><span class="line">		Interface                 <span class="comment">// 接口</span></span><br><span class="line">		Map                       <span class="comment">// 映射</span></span><br><span class="line">		Ptr                       <span class="comment">// 指针</span></span><br><span class="line">		Slice                     <span class="comment">// 切片</span></span><br><span class="line">		String                    <span class="comment">// 字符串</span></span><br><span class="line">		Struct                    <span class="comment">// 结构体</span></span><br><span class="line">		UnsafePointer             <span class="comment">// 底层指针</span></span><br><span class="line">	)</span><br></pre></td></tr></tbody></table></figure><p></p>
</blockquote>
<h3 id="reflect.valueof-获取任意对象值">18.2.reflect.ValueOf() 获取任意对象值</h3>
<p>reflect.ValueOf()返回的是 reflect.Value 类型，其中包含了原始值的值信息。当然 reflect.Value 与原始值之间可以互相转换。<strong>reflect.Value</strong> <strong>类型提供的获取原始值的方法如下：</strong></p>
<table class="table-2 table-2-sm">
<thead class="thead-dark">
<tr>
<th width="18%">
方法
</th>
<th align="center">
含义
</th>
</tr>
</thead>
<tbody>
<tr class="alert" role="alert">
<th scope="row" width="18%" align="left">
Interface()——interface{}
</th>
<td align="left">
将值以 interface{} 类型返回，可以通过类型断言转换为指定类型
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row" align="left">
Int()——int64
</th>
<td align="left">
将值以 int 类型返回，所有有符号整型均可以此方式返回
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row" align="left">
Uint()——uint64
</th>
<td align="left">
将值以 uint 类型返回，所有无符号整型均可以此方式返回
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row" align="left">
Float()——float64
</th>
<td align="left">
将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row" align="left">
Bool()——bool
</th>
<td align="left">
将值以 bool 类型返回
</td>
</tr><tr class="alert" role="alert">
<th scope="row" align="left">
Bytes()——[]bytes
</th>
<td align="left">
将值以字节数组 []bytes 类型返回
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row" align="left">
String()——string
</th>
<td align="left">
将值以字符串类型返回
</td>
</tr>
</tbody>
</table>
<p><strong>例1.获取原始值</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectValue</span><span class="params">(x <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	<span class="keyword">var</span> c = v.Int() + <span class="number">6</span> <span class="comment">//获取反射的原始值</span></span><br><span class="line">	fmt.Println(c)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line">	reflectValue(a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>例2：原始值和reflect.Value相互转换</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectValue</span><span class="params">(x <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	k := v.Kind()</span><br><span class="line">	<span class="keyword">switch</span> k {</span><br><span class="line">	<span class="keyword">case</span> reflect.Int64:</span><br><span class="line">		<span class="comment">// v.Int()从反射中获取整型的原始值</span></span><br><span class="line">		fmt.Printf(<span class="string">"type is int64, value is %d\n"</span>, v.Int())</span><br><span class="line">	<span class="keyword">case</span> reflect.Float32 | reflect.Float64:</span><br><span class="line">		<span class="comment">// v.Float()从反射中获取浮点型的原始值</span></span><br><span class="line">		fmt.Printf(<span class="string">"type is float, value is %f\n"</span>, v.Float())</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">float32</span> = <span class="number">3.14</span></span><br><span class="line">	<span class="keyword">var</span> b <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line">	reflectValue(a) <span class="comment">// type is float, value is 3.140000</span></span><br><span class="line">	reflectValue(b) <span class="comment">// type is int64, value is 100</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 int 类型的原始值转换为 reflect.Value 类型</span></span><br><span class="line">	c := reflect.ValueOf(<span class="number">10</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"type c :%T\n"</span>, c) <span class="comment">// type c :reflect.Value</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="通过反射修改变量值">18.3.通过反射修改变量值</h3>
<p>想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，<strong>必须传递变量地址才能修改变量值</strong>。反射中使用专有的 <strong>Elem()</strong> 方法来获取指针对应的值，然后使用以下函数修改指针对应值：</p>
<div style="border: 5px solid orange; padding: 10px; width: 80%; margin: 0 auto; text-align: left;">
<p>func (v Value) SetBool(x bool)<br> func (v Value) Setlnt(x int64)<br> func (v Value) SetUint(x uint64)<br> func (v Value) SetFloat(x float64)<br> func (v Value) SetComplex(x complex128)<br> func (v Value) SetBytes(x []byte)<br> func (v Value) SetString(x string)<br> func (v Value) SetPointer(x unsafe.Pointer)<br> func (v Value) SetCap(n int)<br> func (v Value) SetLen(n int)<br> func (v Value) SetMapIndex(key, val Value)<br> func (v Value) Set(x Value)</p>
</div>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue1</span><span class="params">(x <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	<span class="keyword">if</span> v.Kind() == reflect.Int64 {</span><br><span class="line">		v.SetInt(<span class="number">200</span>) <span class="comment">//修改的是副本，reflect 包会引发 panic</span></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue2</span><span class="params">(x <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	<span class="comment">// 反射中使用 Elem()方法获取指针对应的值</span></span><br><span class="line">	<span class="keyword">if</span> v.Elem().Kind() == reflect.Int64 {</span><br><span class="line">		v.Elem().SetInt(<span class="number">200</span>)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line">	<span class="comment">// reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value</span></span><br><span class="line">	reflectSetValue2(&amp;a) <span class="comment">//200</span></span><br><span class="line">	fmt.Println(a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="反射与结构体">18.4.反射与结构体</h3>
<p>任意值通过 reflect.TypeOf()获得反射对象信息后，如果它的类型是结构体，可以通过反射类型对象（reflect.Type）的方法获得结构体成员的详细信息，如字段、方法等。</p>
<p><strong>reflect.Type</strong> 中常见的与获取结构体成员相关的的方法如下表：</p>
<table class="table-2 table-2-sm">
<thead class="thead-light">
<tr>
<th width="50%">
方法
</th>
<th>
含义
</th>
</tr>
</thead>
<tbody>
<tr class="alert" role="alert">
<th scope="row">
Field(i int) StructField
</th>
<td>
根据索引，返回索引对应的结构体字段的信息。
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
NumField() int
</th>
<td>
返回结构体成员字段数量。
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
FieldByName(name string) (StructField, bool)
</th>
<td>
根据给定字符串返回字符串对应的结构体字段的信息。
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
FieldByIndex(index []int) StructField
</th>
<td>
多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
FieldByNameFunc(match func(string) bool) (StructField,bool)
</th>
<td>
根据传入的匹配函数匹配需要的字段。
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
NumMethod() int
</th>
<td>
返回该类型的方法集中方法的数目。
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
Method(int) Method
</th>
<td>
返回该类型方法集中的第 i 个方法。
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
MethodByName(string)(Method, bool)
</th>
<td>
根据方法名返回该类型方法集中的方法。
</td>
</tr>
</tbody>
</table>
<blockquote>
<p><font color="#4eb434" size="5"><strong>注：StructField 类型</strong></font></p>
<p>StructField 类型用来描述结构体中的一个字段的信息。StructField 的定义如下：</p>
<p></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StructField <span class="keyword">struct</span> {</span><br><span class="line">	<span class="comment">// 参见 http://golang.org/ref/spec#Uniqueness_of_identifiers</span></span><br><span class="line">	Name      <span class="type">string</span>    <span class="comment">// Name 是字段的名字</span></span><br><span class="line">	PkgPath   <span class="type">string</span>    <span class="comment">//PkgPath 是非导出字段的包路径，对导出字段该字段为"" Type Type // 字段的类型</span></span><br><span class="line">	Tag       StructTag <span class="comment">// 字段的标签</span></span><br><span class="line">	Offset    <span class="type">uintptr</span>   <span class="comment">// 字段在结构体中的字节偏移量</span></span><br><span class="line">	Index     []<span class="type">int</span>     <span class="comment">// 用于 Type.FieldByIndex 时的索引切片</span></span><br><span class="line">	Anonymous <span class="type">bool</span>      <span class="comment">// 是否匿名字段</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
</blockquote>
<p>下面是两个例子：</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">反射查看结构体信息</button><button type="button" class="tab " data-href="样例-2">反射修改结构体信息</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// student 结构体</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> {</span><br><span class="line">	Name  <span class="type">string</span> <span class="string">`json:"name"`</span> <span class="comment">// 字段标签 tag</span></span><br><span class="line">	Age   <span class="type">int</span>    <span class="string">`json:"age"`</span></span><br><span class="line">	Score <span class="type">int</span>    <span class="string">`json:"score"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span></span> GetInfo() <span class="type">string</span> {</span><br><span class="line">	<span class="keyword">var</span> str = fmt.Sprintf(<span class="string">"姓名:%v 年龄:%v 成绩:%v"</span>, s.Name, s.Age, s.Score)</span><br><span class="line">	fmt.Println(str)</span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span></span> SetInfo(name <span class="type">string</span>, age <span class="type">int</span>, score <span class="type">int</span>) {</span><br><span class="line">	s.Name = name</span><br><span class="line">	s.Age = age</span><br><span class="line">	s.Score = score</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span></span> Print() {</span><br><span class="line">	fmt.Println(<span class="string">"打印方法..."</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结构体字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintStructField</span><span class="params">(s <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">	t := reflect.TypeOf(s)</span><br><span class="line">	<span class="comment">// v := reflect.ValueOf(s)</span></span><br><span class="line">	kind := t.Kind()</span><br><span class="line">	<span class="keyword">if</span> kind != reflect.Struct &amp;&amp; kind != reflect.Ptr {</span><br><span class="line">		fmt.Println(<span class="string">"传入的不是结构体"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过类型变量里面的 Field 可以获取结构体的字段</span></span><br><span class="line">	field0 := t.Field(<span class="number">0</span>)</span><br><span class="line">	fmt.Println(field0.Name)</span><br><span class="line">	fmt.Println(field0.Type)</span><br><span class="line">	fmt.Println(field0.Tag.Get(<span class="string">"json"</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类型变量里面的 FieldByName 可以获取结构体的字段</span></span><br><span class="line">	field1, _ := t.FieldByName(<span class="string">"Age"</span>)</span><br><span class="line">	fmt.Println(field1.Name)</span><br><span class="line">	fmt.Println(field1.Type)</span><br><span class="line">	fmt.Println(field1.Tag.Get(<span class="string">"json"</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、通过类型变量里面的 NumField 可以获取到该结构体有几个字段</span></span><br><span class="line">	num := t.NumField()</span><br><span class="line">	fmt.Println(<span class="string">"字段数量:"</span>, num)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结构体方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintStructFn</span><span class="params">(s <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">	t := reflect.TypeOf(s)</span><br><span class="line">	v := reflect.ValueOf(s)</span><br><span class="line">	<span class="keyword">if</span> t.Kind() != reflect.Struct &amp;&amp; t.Elem().Kind() != reflect.Struct {</span><br><span class="line">		fmt.Println(<span class="string">"传入的不是结构体"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过类型变量里面的 Method 可以获取结构体的方法</span></span><br><span class="line">	<span class="keyword">var</span> tMethod = t.Method(<span class="number">0</span>) <span class="comment">//注意</span></span><br><span class="line">	fmt.Println(tMethod.Name)</span><br><span class="line">	fmt.Println(tMethod.Type)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类型变量获取这个结构体有多少个方法</span></span><br><span class="line">	fmt.Println(t.NumMethod())</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3、执行方法 （注意需要使用值变量，并且要注意参数）</span></span><br><span class="line">	<span class="comment">// v.Method(0).Call(nil)</span></span><br><span class="line">	v.MethodByName(<span class="string">"Print"</span>).Call(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4、执行方法传入参数 （注意需要使用值变量，并且要注意参数）</span></span><br><span class="line">	<span class="keyword">var</span> params []reflect.Value <span class="comment">//声明了 []reflect.Value</span></span><br><span class="line">	params = <span class="built_in">append</span>(params, reflect.ValueOf(<span class="string">"张三"</span>))</span><br><span class="line">	params = <span class="built_in">append</span>(params, reflect.ValueOf(<span class="number">22</span>))</span><br><span class="line">	params = <span class="built_in">append</span>(params, reflect.ValueOf(<span class="number">100</span>))</span><br><span class="line">	v.MethodByName(<span class="string">"SetInfo"</span>).Call(params) <span class="comment">//传入的参数是 []reflect.Value, 返回[]reflect.Value</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5、执行方法获取方法的值</span></span><br><span class="line">	info := v.MethodByName(<span class="string">"GetInfo"</span>).Call(<span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(info)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	stu1 := Student{</span><br><span class="line">		Name: <span class="string">"小明"</span>, Age: <span class="number">15</span>, Score: <span class="number">98</span>}</span><br><span class="line">	PrintStructField(stu1)</span><br><span class="line">	PrintStructFn(&amp;stu1)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Name</span></span><br><span class="line"><span class="comment">string</span></span><br><span class="line"><span class="comment">name</span></span><br><span class="line"><span class="comment">Age</span></span><br><span class="line"><span class="comment">int</span></span><br><span class="line"><span class="comment">age</span></span><br><span class="line"><span class="comment">字段数量: 3</span></span><br><span class="line"><span class="comment">GetInfo</span></span><br><span class="line"><span class="comment">func(*main.Student) string</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">打印方法...</span></span><br><span class="line"><span class="comment">姓名:张三 年龄:22 成绩:100</span></span><br><span class="line"><span class="comment">[姓名:张三 年龄:22 成绩:100]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// student 结构体</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> {</span><br><span class="line">	Name  <span class="type">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">	Age   <span class="type">int</span>    <span class="string">`json:"age"`</span></span><br><span class="line">	Score <span class="type">int</span>    <span class="string">`json:"score"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span></span> GetInfo() <span class="type">string</span> {</span><br><span class="line">	<span class="keyword">var</span> str = fmt.Sprintf(<span class="string">"姓名:%v 年龄:%v 成绩:%v"</span>, s.Name, s.Age, s.Score)</span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反射修改结构体属性</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectChangeStruct</span><span class="params">(s <span class="keyword">interface</span>{})</span></span> {</span><br><span class="line">	t := reflect.TypeOf(s)</span><br><span class="line">	v := reflect.ValueOf(s)</span><br><span class="line">	<span class="keyword">if</span> t.Elem().Kind() != reflect.Struct {</span><br><span class="line">		fmt.Println(<span class="string">"传入的不是结构体指针类型"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	name := v.Elem().FieldByName(<span class="string">"Name"</span>)</span><br><span class="line">	name.SetString(<span class="string">"李四"</span>) <span class="comment">// 设置值</span></span><br><span class="line">	age := v.Elem().FieldByName(<span class="string">"Age"</span>)</span><br><span class="line">	age.SetInt(<span class="number">20</span>) <span class="comment">// 设置值</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	stu1 := Student{</span><br><span class="line">		Name:  <span class="string">"小明"</span>,</span><br><span class="line">		Age:   <span class="number">15</span>,</span><br><span class="line">		Score: <span class="number">98</span>}</span><br><span class="line">	reflectChangeStruct(&amp;stu1)</span><br><span class="line">	fmt.Println(stu1.GetInfo()) <span class="comment">// 姓名:李四 年龄:20 成绩:98</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h2 id="文件-目录操作">19.文件 目录操作</h2>
<h3 id="文件-目录基本操作">19.1.文件 目录基本操作</h3>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">打开和关闭文件</button><button type="button" class="tab " data-href="样例-2">文件重命名</button><button type="button" class="tab " data-href="样例-3">复制文件</button><button type="button" class="tab " data-href="样例-4">创建目录</button><button type="button" class="tab " data-href="样例-5">删除目录和文件</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><p>os.Open()函数能够打开一个文件，返回一个*File 和一个 err。操作完成文件对象以后一定要记得关闭文件（为了防止文件忘记关闭，我们通常使用 defer 注册文件关闭语句）。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 只读方式打开当前目录下的 main.go 文件</span></span><br><span class="line">	file, err := os.Open(<span class="string">"./main.go"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(<span class="string">"open file failed!, err:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	}</span><br><span class="line">	fmt.Println(file)  <span class="comment">//&amp;{0xc000078780}</span></span><br><span class="line">	<span class="keyword">defer</span> file.Close() <span class="comment">// 关闭文件</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	err := os.Rename(<span class="string">"C:/Users/LENOVO/Desktop/go/go.sum"</span>, <span class="string">"C:/Users/LENOVO/Desktop/go/go1.sum"</span>) <span class="comment">//只能同盘操作</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-3"><p><strong>第一种复制文件方法：ioutil 进行复制</strong>（go 1.16 起弃用该方法）</p>
<details class="toggle">
<summary class="toggle-button" style="">
代码
</summary>
<div class="toggle-content">
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己编写一个函数，接收两个文件路径 srcFileName dstFileName</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstFileName <span class="type">string</span>, srcFileName <span class="type">string</span>)</span></span> (err <span class="type">error</span>) {</span><br><span class="line">	input, err := ioutil.ReadFile(srcFileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line">	err = ioutil.WriteFile(dstFileName, input, <span class="number">0644</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(<span class="string">"Error creating"</span>, dstFileName)</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	srcFile := <span class="string">"c:/test1.zip"</span></span><br><span class="line">	dstFile := <span class="string">"D:/test1.zip"</span></span><br><span class="line">	err := CopyFile(dstFile, srcFile)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> {</span><br><span class="line">		fmt.Printf(<span class="string">"拷贝完成\n"</span>)</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		fmt.Printf(<span class="string">"拷贝错误 err=%v\n"</span>, err)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</div>
</details>
<p><strong>第二种复制文件方法流的方式复制：</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己编写一个函数，接收两个文件路径 srcFileName dstFileName</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstFileName <span class="type">string</span>, srcFileName <span class="type">string</span>)</span></span> (err <span class="type">error</span>) {</span><br><span class="line">	source, _ := os.Open(srcFileName)</span><br><span class="line">	destination, _ := os.OpenFile(dstFileName, os.O_CREATE|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">128</span>)</span><br><span class="line">	<span class="keyword">for</span> {</span><br><span class="line">		n, err := source.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF {</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> {</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> _, err := destination.Write(buf[:n]); err != <span class="literal">nil</span> {</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">//调用 CopyFile 完成文件拷贝</span></span><br><span class="line">	srcFile := <span class="string">"c:/000.avi"</span></span><br><span class="line">	dstFile := <span class="string">"D:/000.avi"</span></span><br><span class="line">	err := CopyFile(dstFile, srcFile)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> {</span><br><span class="line">		fmt.Printf(<span class="string">"拷贝完成\n"</span>)</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		fmt.Printf(<span class="string">"拷贝错误 err=%v\n"</span>, err)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-4"><p>1.一次创建一个目录：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	err := os.Mkdir(<span class="string">"C:/Users/LENOVO/Desktop/go/abc"</span>, <span class="number">0666</span>) <span class="comment">//创建 abc 文件夹</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>2.一次创建多个目录：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 创建多级目录dir1/dir2/dir3</span></span><br><span class="line">	err := os.MkdirAll(<span class="string">"C:/Users/LENOVO/Desktop/go/dir1/dir2/dir3"</span>, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-5"><p>1.删除一个目录或者文件</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 删除</span></span><br><span class="line">	err := os.Remove(<span class="string">"C:/Users/LENOVO/Desktop/go/abc"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>2.一次删除多个目录或者文件</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 删除</span></span><br><span class="line">	err := os.RemoveAll(<span class="string">"C:/Users/LENOVO/Desktop/go/dir1"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h3 id="读取文件">19.2.读取文件</h3>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">file.Read()读取</button><button type="button" class="tab " data-href="样例-2">循环读取</button><button type="button" class="tab " data-href="样例-3">bufio读取</button><button type="button" class="tab " data-href="样例-4">io/ioutil读取</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><p>Read 方法定义如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span></span> Read(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回 0 和io.EOF。 举个例子：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 只读方式打开当前目录下的 main.go 文件</span></span><br><span class="line">	file, err := os.Open(<span class="string">"./main.go"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(<span class="string">"open file failed!, err:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 Read 方法读取数据，注意一次只会读取 128 个字节</span></span><br><span class="line">	<span class="keyword">var</span> tmp = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">128</span>)</span><br><span class="line">	n, err := file.Read(tmp)</span><br><span class="line">	<span class="keyword">if</span> err == io.EOF {</span><br><span class="line">		fmt.Println(<span class="string">"文件读完了"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(<span class="string">"read file failed, err:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"读取了%d 字节数据\n"</span>, n)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(tmp[:n]))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><p>使用 for 循环读取文件中的所有数据 (推荐) ：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 只读方式打开当前目录下的 main.go 文件</span></span><br><span class="line">	file, err := os.Open(<span class="string">"./main.go"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(<span class="string">"open file failed!, err:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环读取文件</span></span><br><span class="line">	<span class="keyword">var</span> content []<span class="type">byte</span></span><br><span class="line">	<span class="keyword">var</span> tmp = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">128</span>)</span><br><span class="line">	<span class="keyword">for</span> {</span><br><span class="line">		n, err := file.Read(tmp)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF {</span><br><span class="line">			fmt.Println(<span class="string">"文件读完了"</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">			fmt.Println(<span class="string">"read file failed, err:"</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		}</span><br><span class="line">		content = <span class="built_in">append</span>(content, tmp[:n]...)</span><br><span class="line">	}</span><br><span class="line">  </span><br><span class="line">	fmt.Println(<span class="type">string</span>(content))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-3"><p>bufio 是在 file 的基础上封装了一层 API，支持更多的功能：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bufio 按行读取示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	file, err := os.Open(<span class="string">"C:/test.txt"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(<span class="string">"open file failed, err:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	</span><br><span class="line">	reader := bufio.NewReader(file)</span><br><span class="line">	<span class="keyword">for</span> {</span><br><span class="line">		line, err := reader.ReadString(<span class="string">'\n'</span>) <span class="comment">//注意是字符</span></span><br><span class="line">		<span class="keyword">if</span> err == io.EOF {</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(line) != <span class="number">0</span> {</span><br><span class="line">				fmt.Println(line)</span><br><span class="line">			}</span><br><span class="line">			fmt.Println(<span class="string">"文件读完了"</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">			fmt.Println(<span class="string">"read file failed, err:"</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		}</span><br><span class="line">		fmt.Print(line)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-4"><p>io/ioutil 包的 ReadFile 方法能够读取完整的文件，只需要将文件名作为参数传入（该方法在 go 1.16 后已被弃用）：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ioutil.ReadFile 读取整个文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	content, err := ioutil.ReadFile(<span class="string">"./main.go"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(<span class="string">"read file failed, err:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	}</span><br><span class="line">	fmt.Println(<span class="type">string</span>(content))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h3 id="文件写入">19.3.文件写入</h3>
<p>os.OpenFile()函数能够以指定模式打开文件，从而实现文件写入相关功能，其格式如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (*File, <span class="type">error</span>) {</span><br><span class="line">	... </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>name：要打开的文件名</li>
<li>flag：打开文件的模式</li>
<li>perm：文件权限，一个八进制数。r（读）04，w（写）02，x（执行）01。<code>FileMode</code> 是 <code>os</code> 包中的类型，是 <code>uint32</code> 的别名，表示文件的权限和属性。</li>
</ul>
<blockquote>
<p>常见文件打开模式：</p>
<table>
<thead>
<tr class="header">
<th>模式</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>os.O_WRONLY</td>
<td>只写</td>
</tr>
<tr class="even">
<td>os.O_CREATE</td>
<td>创建文件</td>
</tr>
<tr class="odd">
<td>os.O_RDONLY</td>
<td>只读</td>
</tr>
<tr class="even">
<td>os.O_RDWR</td>
<td>读写</td>
</tr>
<tr class="odd">
<td>os.O_TRUNC</td>
<td>清空</td>
</tr>
<tr class="even">
<td>os.O_APPEND</td>
<td>追加</td>
</tr>
</tbody>
</table>
<p>常见 FileMode:</p>
<table border="1" cellpadding="5" cellspacing="0">
<thead>
<tr>
<th>
常量
</th>
<th>
描述
</th>
<th>
说明
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>0600</code>
</td>
<td>
读写权限（用户）
</td>
<td>
默认权限（例：<code>os.FileMode(0600)</code>），表示用户有读写权限
</td>
</tr>
<tr>
<td>
<code>0644</code>
</td>
<td>
用户读写，组和其他读权限
</td>
<td>
常用权限值
</td>
</tr>
<tr>
<td>
<code>0777</code>
</td>
<td>
所有权限（读、写、执行）
</td>
<td>
最宽权限，通常不建议设置
</td>
</tr>
<tr>
<td>
<code>0666</code>
</td>
<td>
所有人读写权限
</td>
<td>
所有人（用户、组、其他）都可以读和写该文件，但不能执行（没有 x 权限）。<br> "0"表示没有特殊模式，"666"每一位表示对应用户类型的权限（rwx）。"6"是二进制的 110，对应 读 (4) + 写 (2)，没有执行权限 (0)。
</td>
</tr>
</tbody>
</table>
</blockquote>
<p>文件写入有以下三种方法：</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">Write 和 WriteString</button><button type="button" class="tab " data-href="样例-2">bufio.NewWriter</button><button type="button" class="tab " data-href="样例-3">ioutil.WriteFile</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	file, err := os.OpenFile(<span class="string">"C:/test.txt"</span>, os.O_CREATE|os.O_RDWR, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(<span class="string">"open file failed, err:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	</span><br><span class="line">	str := <span class="string">"你好 golang"</span></span><br><span class="line">	file.Write([]<span class="type">byte</span>(str))        <span class="comment">//写入字节切片数据</span></span><br><span class="line">	file.WriteString(<span class="string">"直接写入的字符串数据"</span>) <span class="comment">//直接写入字符串数据</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	file, err := os.OpenFile(<span class="string">"C:/test.txt"</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(<span class="string">"open file failed, err:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	</span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ {</span><br><span class="line">		writer.WriteString(<span class="string">"你好 golang\r\n"</span>) <span class="comment">//将数据先写入缓存</span></span><br><span class="line">	}</span><br><span class="line">	writer.Flush() <span class="comment">//将缓存中的内容写入文件（注意）</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-3"><p>注意，ioutil 在 go 1.16 后已被弃用。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	str := <span class="string">"hello golang"</span></span><br><span class="line">	err := ioutil.WriteFile(<span class="string">"C:/test.txt"</span>, []<span class="type">byte</span>(str), <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		fmt.Println(<span class="string">"write file failed, err:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h1 id="三go-中的包管理">三、Go 中的包管理</h1>
<p><strong>包（package）</strong>是多个 Go 源码的集合，是一种高级的代码复用方案。</p>
<p><strong>Golang</strong> <strong>中的包可以分为三种</strong>：1、系统内置包 2、自定义包 3、第三方包。</p>
<ul>
<li><strong>系统内置包</strong>: Golang 语言给我们提供的内置包，引入后可以直接使用，如 fmt、strconv、strings、sort、errors、time、encoding/json、os、io 等。</li>
<li><strong>自定义包</strong>：开发者自己写的包。</li>
<li><strong>第三方包：</strong>属于自定义包的一种，需要下载安装到本地后才可以使用，如前面介绍的"github.com/shopspring/decimal"包解决 float 精度丢失问题。</li>
</ul>
<h2 id="go-mod-指令管理项目">1.go mod 指令管理项目</h2>
<p>以下指令运用格式前缀均为：<code>go mod</code>，如 <code>go mod init</code></p>
<table class="table-2 table-2-sm">
<thead class="thead-dark">
<tr>
<th width="15%">
指令
</th>
<th align="center">
含义
</th>
</tr>
</thead>
<tbody>
<tr class="alert" role="alert">
<th scope="row" width="15%" style="bold">
init
</th>
<td align="left" style="text-indent: 2em;">
initialize new module in current directory(在当前文件夹下初始化一个新的 module, 创建 go.mod 文件)
<p>
该命令通常在初始化新项目时使用，格式 <code>go mod init ProjectName</code>，go.mod 文件中即为项目的配置信息（module名、go version、依赖包等）。
</p>
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row" width="15%" style="bold">
download
</th>
<td align="left" style="text-indent: 2em;">
download modules to local cache(下载依赖的 module 到本地 cache)
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row" width="15%" style="bold">
edit
</th>
<td align="left" style="text-indent: 2em;">
edit go.mod from tools or scripts (编辑 go.mod 文件)
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row" width="15%" style="bold">
graph
</th>
<td align="left" style="text-indent: 2em;">
print module requirement graph (打印模块依赖图)
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row" width="15%" style="bold">
tidy
</th>
<td align="left" style="text-indent: 2em;">
add missing and remove unused modules (增加丢失的 module，去掉未用的 module)
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row" width="15%" style="bold">
vendor
</th>
<td align="left" style="text-indent: 2em;">
make vendored copy of dependencies (将依赖复制到 vendor 下)
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row" width="15%" style="bold">
verify
</th>
<td align="left" style="text-indent: 2em;">
verify dependencies have expected content (校验依赖 检查下载的第三方库有没有本地修改，如果有修改，则会返回非 0，否则验证成功。)
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row" width="15%" style="bold">
why
</th>
<td align="left" style="text-indent: 2em;">
explain why packages or modules are needed (解释为什么需要依赖)
</td>
</tr>
</tbody></table>
<h2 id="golang-中自定义包">2.Golang 中自定义包</h2>
<p><strong>包（package）</strong>是多个 Go 源码的集合，一个包可以简单理解为<strong>一个存放多个.go 文件的文件夹（文件夹名即为包名）</strong>。一个 Module 下可以有多个包。<strong>该文件夹下面的所有 go 文件都要在代码的第一行添加包声明代码，声明该文件归属的包。</strong></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>一个文件夹下面直接包含的文件只能归属一个 package，同样一个 package 的文件不能在多个文件夹下。</li>
<li>包名可以不和文件夹的名字一样，包名不能包含 - 符号。</li>
<li>包名为 main 的包为应用程序的入口包，这种包编译后会得到一个可执行文件，而编译不包含 main 包的源代码则不会得到可执行文件 (包名不是 main 的包不可以直接运行) 。</li>
</ul>
<p><font color="#4eb434" size="5"><strong>定义一个包</strong></font></p>
<p>定义包时，如果想在一个包中引用另外一个包里的标识符（如变量、常量、类型、函数等）时，该标识符必须是对外可见的（public）。在 Go 语言中只需要将标识符的首字母大写就可以让标识符对外可见了。如，定义一个包名为 calc 的包，可以先新建一个名为 calc 的文件夹，然后再在文件夹中新建以下 xx.go 文件：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> calc</span><br><span class="line"></span><br><span class="line"><span class="comment">//包名不是 main，不能直接运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//首字母大小表示公有，首字母小写表示私有</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>  <span class="comment">//私有变量</span></span><br><span class="line"><span class="keyword">var</span> Age = <span class="number">20</span> <span class="comment">//公有变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sum</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> {</span><br><span class="line">	<span class="keyword">return</span> x - y</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><font color="#4eb434" size="5"><strong>将定义的包在 main 包中引入</strong></font></p>
<p>访问一个包里面的公有属性方法的时候需要通过<strong>包名称.公有属性方法</strong>去访问</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"test01/calc"</span>	<span class="comment">// 这里的test01是通过 go mod init test01 得到的 go.mod 文件里的 Module 名，calc 包就在这个 Module 下</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	c := calc.Add(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果只希望导入包，而不使用包内部的数据时，可以使用匿名导入包。具体的格式为：<code>import _ "包的路径"</code>。匿名导入的包与其他方式导入的包一样都会被编译到可执行文件中。</p>
<p>在导入包名的时候，我们还可以为导入的包设置别名。通常用于导入的包名太长或者导入的包名冲突的情况。具体语法格式为：<code>import 别名 "包的路径"</code>。</p>
<h2 id="golang-中-init-初始化函数">3.Golang 中 init() 初始化函数</h2>
<p>在 Go 语言程序执行时导入包语句会自动触发包内部 init()函数的调用。需要注意的是：init() 函数没有参数也没有返回值。 init()函数在程序运行时自动被调用执行，不能在代码中主动调用它。</p>
<p>包初始化执行的顺序如下图所示：</p>
<p><img src="/img/load1.gif" data-original="https://cdn.jsdelivr.net/gh/hahahaha5606/blogImage/images/image-20250518152203575.png" style="zoom:67%;"></p>
<blockquote>
<p>上图中，程序会先输出 init 函数中的 10，然后再输出 main 函数中的 “Hello”</p>
</blockquote>
<p>Go 语言包会从 main 包开始检查其导入的所有包，每个包中又可能导入了其他的包。Go 编译器由此构建出一个树状的包引用关系，再根据引用顺序决定编译顺序，依次编译这些包的代码。</p>
<p>在运行时，被最后导入的包会最先初始化并调用其 init()函数（后入先出）， 如下图示：</p>
<p><img src="/img/load2.gif" data-original="https://cdn.jsdelivr.net/gh/hahahaha5606/blogImage/images/image-20250518152352804.png" alt="image-20250518152352804" style="zoom:67%;"></p>
<h2 id="golang-中使用第三方包">4.Golang 中使用第三方包</h2>
<p>我们可以在 https://pkg.go.dev/ 查找看常见的 golang 第三方包</p>
<p>在使用 <code>go mod init ProjectName</code> 初始化项目后，cd 到项目里，（可选：使用 go get 包地址/包名下载安装需要的第三方包）,引入需要的包后使用 <code>go mod tidy</code> 添加缺失的依赖，去掉不用的依赖，保持代码整洁。</p>
<h1 id="四gin-框架开发">四、Gin 框架开发</h1>
<p><strong>Gin</strong> 是一个流行的 Go (Golang) 编写的轻量级 http web 框架，运行速度非常快，适用于 Api 接口的高并发。</p>
<p>Gin 的官网：https://gin-gonic.com/zh-cn/</p>
<p>Gin Github 地址：https://github.com/gin-gonic/gin</p>
<h2 id="gin-环境搭建">1.Gin 环境搭建</h2>
<p>1.首先下载并安装 Gin，在 Go 文件夹所在目录打开终端输入：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></tbody></table></figure>
<p>2.将 gin 引入到代码中：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/gin-gonic/gin"</span></span><br></pre></td></tr></tbody></table></figure>
<p>3.（可选）如果使用诸如 http.StatusOK 之类的常量，则需要引入 net/http 包：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br></pre></td></tr></tbody></table></figure>
<p>4.新建 Main.go 配置路由</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 创建一个默认的路由引擎</span></span><br><span class="line">	r := gin.Default()</span><br><span class="line">	<span class="comment">// 配置路由</span></span><br><span class="line">	r.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> { <span class="comment">// c是当前请求的上下文，封装有请求和响应的所有信息</span></span><br><span class="line">		c.JSON(<span class="number">200</span>, gin.H{ <span class="comment">// c.JSON：返回 JSON 格式的数据</span></span><br><span class="line">			<span class="string">"message"</span>: <span class="string">"Hello world!"</span>})</span><br><span class="line">	}) </span><br><span class="line">	r.GET(<span class="string">"/news"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> { <span class="comment">// 地址需改为：localhost:8080/news</span></span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"我是新闻页面"</span>) <span class="comment">// 状态码200表示“请求成功”</span></span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	r.POST(<span class="string">"/add"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		c.String(http.StatusOK, <span class="string">"这是一个post, 主要用于添加数据"</span>) <span class="comment">// http.StatusOK 是状态码,相当于200</span></span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	r.PUT(<span class="string">"/update"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		c.String(http.StatusOK, <span class="string">"这是一个put, 主要用于更新编辑数据"</span>)</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	r.DELETE(<span class="string">"/delete"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"这是一个delete, 主要用于删除数据"</span>)</span><br><span class="line">	})</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 启动 HTTP 服务，默认在 0.0.0.0:8080 启动服务</span></span><br><span class="line">	r.Run()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>5.运行项目</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 直接点击运行 或 在终端输入：</span></span><br><span class="line"><span class="keyword">go</span> run main.<span class="keyword">go</span></span><br></pre></td></tr></tbody></table></figure>
<p>在浏览器输入端口号：<code>localhost:8080</code> 即可跳转 hello world 页面：</p>
<p><img src="/img/load1.gif" data-original="https://cdn.jsdelivr.net/gh/hahahaha5606/blogImage/images/image-20250523154603797.png" alt="image-20250523154603797" style="zoom:67%;"></p>
<p>除了 GET 操作外，POST、PUT 和 DELETE 操作在浏览器中均不可见，此时可以下载 <code>Postman</code> 软件查看对应页面（<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_61843874/article/details/123324727">Postman 入门</a>）。</p>
<p>6.要改变默认启动的端口</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">r.Run(<span class="string">":9000"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="go-程序的热加载">2.Go 程序的热加载</h2>
<p><strong>热加载</strong>就是<strong>当我们对代码进行修改时，程序能够自动重新加载并执行</strong>，这在我们开发中是非常便利的，可以快速进行代码测试，省去了每次手动重新编译。</p>
<p>beego 中我们可以使用官方给我们提供的 bee 工具来热加载项目，但是 gin 中并没有官方提供的热加载工具，这个时候我们要实现热加载就可以借助第三方的工具。</p>
<p><strong>工具</strong> <strong>1</strong>（推荐）：https://github.com/gravityblast/fresh</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/pilu/fresh</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重启终端，输入：</span></span><br><span class="line">fresh</span><br></pre></td></tr></tbody></table></figure>
<p>工具 2：https://github.com/codegangsta/gin</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/codegangsta/gin</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重启终端，输入：</span></span><br><span class="line">gin run main.<span class="keyword">go</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="gin-框架中的路由"><a id="anchor1"></a>3.Gin 框架中的路由</h2>
<blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39805338/article/details/80810379">URI</a></strong>，全称 Uniform Resource Identifier，即<strong>统一资源标识符</strong>，是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：</p>
<p></p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</span><br></pre></td></tr></tbody></table></figure><p></p>
<p><strong>1.协议部分[scheme:]</strong>：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。"//" 为分隔符。在Internet中可以使用多种协议，常见的有</p>
<ul>
<li>http 超文本传输协议资源</li>
<li>https 用安全套接字层传送的超文本传输协议</li>
<li>ftp 文件传输协议</li>
<li>mailto 电子邮件地址</li>
</ul>
<p><strong>2.域名部分[host]</strong>：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</p>
<p><strong>3.端口部分[port#]</strong>：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</p>
<p><strong>4.虚拟目录部分[path]</strong>：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</p>
<p><strong>5.文件名部分</strong>：从域名后的最后一个“/”开始到“？”为止，是文件名部分；如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分；如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</p>
<p><strong>6.参数部分[query]</strong>：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数部分中有多个参数键值对，键值对之间用“&amp;”作为分隔符。</p>
<p><strong>7.锚部分[anchor/fragment]</strong>：从“#”开始到最后，都是锚部分，用于指向资源中的特定部分或位置。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分。</p>
</blockquote>
<p><strong>路由（Routing）</strong>是由一个 URI（Uniform Resource Identifier，统一资源标识符或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成的，涉及到应用如何响应客户端对某个网站节点的访问。</p>
<p>RESTful API 是目前比较成熟的一套互联网应用程序的 API 设计理论，所以我们设计我们的路由的时候建议参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/rest-api-tutorial.html">RESTful API 指南</a>。</p>
<details class="toggle"><summary class="toggle-button" style="">RESTful API 中的 HTTP 状态码</summary><div class="toggle-content"><p>HTTP 状态码表示请求的处理结果：</p>
<table class="table-2 table-2-sm">
<thead class="thead-light">
<tr>
<th width="12%">
状态码
</th>
<th width="18%">
类别
</th>
<th>
常见状态码
</th>
</tr>
</thead>
<tbody>
<tr class="alert" role="alert">
<th scope="row">
2xx
</th>
<td>
成功
</td>
<td>
<ul>
<li>
200 OK：请求成功
</li>
<li>
201 Created：资源创建成功
</li>
<li>
204 No Content：成功但无返回内容（如DELETE操作）
</li>
</ul>
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
3xx
</th>
<td>
重定向
</td>
<td>
301 Moved Permanently
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
4xx
</th>
<td>
客户端错误
</td>
<td>
<ul>
<li>
400 Bad Request：客户端错误
</li>
<li>
401 Unauthorized：未认证
</li>
<li>
403 Forbidden：无权限
</li>
<li>
404 Not Found：资源不存在
</li>
<li>
405 Method Not Allowed：不支持的HTTP方法
</li>
<li>
409 Conflict：资源冲突
</li>
<li>
429 Too Many Requests：请求频率超限
</li>
<li>
415 Unsupported Media Type：不支持的内容类型
</li>
<li>
422 Unprocessable Entity：语义错误
</li>
</ul>
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
5xx
</th>
<td>
服务器错误
</td>
<td>
500 Internal Server Error
</td>
</tr>
</tbody>
</table>
</div></details>
<p>在 RESTful 架构中，每个网址代表一种资源，不同的请求方式表示执行不同的操作：</p>
<table class="table-2 table-2-sm">
<thead class="thead-light">
<tr>
<th width="27%">
请求方式
</th>
<th width="60%">
操作
</th>
<th>
是否幂等
</th>
</tr>
</thead>
<tbody>
<tr class="alert" role="alert">
<th scope="row">
GET（SELECT）
</th>
<td>
从服务器取出资源（一项或多项）
</td>
<td>
是
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
POST（CREATE）
</th>
<td>
在服务器新建一个资源
</td>
<td>
否
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
PUT（UPDATE）
</th>
<td>
在服务器完全更新资源（客户端提供改变后的完整资源）
</td>
<td>
是
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
PATCH
</th>
<td>
在服务器部分更新资源
</td>
<td>
否
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
DELETE（DELETE）
</th>
<td>
从服务器删除资源
</td>
<td>
是
</td>
</tr>
</tbody>
</table>
<p><font color="#985fff">"幂等"表示操作多次调用将产生相同结果。</font></p>
<p>我们可以用 Postman 软件测试简单的路由请求配置，如 Gin 环境搭建节里的第 4 步，还可以：</p>
<p><strong>路由中获取 Get 传值 (<code>c.Query</code>)</strong>：域名为 http://localhost:8080/news?aid=123 （前缀 http 和后面内容都要加）</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">r.GET(<span class="string">"/news"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">	aid := c.Query(<span class="string">"aid"</span>)</span><br><span class="line">	c.String(<span class="number">200</span>, <span class="string">"aid=%s"</span>, aid)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
<p><strong>动态路由 (<code>c.Param</code>)</strong>：域名为 http://localhost:8080/user/123 或 localhost:8080/user/123</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">r.GET(<span class="string">"/user/:uid"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		uid := c.Param(<span class="string">"uid"</span>)</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"userID=%s"</span>, uid)</span><br><span class="line">	})</span><br></pre></td></tr></tbody></table></figure>
<h2 id="响应客户端请求的不同方法">4.响应客户端请求的不同方法</h2>
<p>以下表格为在Go语言的Web框架（比如Gin）中用于响应客户端请求的不同方法，用于返回各种格式的数据或内容。</p>
<table class="table-2 table-2-sm">
<thead class="thead-light">
<tr>
<th width="27%">
响应方法
</th>
<th>
说明
</th>
</tr>
</thead>
<tbody>
<tr class="alert" role="alert">
<th scope="row">
c.String()
</th>
<td>
返回纯文本字符串
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
c.JSON()
</th>
<td>
返回JSON格式的数据
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
c.JSONP()
</th>
<td>
返回JSONP格式（适用于跨域请求）需要提供回调函数名
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
c.XML()
</th>
<td>
返回XML格式的数据
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
c.HTML()
</th>
<td>
返回HTML页面，可以插入模板内容
</td>
</tr>
</tbody>
</table>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">c.String()</button><button type="button" class="tab " data-href="样例-2">c.JSON()</button><button type="button" class="tab " data-href="样例-3">c.JSONP()</button><button type="button" class="tab " data-href="样例-4">c.XML()</button><button type="button" class="tab " data-href="样例-5">c.HTML()</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// 创建一个默认的路由引擎</span></span><br><span class="line">	r := gin.Default()</span><br><span class="line">	<span class="comment">// 配置路由</span></span><br><span class="line">	r.GET(<span class="string">"/user/:uid"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		uid := c.Param(<span class="string">"uid"</span>)</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"userID=%s"</span>, uid)</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	r.POST(<span class="string">"/add"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		c.String(http.StatusOK, <span class="string">"这是一个post, 主要用于添加数据"</span>) <span class="comment">// http.StatusOK 是状态码,相当于200</span></span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	r.PUT(<span class="string">"/update"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		c.String(http.StatusOK, <span class="string">"这是一个put, 主要用于更新编辑数据"</span>)</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	r.DELETE(<span class="string">"/delete"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"这是一个delete, 主要用于删除数据"</span>)</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动 HTTP 服务，默认在 0.0.0.0:8080 启动服务</span></span><br><span class="line">	r.Run()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	<span class="comment">// gin.H 是 map[string]interface{}的缩写</span></span><br><span class="line">	r.GET(<span class="string">"/someJSON"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		<span class="comment">// 方式一：自己拼接 JSON</span></span><br><span class="line">		c.JSON(http.StatusOK, gin.H{<span class="string">"message"</span>: <span class="string">"Hello world!"</span>})</span><br><span class="line">	})</span><br><span class="line">	r.GET(<span class="string">"/moreJSON"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		<span class="comment">// 方法二：使用结构体</span></span><br><span class="line">		<span class="keyword">var</span> msg <span class="keyword">struct</span> {</span><br><span class="line">			Name    <span class="type">string</span> <span class="string">`json:"user"`</span></span><br><span class="line">			Message <span class="type">string</span></span><br><span class="line">			Age     <span class="type">int</span></span><br><span class="line">		}</span><br><span class="line">		msg.Name = <span class="string">"wooou"</span></span><br><span class="line">		msg.Message = <span class="string">"Hello world!"</span></span><br><span class="line">		msg.Age = <span class="number">18</span></span><br><span class="line">		c.JSON(http.StatusOK, msg)</span><br><span class="line">	})</span><br><span class="line">	r.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-3"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">"/JSONP"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		data := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{<span class="string">"foo"</span>: <span class="string">"bar"</span>}</span><br><span class="line">		<span class="comment">// /JSONP?callback=x</span></span><br><span class="line">		<span class="comment">// 将输出：x({\"foo\":\"bar\"})</span></span><br><span class="line">		c.JSONP(http.StatusOK, data)</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	r.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-4"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	<span class="comment">// gin.H 是 map[string]interface{}的缩写</span></span><br><span class="line">	r.GET(<span class="string">"/someXML"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		<span class="comment">// 方式一：自己拼接 JSON</span></span><br><span class="line">		c.XML(http.StatusOK, gin.H{<span class="string">"message"</span>: <span class="string">"Hello world!"</span>})</span><br><span class="line">	})</span><br><span class="line">	r.GET(<span class="string">"/moreXML"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		<span class="comment">// 方法二：使用结构体</span></span><br><span class="line">		<span class="keyword">type</span> MessageRecord <span class="keyword">struct</span> {</span><br><span class="line">			Name    <span class="type">string</span></span><br><span class="line">			Message <span class="type">string</span></span><br><span class="line">			Age     <span class="type">int</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">var</span> msg MessageRecord</span><br><span class="line">		msg.Name = <span class="string">"wooou"</span></span><br><span class="line">		msg.Message = <span class="string">"Hello world!"</span></span><br><span class="line">		msg.Age = <span class="number">18</span></span><br><span class="line">		c.XML(http.StatusOK, msg)</span><br><span class="line">	})</span><br><span class="line">	r.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-5"><p>首先在当前目录下新建路径为 “templates/default/index.html” 的 html 文件（可以输入 <code>html:5</code> 来快速生成 html 框架）：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这里是个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>通过两个花括号和点号来访问后台数据：{{.title}}<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>然后使用 c.HTML() 访问加载 html 文件：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载模板文件（记得要加）</span></span><br><span class="line">	router.LoadHTMLGlob(<span class="string">"templates/default/*"</span>)</span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">"index.html"</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">			<span class="string">"title"</span>: <span class="string">"前台首页"</span>}) <span class="comment">//第三个参数 map[string]interface{} 也可以简写为 gin.H{}</span></span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h2 id="gin-html-模板渲染">5.Gin HTML 模板渲染</h2>
<blockquote>
<p>第4节中提供了当 html 模板文件在同一个文件夹下的加载渲染方法，当Gin 框架中不同目录下面有同名模板时，我们需要使用下面方法加载模板：</p>
<p><strong>首先在定义 html 模板文件时需用 <code>define end</code> 定义名称</strong>，以下是两个 html 模板文件</p>
<p></p><div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">代码</button><button type="button" class="tab " data-href="样例-2">预览</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><blockquote>
<p></p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">{{ define "admin/index.html" }} <span class="comment">&lt;!-- 相当于给模板定义一个名字 define end 成对出现--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>admin/index.html 文件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>通过两个花括号和点号来访问后台数据：{{.title}}<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">{{ end }}</span><br></pre></td></tr></tbody></table></figure><p></p>
</blockquote></div><div class="tab-item-content" id="样例-2"><blockquote>
<p></p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">{{ define "default/index.html" }}</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这里是个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>通过两个花括号和点号来访问后台数据：{{.title}}<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        {{.news.Title}}</span><br><span class="line">        {{.news.Content}}</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">{{ end }}</span><br></pre></td></tr></tbody></table></figure><p></p>
</blockquote></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p></p>
<p>然后在 Go 文件中加载多级目录下的 html 模板文件（<em>加载目录下的所有文件，**表示一层所有目录，*表示所有文件</em>）：</p>
<p></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Article <span class="keyword">struct</span> {</span><br><span class="line">	Title   <span class="type">string</span> <span class="comment">// 大写表示公有，小写表示私有</span></span><br><span class="line">	Content <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载模板文件（记得要加）</span></span><br><span class="line">	router.LoadHTMLGlob(<span class="string">"templates/**/*"</span>) <span class="comment">// 加载templates目录下的所有文件，**表示所有目录，*表示所有文件</span></span><br><span class="line">	</span><br><span class="line">  <span class="comment">//前台</span></span><br><span class="line">	router.GET(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		news := &amp;Article{</span><br><span class="line">			Title:   <span class="string">"新闻1"</span>,</span><br><span class="line">			Content: <span class="string">"内容1"</span>,</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">"default/index.html"</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">			<span class="string">"title"</span>: <span class="string">"前台首页"</span>,</span><br><span class="line">			<span class="string">"news"</span>:  news}) <span class="comment">//第三个参数 map[string]interface{} 也可以简写为 gin.H{}</span></span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">  <span class="comment">//后台</span></span><br><span class="line">	router.GET(<span class="string">"/admin"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">"admin/index.html"</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">			<span class="string">"title"</span>: <span class="string">"后台首页"</span>})</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
</blockquote>
<h3 id="gin-模板基本语法">5.1.Gin 模板基本语法</h3>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">输出数据</button><button type="button" class="tab " data-href="样例-2">注释</button><button type="button" class="tab " data-href="样例-3">变量</button><button type="button" class="tab " data-href="样例-4">移除空格</button><button type="button" class="tab " data-href="样例-5">比较函数</button><button type="button" class="tab " data-href="样例-6">条件判断</button><button type="button" class="tab " data-href="样例-7">range</button><button type="button" class="tab " data-href="样例-8">With</button><button type="button" class="tab " data-href="样例-9">预定义函数</button><button type="button" class="tab " data-href="样例-10">自定义模板函数</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><p>模板语法都包含在中间，其中 {{.}} 中的点表示当前对象。</p>
<p>当我们传入一个结构体对象时，我们可以根据 <code>.</code> 来访问结构体的对应字段。</p></div><div class="tab-item-content" id="样例-2"><p>Gin 的 html 模板中注释的语法为：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">{{<span class="comment">/* a comment */</span>}}</span><br></pre></td></tr></tbody></table></figure>
<p>注释，执行时会忽略。可以多行。注释不能嵌套，并且必须紧贴分界符始止。</p></div><div class="tab-item-content" id="样例-3"><p>我们还可以在模板中声明变量，用来保存传入模板的数据或其他语句生成的结果。具体语法如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">&lt;h4&gt;{{$obj := .title}}&lt;/h4&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>如下，赋值变量后打印输出变量：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">{{ define <span class="string">"default/index.html"</span> }}</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;这里是个标题&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;通过两个花括号和点号来访问后台数据：{{.title}}&lt;/h2&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 定义变量 --&gt;</span><br><span class="line">    {{$t := .news.Title}}</span><br><span class="line"></span><br><span class="line">    &lt;h3&gt;        </span><br><span class="line">        {{$t}}</span><br><span class="line">    &lt;/h3&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        {{.news.Content}}</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">{{ end }}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-4"><p>有时候我们在使用模板语法的时候会不可避免的引入一下空格或者换行符，这样模板最终渲染出来的内容可能就和我们想的不一样，这个时候可以使用 {{- 语法去除模板内容左侧的所有空白符号， 使用 -}} 去除模板内容右侧的所有空白符号，如:</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">{{- .Name -}}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>注意：</strong>-要紧挨，同时与模板值之间需要使用空格分隔。</p></div><div class="tab-item-content" id="样例-5"><p>布尔函数会将任何类型的零值视为假，其余视为真。</p>
<p>下面是定义为函数的二元比较运算的集合：</p>
<table class="table-2 table-2-sm">
<thead class="thead-light">
<tr>
<th width="12%">
二元运算符
</th>
<th>
说明
</th>
</tr>
</thead>
<tbody>
<tr class="alert" role="alert">
<th scope="row">
eq
</th>
<td>
如果 arg1 == arg2 则返回真
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
ne
</th>
<td>
如果 arg1 != arg2 则返回真
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
lt
</th>
<td>
如果 arg1 &lt; arg2 则返回真
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
le
</th>
<td>
如果 arg1 ≤ arg2 则返回真
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
gt
</th>
<td>
如果 arg1 &gt; arg2 则返回真
</td>
</tr>
<tr class="alert" role="alert">
<th scope="row">
ge
</th>
<td>
如果 arg1 ≥ arg2 则返回真
</td>
</tr>
</tbody>
</table>
<p>使用时：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">运算符 arg1 arg2</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-6"><p>Go 模板语法中的条件判断有以下几种:</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">{{<span class="keyword">if</span> pipeline}} T1 {{end}}</span><br><span class="line">{{<span class="keyword">if</span> pipeline}} T1 {{<span class="keyword">else</span>}} T0 {{end}}</span><br><span class="line">{{<span class="keyword">if</span> pipeline}} T1 {{<span class="keyword">else</span> <span class="keyword">if</span> pipeline}} T0 {{end}}</span><br></pre></td></tr></tbody></table></figure>
<p>使用时，如：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">{{ define "default/index.html" }}</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这里是个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>通过两个花括号和点号来访问后台数据：{{.title}}<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 条件判断 --&gt;</span></span><br><span class="line">    {{$res := .score}}</span><br><span class="line">    {{if gt .score 60}}</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>{{$res}}分，及格<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    {{else}}</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>{{$res}}分，不及格<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    {{end}}</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">{{ end }}</span><br></pre></td></tr></tbody></table></figure>
<p>而 Go 文件：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Article <span class="keyword">struct</span> {</span><br><span class="line">	Title   <span class="type">string</span> <span class="comment">// 大写表示公有，小写表示私有</span></span><br><span class="line">	Content <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载模板文件（记得要加）</span></span><br><span class="line">	router.LoadHTMLGlob(<span class="string">"templates/**/*"</span>) <span class="comment">// 加载templates目录下的所有文件，**表示所有目录，*表示所有文件</span></span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		news := &amp;Article{</span><br><span class="line">			Title:   <span class="string">"新闻1"</span>,</span><br><span class="line">			Content: <span class="string">"内容1"</span>,</span><br><span class="line">		}</span><br><span class="line">		score := <span class="number">80</span></span><br><span class="line"></span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">"default/index.html"</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">			<span class="string">"title"</span>: <span class="string">"前台首页"</span>,</span><br><span class="line">			<span class="string">"news"</span>:  news,</span><br><span class="line">			<span class="string">"score"</span>: score}) <span class="comment">//第三个参数 map[string]interface{} 也可以简写为 gin.H{}</span></span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">"/admin"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">"admin/index.html"</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">			<span class="string">"title"</span>: <span class="string">"后台首页"</span>})</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-7"><p>Go 的模板语法中使用 range 关键字进行遍历，有以下两种写法，其中 pipeline 的值必须是数组、切片、字典或者通道。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">{{<span class="keyword">range</span> $key,$value := .obj}}</span><br><span class="line">		{{$value}}</span><br><span class="line">{{end}}</span><br></pre></td></tr></tbody></table></figure>
<p>如果 pipeline 的值其长度为 0，上面这种写法不会有任何输出，这时可以用下面这种写法：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">{{$key,$value := .obj}}</span><br><span class="line">		{{$value}}</span><br><span class="line">{{<span class="keyword">else</span>}}</span><br><span class="line">		pipeline 的值其长度为 <span class="number">0</span> &lt;!-- 如果 pipeline 的值其长度为 <span class="number">0</span>，则会执行该句 --&gt;</span><br><span class="line">{{end}}</span><br></pre></td></tr></tbody></table></figure>
<p>如：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">{{ define "default/index.html" }}</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这里是个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>通过两个花括号和点号来访问后台数据：{{.title}}<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- range 遍历 --&gt;</span></span><br><span class="line">    {{range .hobby}}</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>{{.}}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    {{end}}</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的爱好有：</span><br><span class="line">    {{range $index, $value := .hobby}}</span><br><span class="line">        {{$value}}、</span><br><span class="line">    {{else}}</span><br><span class="line">        没有爱好</span><br><span class="line">    {{end}}</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">{{ end }}</span><br></pre></td></tr></tbody></table></figure>
<p>Go 文件：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">c.HTML(http.StatusOK, <span class="string">"default/index.html"</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">	<span class="string">"title"</span>: <span class="string">"前台首页"</span>,</span><br><span class="line">	<span class="string">"news"</span>:  news,</span><br><span class="line">	<span class="string">"hobby"</span>: []<span class="type">string</span>{<span class="string">"吃饭"</span>, <span class="string">"睡觉"</span>, <span class="string">"打豆豆"</span>},</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-8"><p>可以通过 with 将结构体赋值给 <code>.</code> ，如结构体 news 为：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Article <span class="keyword">struct</span> {</span><br><span class="line">	Title   <span class="type">string</span> <span class="comment">// 大写表示公有，小写表示私有</span></span><br><span class="line">	Content <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载模板文件（记得要加）</span></span><br><span class="line">	router.LoadHTMLGlob(<span class="string">"templates/**/*"</span>) <span class="comment">// 加载templates目录下的所有文件，**表示所有目录，*表示所有文件</span></span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line"></span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">"default/index.html"</span>, gin.H{</span><br><span class="line">			<span class="string">"title"</span>: <span class="string">"前台首页"</span>,</span><br><span class="line">			<span class="string">"news"</span>: &amp;Article{</span><br><span class="line">				Title:   <span class="string">"新闻1"</span>,</span><br><span class="line">				Content: <span class="string">"内容1"</span>,</span><br><span class="line">			},</span><br><span class="line"></span><br><span class="line">		}) <span class="comment">//第三个参数 map[string]interface{} 也可以简写为 gin.H{}</span></span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">"/admin"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">"admin/index.html"</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">			<span class="string">"title"</span>: <span class="string">"后台首页"</span>})</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>则：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">{{ define "default/index.html" }}</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这里是个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>通过两个花括号和点号来访问后台数据：{{.title}}<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- with 解构结构体 --&gt;</span></span><br><span class="line">    {{with .news}}</span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>{{.Title}}<span class="tag">&lt;/<span class="name">h3</span>&gt;</span> <span class="comment">&lt;!-- 相当于 .news.Title --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>{{.Content}}<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- 相当于 .news.Content --&gt;</span></span><br><span class="line">    {{end}}</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">{{ end }}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-9"><p>Gin 的 html 模板文件中预定义的全局函数 / 内置函数如下：</p>
<p><strong>and</strong></p>
<p>​ 函数返回它的第一个 empty 参数或者最后一个参数；</p>
<p>​ 就是说"and x y"等价于"if x then y else x"；所有参数都会执行；</p>
<p><strong>or</strong></p>
<p>​ 返回第一个非 empty 参数或者最后一个参数；</p>
<p>​ 亦即"or x y"等价于"if x then x else y"；所有参数都会执行；</p>
<p><strong>not</strong></p>
<p>​ 返回它的单个参数的布尔值的否定</p>
<p><strong>len</strong></p>
<p>​ 返回它的参数的整数类型长度(如两个汉字，长度为6，因为一个汉字占3个字符长)</p>
<p><strong>index</strong></p>
<p>​ 执行结果为第一个参数以剩下的参数为索引/键指向的值；</p>
<p>​ 如"index x 1 2 3"返回 x[1][2][3]的值；每个被索引的主体必须是数组、切片或者字典。</p>
<p><strong>print</strong></p>
<p>​ 即 fmt.Sprint</p>
<p><strong>printf</strong></p>
<p>​ 即 fmt.Sprintf</p>
<p><strong>println</strong></p>
<p>​ 即 fmt.Sprintln</p>
<p><strong>html</strong></p>
<p>​ 返回与其参数的文本表示形式等效的转义 HTML。</p>
<p>​ 这个函数在 html/template 中不可用。</p>
<p><strong>urlquery</strong></p>
<p>​ 以适合嵌入到网址查询中的形式返回其参数的文本表示的转义值。</p>
<p>​ 这个函数在 html/template 中不可用。</p>
<p><strong>js</strong></p>
<p>​ 返回与其参数的文本表示形式等效的转义 JavaScript。</p>
<p><strong>call</strong></p>
<p>​ 执行结果是调用第一个参数的返回值，该参数必须是函数类型，其余参数作为调用该函数的参数；</p>
<p>​ 如"call .X.Y 1 2"等价于 go 语言里的 dot.X.Y(1, 2)；</p>
<p>​ 其中 Y 是函数类型的字段或者字典的值，或者其他类似情况；</p>
<p>​ call 的第一个参数的执行结果必须是函数类型的值（和预定义函数如 print 明显不同）；</p>
<p>​ 该函数类型值必须有 1 到 2 个返回值，如果有 2 个则后一个必须是 error 接口类型；</p>
<p>​ 如果有 2 个返回值的方法返回的 error 非 nil，模板执行会中断并返回给调用模板执行者该错误；</p>
<p>调用时：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">{{len .title}}</span><br><span class="line">{{index .hobby 2}}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-10"><p>假设要在 html 模板文件中调用自定义模板函数，可以先在 Go 文件中定义函数如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"html/template"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Article <span class="keyword">struct</span> {</span><br><span class="line">	Title   <span class="type">string</span> <span class="comment">// 大写表示公有，小写表示私有</span></span><br><span class="line">	Content <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnixToTime</span><span class="params">(timestamp <span class="type">int64</span>)</span></span> <span class="type">string</span> {</span><br><span class="line">	t := time.Unix(timestamp, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> t.Format(<span class="string">"2006-01-02 15:04:05"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	router := gin.Default()</span><br><span class="line">	<span class="comment">//自定义模板函数，注意要把这个函数放在加载模板前 ！！！</span></span><br><span class="line">	router.SetFuncMap(template.FuncMap{</span><br><span class="line">		<span class="string">"MyUnixToTime"</span>: UnixToTime,</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载模板文件（记得要加）</span></span><br><span class="line">	router.LoadHTMLGlob(<span class="string">"templates/**/*"</span>) <span class="comment">// 加载templates目录下的所有文件，**表示所有目录，*表示所有文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 前台首页</span></span><br><span class="line">	router.GET(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">"default/index.html"</span>, gin.H{</span><br><span class="line">			<span class="string">"title"</span>: <span class="string">"前台首页"</span>,</span><br><span class="line">			<span class="string">"news"</span>: &amp;Article{</span><br><span class="line">				Title:   <span class="string">"新闻1"</span>,</span><br><span class="line">				Content: <span class="string">"内容1"</span>,</span><br><span class="line">			},</span><br><span class="line">			<span class="string">"time"</span>: time.Now().Unix(),</span><br><span class="line">		}) <span class="comment">//第三个参数 map[string]interface{} 也可以简写为 gin.H{}</span></span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 后台首页</span></span><br><span class="line">	router.GET(<span class="string">"/admin"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">"admin/index.html"</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">			<span class="string">"title"</span>: <span class="string">"后台首页"</span>})</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后在 html 模板文件中调用如下：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">{{ define "default/index.html" }}</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这里是个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>通过两个花括号和点号来访问后台数据：{{.title}}<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 自定义模板函数,两种写法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>时间：{{MyUnixToTime .time}}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>时间：{{.time | MyUnixToTime}}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">{{ end }}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h3 id="嵌套-template">5.2.嵌套 template</h3>
<p>假设要在多个 html 模板文件中都引入相同样式的头部，且要求头部根据 html 模板文件的不同变换不同的标题。这时我们可以使用嵌套 template，即先新建头部 html 模板文件如下：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">{{ define "public/page_header.html" }}</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">h1</span>{</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="number">#000</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">    }</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">    我是公共头部--{{.title}}</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">{{ end }}</span><br></pre></td></tr></tbody></table></figure>
<p>然后在不同的 html 模板文件中嵌套该文件（嵌套时注意最后的 <code>.</code>）：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">{{ define "default/index.html" }}</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    {{ template "public/page_header.html" .}} <span class="comment">&lt;!-- .表示抓取本页面中后台传入的数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这里是个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>通过两个花括号和点号来访问后台数据：{{.title}}<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 自定义模板函数,两种写法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>时间：{{MyUnixToTime .time}}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>时间：{{.time | MyUnixToTime}}<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">{{ end }}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="静态文件服务">6.静态文件服务</h2>
<p>当我们渲染的 HTML 文件中引用了静态文件（如 css、js 文件），且我们希望在网页端也能访问到这些静态文件时，我们需要配置静态 web 服务。</p>
<p>新建静态文件 <code>templates/static/mycss.css</code> 如下：</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>{</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">    <span class="attribute">color</span>: greenyellow;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在 html 模板文件中引用该 css 文件（<strong>注意，外部 css 样式文件效果在 postman 软件中无法预览，需要在浏览器中查看！</strong>）：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">{{ define "default/index.html" }}</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/static/mycss.css"</span>&gt;</span> <span class="comment">&lt;!--外部样式的优先级高于 body 中的嵌套 template 模板样式--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    {{ template "public/page_header.html" .}} <span class="comment">&lt;!-- .表示抓取本页面中后台传入的数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这里是个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>通过两个花括号和点号来访问后台数据：{{.title}}<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">{{ end }}</span><br></pre></td></tr></tbody></table></figure>
<p>最后在 Go 文件中配置静态文件服务：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"html/template"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Article <span class="keyword">struct</span> {</span><br><span class="line">	Title   <span class="type">string</span> <span class="comment">// 大写表示公有，小写表示私有</span></span><br><span class="line">	Content <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnixToTime</span><span class="params">(timestamp <span class="type">int64</span>)</span></span> <span class="type">string</span> {</span><br><span class="line">	t := time.Unix(timestamp, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> t.Format(<span class="string">"2006-01-02 15:04:05"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	router := gin.Default()</span><br><span class="line">	<span class="comment">//自定义模板函数，注意要把这个函数放在加载模板前 ！！！</span></span><br><span class="line">	router.SetFuncMap(template.FuncMap{</span><br><span class="line">		<span class="string">"MyUnixToTime"</span>: UnixToTime,</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载模板文件</span></span><br><span class="line">	router.LoadHTMLGlob(<span class="string">"templates/**/*"</span>) <span class="comment">// 加载templates目录下的所有文件，**表示所有目录，*表示所有文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载静态文件</span></span><br><span class="line">	router.Static(<span class="string">"/static"</span>, <span class="string">"./templates/static"</span>) <span class="comment">//第一个参数为网页路由，第二个参数为文件路径，这时可通过 localhost:8080/static/mycss.css 访问到文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 前台首页</span></span><br><span class="line">	router.GET(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">"default/index.html"</span>, gin.H{</span><br><span class="line">			<span class="string">"title"</span>: <span class="string">"前台首页"</span>,</span><br><span class="line">			<span class="string">"news"</span>: &amp;Article{</span><br><span class="line">				Title:   <span class="string">"新闻1"</span>,</span><br><span class="line">				Content: <span class="string">"内容1"</span>,</span><br><span class="line">			},</span><br><span class="line">			<span class="string">"time"</span>: time.Now().Unix(),</span><br><span class="line">		}) <span class="comment">//第三个参数 map[string]interface{} 也可以简写为 gin.H{}</span></span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 后台首页</span></span><br><span class="line">	router.GET(<span class="string">"/admin"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">"admin/index.html"</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">			<span class="string">"title"</span>: <span class="string">"后台首页"</span>})</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在浏览器中预览效果，且可通过 <code>localhost:8080/static/mycss.css</code> 路径访问静态文件。</p>
<h2 id="路由详解">7.路由详解</h2>
<p>路由（Routing）是由一个 URI（或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成的，涉及到应用如何响应客户端对某个网站节点的访问。</p>
<p>路由知识在前面 <a href="#anchor1">3.Gin框架中的路由</a> 提到，下面是关于路由传值、路由返回值的更深入说明。</p>
<h3 id="get-post-以及获取-get-post-传值">7.1.GET POST 以及获取 GET POST 传值</h3>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">Get 请求传值</button><button type="button" class="tab " data-href="样例-2">动态路由传值</button><button type="button" class="tab " data-href="样例-3">POST 请求传值</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><p>从访问的路由（“?”后，以“&amp;”间隔）中获取参数值，主要使用的函数有：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">c.Query(<span class="string">"参数名"</span>)</span><br><span class="line">c.DefaultQuery(<span class="string">"参数名"</span>, <span class="string">"默认值"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>如：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"html/template"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Article <span class="keyword">struct</span> {</span><br><span class="line">	Title   <span class="type">string</span> <span class="comment">// 大写表示公有，小写表示私有</span></span><br><span class="line">	Content <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnixToTime</span><span class="params">(timestamp <span class="type">int64</span>)</span></span> <span class="type">string</span> {</span><br><span class="line">	t := time.Unix(timestamp, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> t.Format(<span class="string">"2006-01-02 15:04:05"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	router := gin.Default()</span><br><span class="line">	<span class="comment">//自定义模板函数，注意要把这个函数放在加载模板前 ！！！</span></span><br><span class="line">	router.SetFuncMap(template.FuncMap{</span><br><span class="line">		<span class="string">"MyUnixToTime"</span>: UnixToTime,</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载模板文件</span></span><br><span class="line">	router.LoadHTMLGlob(<span class="string">"templates/**/*"</span>) <span class="comment">// 加载templates目录下的所有文件，**表示所有目录，*表示所有文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载静态文件</span></span><br><span class="line">	router.Static(<span class="string">"/static"</span>, <span class="string">"./templates/static"</span>) <span class="comment">//第一个参数为网页路由，第二个参数为文件路径，这时可通过 localhost:8080/static/mycss.css 访问到文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 前台首页</span></span><br><span class="line">	router.GET(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		name := c.Query(<span class="string">"username"</span>) <span class="comment">//获取get请求参数</span></span><br><span class="line">		age := c.Query(<span class="string">"age"</span>)</span><br><span class="line">		sex := c.Query(<span class="string">"sex"</span>)</span><br><span class="line">		page := c.DefaultQuery(<span class="string">"page"</span>, <span class="string">"1"</span>) <span class="comment">//获取get请求参数，如果参数不存在，则返回默认值 1</span></span><br><span class="line">		c.JSON(http.StatusOK, gin.H{</span><br><span class="line">			<span class="string">"name"</span>: name,</span><br><span class="line">			<span class="string">"age"</span>:  age,</span><br><span class="line">			<span class="string">"sex"</span>:  sex,</span><br><span class="line">			<span class="string">"page"</span>: page,</span><br><span class="line">		})</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 后台首页</span></span><br><span class="line">	router.GET(<span class="string">"/admin"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">"admin/index.html"</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">			<span class="string">"title"</span>: <span class="string">"后台首页"</span>})</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>此时访问 <code>localhost:8080/home?username=ppdop&amp;age=18&amp;sex=guess&amp;page=2</code>，将得到以下页面：</p>
<p><img src="/img/load1.gif" data-original="https://cdn.jsdelivr.net/gh/hahahaha5606/blogImage/images/image-20250529142626046.png" alt="image-20250529142626046" style="zoom:67%;"></p></div><div class="tab-item-content" id="样例-2"><p>动态路由传值，主要使用的函数为 <code>c.Param()</code>。如：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"html/template"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Article <span class="keyword">struct</span> {</span><br><span class="line">	Title   <span class="type">string</span> <span class="comment">// 大写表示公有，小写表示私有</span></span><br><span class="line">	Content <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnixToTime</span><span class="params">(timestamp <span class="type">int64</span>)</span></span> <span class="type">string</span> {</span><br><span class="line">	t := time.Unix(timestamp, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> t.Format(<span class="string">"2006-01-02 15:04:05"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	router := gin.Default()</span><br><span class="line">	<span class="comment">//自定义模板函数，注意要把这个函数放在加载模板前 ！！！</span></span><br><span class="line">	router.SetFuncMap(template.FuncMap{</span><br><span class="line">		<span class="string">"MyUnixToTime"</span>: UnixToTime,</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载模板文件</span></span><br><span class="line">	router.LoadHTMLGlob(<span class="string">"templates/**/*"</span>) <span class="comment">// 加载templates目录下的所有文件，**表示所有目录，*表示所有文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载静态文件</span></span><br><span class="line">	router.Static(<span class="string">"/static"</span>, <span class="string">"./templates/static"</span>) <span class="comment">//第一个参数为网页路由，第二个参数为文件路径，这时可通过 localhost:8080/static/mycss.css 访问到文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 前台首页</span></span><br><span class="line">	router.GET(<span class="string">"/home/:id"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> { <span class="comment">//这里要相应配置</span></span><br><span class="line">		id := c.Param(<span class="string">"id"</span>)</span><br><span class="line">		c.String(http.StatusOK, <span class="string">"id: %s"</span>, id)</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 后台首页</span></span><br><span class="line">	router.GET(<span class="string">"/admin"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">"admin/index.html"</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{</span><br><span class="line">			<span class="string">"title"</span>: <span class="string">"后台首页"</span>})</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>则访问地址为 <code>localhost:8080/home/12</code> 时将得到输出字符串 <code>id: 12</code> 。</p></div><div class="tab-item-content" id="样例-3"><p>假设表单如下:</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">{{ define "default/index.html" }}</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/doAddUser"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">        用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">        密码: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">{{end}}</span><br></pre></td></tr></tbody></table></figure>
<p>则处理表单POST的数据的操作为：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 前台首页</span></span><br><span class="line">router.GET(<span class="string">"/home/addUser"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">	c.HTML(http.StatusOK, <span class="string">"default/index.html"</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{})</span><br><span class="line">})</span><br><span class="line">router.POST(<span class="string">"/doAddUser"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> { <span class="comment">// 处理表单提交</span></span><br><span class="line">	username := c.PostForm(<span class="string">"username"</span>)</span><br><span class="line">	password := c.PostForm(<span class="string">"password"</span>)</span><br><span class="line">	age := c.DefaultPostForm(<span class="string">"age"</span>, <span class="string">"20"</span>)</span><br><span class="line">	c.JSON(http.StatusOK, gin.H{</span><br><span class="line">		<span class="string">"username"</span>: username,</span><br><span class="line">		<span class="string">"password"</span>: password,</span><br><span class="line">		<span class="string">"age"</span>:      age,</span><br><span class="line">	})</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
<p>在浏览器进行测试，访问 <code>http://localhost:8080/home/addUser</code> 并输入用户名、密码，点击提交按钮将自动跳转页面 <code>http://localhost:8080/doAddUser</code> 并显示用户名、密码和年龄的 JSON 字符串。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h3 id="获取-get-post-传递的数据绑定到结构体">7.2.获取 GET POST 传递的数据绑定到结构体</h3>
<p>为了能够更方便的获取请求相关参数，提高开发效率，我们可以基于请求的 Content-Type 识别请求数据类型并利用反射机制自动提取请求中 QueryString、form 表单、JSON、XML 等参数到结构体中。 .ShouldBind() 能够基于请求自动提取 JSON、form 表单和 QueryString 类型的数据，并把值绑定到指定的结构体对象。</p>
<p>结构体：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 注意首字母大写</span></span><br><span class="line"><span class="keyword">type</span> Userinfo <span class="keyword">struct</span> {</span><br><span class="line">	Username <span class="type">string</span> <span class="string">`form:"username" json:"user"`</span></span><br><span class="line">	Password <span class="type">string</span> <span class="string">`form:"password" json:"password"`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">Get 传值绑定到结构体</button><button type="button" class="tab " data-href="样例-2">Post 传值绑定到结构体</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><p>/?username=zhangsan&amp;password=123456</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">router.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">	<span class="keyword">var</span> userinfo Userinfo <span class="comment">// 或 user := &amp;UserInfo{}</span></span><br><span class="line">	<span class="keyword">if</span> err := c.ShouldBind(&amp;userinfo); err == <span class="literal">nil</span> {</span><br><span class="line">		c.JSON(http.StatusOK, userinfo)</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		c.JSON(http.StatusBadRequest, gin.H{<span class="string">"error"</span>: err.Error()})</span><br><span class="line">	}</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
<p>返回数据 {"user":"zhangsan","password":"123456"}</p></div><div class="tab-item-content" id="样例-2"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">router.POST(<span class="string">"/doLogin"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">   <span class="keyword">var</span> userinfo Userinfo <span class="comment">// 或 user := &amp;UserInfo{}</span></span><br><span class="line">   </span><br><span class="line">	<span class="keyword">if</span> err := c.ShouldBind(&amp;userinfo); err == <span class="literal">nil</span> {</span><br><span class="line">		c.JSON(http.StatusOK, userinfo)</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		c.JSON(http.StatusBadRequest, gin.H{<span class="string">"error"</span>: err.Error()})</span><br><span class="line">	}</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
<p>返回数据 {"user":"zhangsan","password":"123456"}</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h3 id="获取-post-xml-数据">7.3.获取 POST XML 数据</h3>
<p>在 API 的开发中，我们经常会用到 JSON 或 XML 来作为数据交互的格式（如支付时），这个时候我们可以在 gin 中使用 c.GetRawData() 获取数据。</p>
<p>首先配置路由：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//结构体为</span></span><br><span class="line"><span class="keyword">type</span> Article <span class="keyword">struct</span> {</span><br><span class="line">	Title   <span class="type">string</span> <span class="string">`json:"title" xml:"title"`</span></span><br><span class="line">	Content <span class="type">string</span> <span class="string">`json:"content" xml:"content"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取 POST 请求的 XML 数据</span></span><br><span class="line">	router.POST(<span class="string">"/xml"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		article := &amp;Article{}</span><br><span class="line">		xmlSliceData, _ := c.GetRawData() <span class="comment">//从 c.Request.Body 读取请求数据, xmlSliceData 为 []byte 类型</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := xml.Unmarshal(xmlSliceData, article); err == <span class="literal">nil</span> {</span><br><span class="line">			c.JSON(http.StatusOK, article)</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			c.JSON(http.StatusBadRequest, gin.H{<span class="string">"error"</span>: err.Error()})</span><br><span class="line">		}</span><br><span class="line">	})</span><br></pre></td></tr></tbody></table></figure>
<p>然后打开 PostMan 按图中步骤进行模拟：</p>
<figure>
<img src="/img/load4.gif" data-original="https://cdn.jsdelivr.net/gh/hahahaha5606/blogImage/images/image-20250529162024466.png" alt="image-20250529162024466"><figcaption aria-hidden="true">image-20250529162024466</figcaption>
</figure>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">content</span> <span class="attr">type</span>=<span class="string">"string"</span>&gt;</span>我是张三<span class="tag">&lt;/<span class="name">content</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span> <span class="attr">type</span>=<span class="string">"string"</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="路由组">8.路由组</h2>
<p>当项目较大时，我们可以对数量庞大的路由进行分组处理。</p>
<p>官方文档：https://gin-gonic.com/zh-cn/docs/examples/grouping-routes/</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">路由分组前</button><button type="button" class="tab " data-href="样例-2">路由分组后</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载模板文件</span></span><br><span class="line">	router.LoadHTMLGlob(<span class="string">"templates/**/*"</span>) <span class="comment">// 加载templates目录下的所有文件，**表示所有目录，*表示所有文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载静态文件</span></span><br><span class="line">	router.Static(<span class="string">"/static"</span>, <span class="string">"./templates/static"</span>) <span class="comment">//第一个参数为网页路由，第二个参数为文件路径</span></span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"首页"</span>)</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">"/news"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"新闻"</span>)</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">"/api/v1"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"api/v1 接口"</span>)</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">"/api/v2"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"api/v2 接口"</span>)</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">"/api/v3"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"api/v3 接口"</span>)</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">"/admin"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"管理员页面"</span>)</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">"/admin/login"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"管理员登录页面"</span>)</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载模板文件</span></span><br><span class="line">	router.LoadHTMLGlob(<span class="string">"templates/**/*"</span>) <span class="comment">// 加载templates目录下的所有文件，**表示所有目录，*表示所有文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载静态文件</span></span><br><span class="line">	router.Static(<span class="string">"/static"</span>, <span class="string">"./templates/static"</span>) <span class="comment">//第一个参数为网页路由，第二个参数为文件路径</span></span><br><span class="line"></span><br><span class="line">	defaultRouters := router.Group(<span class="string">"/"</span>)</span><br><span class="line">	{</span><br><span class="line">		defaultRouters.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">			c.String(<span class="number">200</span>, <span class="string">"首页"</span>)</span><br><span class="line">		})</span><br><span class="line"></span><br><span class="line">		defaultRouters.GET(<span class="string">"/news"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">			c.String(<span class="number">200</span>, <span class="string">"新闻"</span>)</span><br><span class="line">		})</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	apiRouters := router.Group(<span class="string">"/api"</span>)</span><br><span class="line">	{</span><br><span class="line">		apiRouters.GET(<span class="string">"/v1"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">			c.String(<span class="number">200</span>, <span class="string">"api/v1 接口"</span>)</span><br><span class="line">		})</span><br><span class="line"></span><br><span class="line">		apiRouters.GET(<span class="string">"/v2"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">			c.String(<span class="number">200</span>, <span class="string">"api/v2 接口"</span>)</span><br><span class="line">		})</span><br><span class="line"></span><br><span class="line">		apiRouters.GET(<span class="string">"/v3"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">			c.String(<span class="number">200</span>, <span class="string">"api/v3 接口"</span>)</span><br><span class="line">		})</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	adminRouters := router.Group(<span class="string">"/admin"</span>)</span><br><span class="line">	{</span><br><span class="line">		adminRouters.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">			c.String(<span class="number">200</span>, <span class="string">"管理员页面"</span>)</span><br><span class="line">		})</span><br><span class="line"></span><br><span class="line">		adminRouters.GET(<span class="string">"/login"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">			c.String(<span class="number">200</span>, <span class="string">"管理员登录页面"</span>)</span><br><span class="line">		})</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p>我们还可以换一种写法，将路由的各个组写到自定义包里。</p>
<p>首先新建文件夹 <code>routers</code>，并在包下新建 <code>adminRouters.go</code>，<code>apiRouters.go</code> 和 <code>defaultRouters.go</code> 三个文件，然后修改 <code>main.go</code> 文件。如下：</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">adminRouters.go</button><button type="button" class="tab " data-href="样例-2">apiRouters.go</button><button type="button" class="tab " data-href="样例-3">defaultRouters.go</button><button type="button" class="tab " data-href="样例-4">main.go</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AdminRoutersInit</span><span class="params">(r *gin.Engine)</span></span> {</span><br><span class="line">	adminRouters := r.Group(<span class="string">"/admin"</span>)</span><br><span class="line">	{</span><br><span class="line">		adminRouters.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">			c.String(<span class="number">200</span>, <span class="string">"管理员页面"</span>)</span><br><span class="line">		})</span><br><span class="line"></span><br><span class="line">		adminRouters.GET(<span class="string">"/login"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">			c.String(<span class="number">200</span>, <span class="string">"管理员登录页面"</span>)</span><br><span class="line">		})</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ApiRoutersInit</span><span class="params">(r *gin.Engine)</span></span> {</span><br><span class="line">	apiRouters := r.Group(<span class="string">"/api"</span>)</span><br><span class="line">	{</span><br><span class="line">		apiRouters.GET(<span class="string">"/v1"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">			c.String(<span class="number">200</span>, <span class="string">"api/v1 接口"</span>)</span><br><span class="line">		})</span><br><span class="line"></span><br><span class="line">		apiRouters.GET(<span class="string">"/v2"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">			c.String(<span class="number">200</span>, <span class="string">"api/v2 接口"</span>)</span><br><span class="line">		})</span><br><span class="line"></span><br><span class="line">		apiRouters.GET(<span class="string">"/v3"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">			c.String(<span class="number">200</span>, <span class="string">"api/v3 接口"</span>)</span><br><span class="line">		})</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-3"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DefaultRoutersInit</span><span class="params">(r *gin.Engine)</span></span> {</span><br><span class="line">	defaultRouters := r.Group(<span class="string">"/"</span>)</span><br><span class="line">	{</span><br><span class="line">		defaultRouters.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">			c.String(<span class="number">200</span>, <span class="string">"首页"</span>)</span><br><span class="line">		})</span><br><span class="line"></span><br><span class="line">		defaultRouters.GET(<span class="string">"/news"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">			c.String(<span class="number">200</span>, <span class="string">"新闻"</span>)</span><br><span class="line">		})</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-4"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"test/routers"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载模板文件</span></span><br><span class="line">	router.LoadHTMLGlob(<span class="string">"templates/**/*"</span>) <span class="comment">// 加载templates目录下的所有文件，**表示所有目录，*表示所有文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载静态文件</span></span><br><span class="line">	router.Static(<span class="string">"/static"</span>, <span class="string">"./templates/static"</span>) <span class="comment">//第一个参数为网页路由，第二个参数为文件路径</span></span><br><span class="line"></span><br><span class="line">	routers.DefaultRoutersInit(router)</span><br><span class="line">	routers.ApiRoutersInit(router)</span><br><span class="line">	routers.AdminRoutersInit(router)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h2 id="gin-中自定义控制器">9.Gin 中自定义控制器</h2>
<p>路由主要实现访问路径，具体的业务逻辑往往放在控制器中。</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">控制器分组</button><button type="button" class="tab " data-href="样例-2">控制器的继承</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><p>当项目较大时，我们有必要对控制器进行分组。</p>
<p>控制器分组的实现逻辑和路由分组一样，如分组前 <code>routers/adminRouters.go</code>：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"test/controllers/admin"</span></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AdminRoutersInit</span><span class="params">(r *gin.Engine)</span></span> {</span><br><span class="line">	adminRouters := r.Group(<span class="string">"/admin"</span>)</span><br><span class="line">	{</span><br><span class="line">		adminRouters.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">			c.String(<span class="number">200</span>, <span class="string">"管理员页面"</span>)</span><br><span class="line">		})</span><br><span class="line">		adminRouters.GET(<span class="string">"/login"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">			c.String(<span class="number">200</span>, <span class="string">"管理员登录页面"</span>)</span><br><span class="line">		})</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>分组时，新建 <code>controllers/admin/userController.go</code> 来实现业务逻辑：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> admin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AdminFunc</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">	c.String(<span class="number">200</span>, <span class="string">"管理员页面"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AdminLogin</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">	c.String(<span class="number">200</span>, <span class="string">"管理员登录页面"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>分组后，文件 <code>routers/adminRouters.go</code> 可以修改为：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"test/controllers/admin"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AdminRoutersInit</span><span class="params">(r *gin.Engine)</span></span> {</span><br><span class="line">	adminRouters := r.Group(<span class="string">"/admin"</span>)</span><br><span class="line">	{</span><br><span class="line">		adminRouters.GET(<span class="string">"/"</span>, admin.AdminFunc) <span class="comment">//这里不用加括号（只注册方法），加括号表示执行方法</span></span><br><span class="line">		adminRouters.GET(<span class="string">"/login"</span>, admin.AdminLogin)</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><p>如果想要实现控制器的继承，可以进一步把控制器定义为结构体，将业务逻辑定义为结构体方法。</p>
<p>假设 <code>controllers/admin/userController.go</code> 要继承 <code>baseController</code>，新建文件 <code>controllers/admin/baseController.go</code> 如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> admin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> baseController <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con baseController)</span></span> success(c *gin.Context) {</span><br><span class="line">	c.String(<span class="number">200</span>, <span class="string">"成功"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con baseController)</span></span> <span class="type">error</span>(c *gin.Context) {</span><br><span class="line">	c.String(<span class="number">200</span>, <span class="string">"失败"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后修改 <code>controllers/admin/userController.go</code> :</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> admin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserController <span class="keyword">struct</span> {</span><br><span class="line">	baseController <span class="comment">//继承</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con UserController)</span></span> AdminFunc(c *gin.Context) { <span class="comment">//改成结构体 UserController 的方法，便于实现继承</span></span><br><span class="line">	c.String(<span class="number">200</span>, <span class="string">"管理员页面"</span>)</span><br><span class="line">	con.success(c) <span class="comment">//使用继承的方法</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con UserController)</span></span> AdminLogin(c *gin.Context) { <span class="comment">//改成结构体 UserController 的方法，便于实现继承</span></span><br><span class="line">	c.String(<span class="number">200</span>, <span class="string">"管理员登录页面"</span>)</span><br><span class="line">	con.success(c) <span class="comment">//使用继承的方法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>最后分组后的文件 <code>routers/adminRouters.go</code> 为：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"test/controllers/admin"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AdminRoutersInit</span><span class="params">(r *gin.Engine)</span></span> {</span><br><span class="line">	adminRouters := r.Group(<span class="string">"/admin"</span>)</span><br><span class="line">	{</span><br><span class="line">		adminRouters.GET(<span class="string">"/"</span>, admin.UserController{}.AdminFunc) <span class="comment">//这里不用加括号（只注册方法），加括号表示执行方法</span></span><br><span class="line">		adminRouters.GET(<span class="string">"/login"</span>, admin.UserController{}.AdminLogin)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>主文件<code>main.go</code> 不变：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"test/routers"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载模板文件</span></span><br><span class="line">	router.LoadHTMLGlob(<span class="string">"templates/**/*"</span>) <span class="comment">// 加载templates目录下的所有文件，**表示所有目录，*表示所有文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载静态文件</span></span><br><span class="line">	router.Static(<span class="string">"/static"</span>, <span class="string">"./templates/static"</span>) <span class="comment">//第一个参数为网页路由，第二个参数为文件路径</span></span><br><span class="line"></span><br><span class="line">	routers.AdminRoutersInit(router)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h2 id="gin-中间件">10.Gin 中间件</h2>
<p>Gin 框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫<strong>中间件</strong>，中间件适合处理一些公共的业务逻辑，比如登录认证、权限校验、数据分页、记录日志、耗时统计等。</p>
<p><strong>通俗的讲</strong>：<strong>中间件</strong>就是匹配路由前和匹配路由完成后执行的一系列操作。</p>
<blockquote>
<p><strong>GET 路由函数定义</strong></p>
<p></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// GET is a shortcut for router.Handle("GET", path, handlers).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> GET(relativePath <span class="type">string</span>, handlers ...HandlerFunc) IRoutes {</span><br><span class="line">	<span class="keyword">return</span> group.handle(http.MethodGet, relativePath, handlers)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>GET 函数的第一个参数后可以是不止一个函数。Gin 中的中间件必须是一个 gin.HandlerFunc 类型，配置路由的时候可以传递多个 func 回调函数，最后一个 func 回调函数前面触发的方法都可以称为中间件。</p>
</blockquote>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">router.GET(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"Hello"</span>)</span><br><span class="line">}, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">	c.String(<span class="number">200</span>, <span class="string">"主页"</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
<p>上面代码中的 <code>func(c *gin.Context) {fmt.Println("Hello")}</code> 就可以视为中间件。</p>
<p>直接将中间件写在 GET 函数中较为繁琐，我们可以将其化为 “路由中间件” 写法：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"test/routers"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMiddleware</span><span class="params">(c *gin.Context)</span></span> { <span class="comment">//中间件函数</span></span><br><span class="line">	fmt.Println(<span class="string">"Hello"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载模板文件</span></span><br><span class="line">	router.LoadHTMLGlob(<span class="string">"templates/**/*"</span>) <span class="comment">// 加载templates目录下的所有文件，**表示所有目录，*表示所有文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载静态文件</span></span><br><span class="line">	router.Static(<span class="string">"/static"</span>, <span class="string">"./templates/static"</span>) <span class="comment">//第一个参数为网页路由，第二个参数为文件路径</span></span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">"/home"</span>, initMiddleware, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> { <span class="comment">//路由中间件</span></span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"主页"</span>)</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="c.next-调用该请求的剩余处理程序">10.1. c.Next() 调用该请求的剩余处理程序</h3>
<p>中间件里面加上 c.Next() 可以让我们在路由匹配完成后执行一些操作，如统计一个请求的执行时间等。</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">用法</button><button type="button" class="tab " data-href="样例-2">统计时间</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"test/routers"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMiddleware</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"Hello"</span>)</span><br><span class="line"></span><br><span class="line">	c.Next() <span class="comment">// 调用该请求的剩余处理程序</span></span><br><span class="line">	fmt.Println(<span class="string">"How are you"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载模板文件</span></span><br><span class="line">	router.LoadHTMLGlob(<span class="string">"templates/**/*"</span>) <span class="comment">// 加载templates目录下的所有文件，**表示所有目录，*表示所有文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载静态文件</span></span><br><span class="line">	router.Static(<span class="string">"/static"</span>, <span class="string">"./templates/static"</span>) <span class="comment">//第一个参数为网页路由，第二个参数为文件路径</span></span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">"/home"</span>, initMiddleware, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		fmt.Println(<span class="string">"home"</span>)</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"主页"</span>)</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>访问时，终端输出顺序：Hello &gt; home &gt; How are you。也就是 c.Next() 后的语句是最后执行的。</p></div><div class="tab-item-content" id="样例-2"><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"test/routers"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMiddleware</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"Hello"</span>)</span><br><span class="line">	start := time.Now().UnixNano()</span><br><span class="line"></span><br><span class="line">	c.Next() <span class="comment">// 调用该请求的剩余处理程序</span></span><br><span class="line">	fmt.Println(<span class="string">"How are you"</span>)</span><br><span class="line">	end := time.Now().UnixNano()</span><br><span class="line">	fmt.Println(end - start)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载模板文件</span></span><br><span class="line">	router.LoadHTMLGlob(<span class="string">"templates/**/*"</span>) <span class="comment">// 加载templates目录下的所有文件，**表示所有目录，*表示所有文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载静态文件</span></span><br><span class="line">	router.Static(<span class="string">"/static"</span>, <span class="string">"./templates/static"</span>) <span class="comment">//第一个参数为网页路由，第二个参数为文件路径</span></span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">"/home"</span>, initMiddleware, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		fmt.Println(<span class="string">"home"</span>)</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"主页"</span>)</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p>我们可以设置多个中间件，此时 c.Next() 的执行顺序为 “先进后出，逆序执行” ：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"test/routers"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMiddleware1</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"Hello1"</span>)</span><br><span class="line"></span><br><span class="line">	c.Next() <span class="comment">// 调用该请求的剩余处理程序</span></span><br><span class="line">	fmt.Println(<span class="string">"How are you1"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMiddleware2</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"Hello2"</span>)</span><br><span class="line"></span><br><span class="line">	c.Next() <span class="comment">// 调用该请求的剩余处理程序</span></span><br><span class="line">	fmt.Println(<span class="string">"How are you2"</span>)</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载模板文件</span></span><br><span class="line">	router.LoadHTMLGlob(<span class="string">"templates/**/*"</span>) <span class="comment">// 加载templates目录下的所有文件，**表示所有目录，*表示所有文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载静态文件</span></span><br><span class="line">	router.Static(<span class="string">"/static"</span>, <span class="string">"./templates/static"</span>) <span class="comment">//第一个参数为网页路由，第二个参数为文件路径</span></span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">"/home"</span>, initMiddleware1, initMiddleware2, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		fmt.Println(<span class="string">"home"</span>)</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"主页"</span>)</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>访问 <code>localhost:8080/home</code> 时，终端输出依次为：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">9</span>:<span class="number">29</span>:<span class="number">05</span> app         | Hello1</span><br><span class="line"><span class="number">9</span>:<span class="number">29</span>:<span class="number">05</span> app         | Hello2</span><br><span class="line">home</span><br><span class="line">How are you2</span><br><span class="line">How are you1</span><br></pre></td></tr></tbody></table></figure>
<h3 id="c.abort-了解">10.2. c.Abort() （了解）</h3>
<p>Abort 是终止的意思， c.Abort() 表示终止调用该请求的剩余处理程序，即直接返回调用该中间件 c.Abort() 后的程序后即终止 GET 请求。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"test/routers"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMiddleware1</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"Hello1"</span>)</span><br><span class="line"></span><br><span class="line">	c.Abort() <span class="comment">// 终止调用该请求的剩余处理程序</span></span><br><span class="line">	fmt.Println(<span class="string">"How are you1"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMiddleware2</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"Hello2"</span>)</span><br><span class="line"></span><br><span class="line">	c.Abort() <span class="comment">// 终止调用该请求的剩余处理程序</span></span><br><span class="line">	fmt.Println(<span class="string">"How are you2"</span>)</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载模板文件</span></span><br><span class="line">	router.LoadHTMLGlob(<span class="string">"templates/**/*"</span>) <span class="comment">// 加载templates目录下的所有文件，**表示所有目录，*表示所有文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载静态文件</span></span><br><span class="line">	router.Static(<span class="string">"/static"</span>, <span class="string">"./templates/static"</span>) <span class="comment">//第一个参数为网页路由，第二个参数为文件路径</span></span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">"/home"</span>, initMiddleware1, initMiddleware2, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		fmt.Println(<span class="string">"home"</span>)</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"主页"</span>)</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>访问 <code>localhost:8080/home</code> 时，终端输出为：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">9</span>:<span class="number">35</span>:<span class="number">01</span> app         | Hello1</span><br><span class="line"><span class="number">9</span>:<span class="number">35</span>:<span class="number">01</span> app         | How are you1</span><br></pre></td></tr></tbody></table></figure>
<p>且访问的 <code>localhost:8080/home</code> 也不会显示 “主页”，而是空白页面。</p>
<h3 id="全局中间件">10.3.全局中间件</h3>
<p>除了对每个路由中都分别配置其中间件，还可以一次性配置所有路由的中间件。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"test/routers"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMiddleware</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"我是全局中间件"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载模板文件</span></span><br><span class="line">	router.LoadHTMLGlob(<span class="string">"templates/**/*"</span>) <span class="comment">// 加载templates目录下的所有文件，**表示所有目录，*表示所有文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载静态文件</span></span><br><span class="line">	router.Static(<span class="string">"/static"</span>, <span class="string">"./templates/static"</span>) <span class="comment">//第一个参数为网页路由，第二个参数为文件路径</span></span><br><span class="line"></span><br><span class="line">	router.Use(initMiddleware) <span class="comment">//配置全局中间件</span></span><br><span class="line">	router.GET(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		fmt.Println(<span class="string">"home"</span>)</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"主页"</span>)</span><br><span class="line">	})</span><br><span class="line">	router.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		fmt.Println(<span class="string">"here"</span>)</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"这是默认页"</span>)</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="为路由组配置中间件">10.4.为路由组配置中间件</h3>
<p>除了在 GET 路由函数中添加中间件和全局中间件外，为路由组注册中间件有以下几种写法：</p>
<blockquote>
<p>为使项目结构更加清晰明了，新建 <code>middlewares</code> 文件夹用来存放中间件。</p>
<p>路由组的中间件可以写在 <code>middlewares/init.go</code> 中：</p>
<p></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> middlewares</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitMiddleware</span><span class="params">(c *gin.Context)</span></span> { <span class="comment">//函数名首字母记得大写</span></span><br><span class="line">	fmt.Println(<span class="string">"我是初始中间件"</span>)</span><br><span class="line">	fmt.Println(c.Request.URL)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
</blockquote>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">写法1</button><button type="button" class="tab " data-href="样例-2">写法2</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><p>文件 <code>routers/adminRouters.go</code> ：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"test/controllers/admin"</span></span><br><span class="line">	<span class="string">"test/middlewares"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AdminRoutersInit</span><span class="params">(r *gin.Engine)</span></span> {</span><br><span class="line">	adminRouters := r.Group(<span class="string">"/admin"</span>, middlewares.InitMiddleware) <span class="comment">//写法1</span></span><br><span class="line">  </span><br><span class="line">	{</span><br><span class="line">		adminRouters.GET(<span class="string">"/"</span>, admin.UserController{}.AdminFunc) <span class="comment">//这里不用加括号（只注册方法），加括号表示执行方法</span></span><br><span class="line">		adminRouters.GET(<span class="string">"/login"</span>, admin.UserController{}.AdminLogin)</span><br><span class="line"></span><br><span class="line">		adminRouters.GET(<span class="string">"/user"</span>, admin.UserController{}.Index)</span><br><span class="line">		adminRouters.GET(<span class="string">"/user/add"</span>, admin.UserController{}.Add)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>主函数 <code>main.go</code>：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"test/routers"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMiddleware</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"我是全局中间件"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载模板文件</span></span><br><span class="line">	router.LoadHTMLGlob(<span class="string">"templates/**/*"</span>) <span class="comment">// 加载templates目录下的所有文件，**表示所有目录，*表示所有文件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载静态文件</span></span><br><span class="line">	router.Static(<span class="string">"/static"</span>, <span class="string">"./templates/static"</span>) <span class="comment">//第一个参数为网页路由，第二个参数为文件路径</span></span><br><span class="line"></span><br><span class="line">	router.Use(initMiddleware)</span><br><span class="line">	router.GET(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		fmt.Println(<span class="string">"home"</span>)</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"主页"</span>)</span><br><span class="line">	})</span><br><span class="line">	router.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		fmt.Println(<span class="string">"here"</span>)</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"这是默认页"</span>)</span><br><span class="line">	}</span><br><span class="line">	routers.AdminRoutersInit(router)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>执行时，终端输出顺序：我是全局中间件 &gt; 我是初始中间件。</p></div><div class="tab-item-content" id="样例-2"><p>在文件 <code>routers/adminRouters.go</code> 中：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AdminRoutersInit</span><span class="params">(r *gin.Engine)</span></span> {</span><br><span class="line">	adminRouters := r.Group(<span class="string">"/admin"</span>)</span><br><span class="line">	adminRouters.Use(middlewares.InitMiddleware) <span class="comment">//写法2</span></span><br><span class="line">  </span><br><span class="line">	{</span><br><span class="line">		adminRouters.GET(<span class="string">"/"</span>, admin.UserController{}.AdminFunc) <span class="comment">//这里不用加括号（只注册方法），加括号表示执行方法</span></span><br><span class="line">		adminRouters.GET(<span class="string">"/login"</span>, admin.UserController{}.AdminLogin)</span><br><span class="line"></span><br><span class="line">		adminRouters.GET(<span class="string">"/user"</span>, admin.UserController{}.Index)</span><br><span class="line">		adminRouters.GET(<span class="string">"/user/add"</span>, admin.UserController{}.Add)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>其他与写法1相同，终端输出顺序也和写法1输出相同。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h3 id="中间件和对应控制器之间共享数据">10.5.中间件和对应控制器之间共享数据</h3>
<p>使用 c.Set() 和 c.Get() 分别设置和获取值：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">c.Set(<span class="string">"username"</span>, <span class="string">"张三"</span>) <span class="comment">//中间件中设置值</span></span><br><span class="line">username, _ := c.Get(<span class="string">"username"</span>) <span class="comment">//控制器获取值，第一个返回值是 value（空接口类型），第二个返回值是布尔值</span></span><br></pre></td></tr></tbody></table></figure>
<p>在中间件文件 <code>middlewares/init.go</code> 中设置值：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitMiddleware</span><span class="params">(c *gin.Context)</span></span> { <span class="comment">//函数名首字母记得大写</span></span><br><span class="line">	fmt.Println(<span class="string">"我是初始中间件"</span>)</span><br><span class="line">	fmt.Println(c.Request.URL)</span><br><span class="line"></span><br><span class="line">	c.Set(<span class="string">"username"</span>, <span class="string">"张三"</span>) <span class="comment">//设置值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后在控制器文件 <code>controllers/userController.go</code> 中获取值输出：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con UserController)</span></span> Index(c *gin.Context) { <span class="comment">//改成结构体 UserController 的方法，便于实现继承</span></span><br><span class="line"></span><br><span class="line">	username, _ := c.Get(<span class="string">"username"</span>)</span><br><span class="line">	fmt.Println(username)</span><br><span class="line"></span><br><span class="line">	v, ok := username.(<span class="type">string</span>) <span class="comment">//类型断言</span></span><br><span class="line">	<span class="keyword">if</span> ok == <span class="literal">true</span> {</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"用户列表--"</span>+v)</span><br><span class="line">		con.success(c) <span class="comment">//使用继承的方法</span></span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		con.<span class="type">error</span>(c)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="中间件注意事项">10.6.中间件注意事项</h3>
<p><strong>gin</strong> <strong>默认中间件</strong></p>
<p>此前，我们一般会使用 <code>gin.Default()</code> 来创建一个默认路由引擎，<code>gin.Default()</code> 默认使用了 Logger 和 Recovery 中间件，其中：</p>
<p>• Logger 中间件将日志写入 gin.DefaultWriter，即使配置了 GIN_MODE=release。</p>
<p>• Recovery 中间件会 recover 任何 panic。如果有 panic 的话，会写入 500 响应码。</p>
<p>如果不想使用上面两个默认的中间件，可以使用 <strong>gin.New()</strong> 新建一个没有任何默认中间件的路由（不推荐）。</p>
<p><strong>gin</strong> <strong>中间件中使用</strong> <strong>goroutine</strong></p>
<p>当在中间件或 handler 中启动新的 goroutine 时，<strong>不能使用</strong>原始的上下文（<code>c *gin.Context</code>），必须使用其只读副本（<code>c.Copy()</code>）:</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitMiddleware</span><span class="params">(c *gin.Context)</span></span> { <span class="comment">//函数名首字母记得大写</span></span><br><span class="line">	fmt.Println(<span class="string">"我是初始中间件"</span>)</span><br><span class="line">	c.Set(<span class="string">"username"</span>, <span class="string">"张三"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义一个 gorutine 统计日志</span></span><br><span class="line">	cCp := c.Copy()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> { <span class="comment">//由于这里是中间件，所以不用担心主程序在协程执行完前退出</span></span><br><span class="line">		time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">		fmt.Println(<span class="string">"Done! in path"</span> + cCp.Request.URL.Path)</span><br><span class="line">	}()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="gin-中自定义-model">11.Gin 中自定义 Model</h2>
<p>如果我们的应用非常简单的话，我们可以在 Controller 里面处理常见的业务逻辑。但是如果我们有一个功能想在多个控制器、或者多个模板里面复用的话，那么我们就可以把公共的功能单独抽取出来作为一个<strong>模块（Model）</strong>。 Model 是逐步抽象的过程，一般我们会在 Model 里面封装一些公共的方法让不同 Controller 使用，也可以在 Model 中实现和数据库打交道。</p>
<p>如以下代码中的函数 <code>UnixToTime</code>:</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"test/routers"</span></span><br><span class="line">	<span class="string">"text/template"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMiddleware</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"我是全局中间件"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间戳转化为日期</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnixToTime</span><span class="params">(timestamp <span class="type">int</span>)</span></span> <span class="type">string</span> {</span><br><span class="line">	t := time.Unix(<span class="type">int64</span>(timestamp), <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> t.Format(<span class="string">"2006-01-02 15:04:05"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">//创建默认的路由引擎</span></span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自定义模板函数，主要要把这个函数放在加载模板前</span></span><br><span class="line">	router.SetFuncMap(template.FuncMap{</span><br><span class="line">		<span class="string">"UnixToTime"</span>: UnixToTime,</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">//加载模板，放在配置路由前面</span></span><br><span class="line">	router.LoadHTMLGlob(<span class="string">"templates/**/*"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载静态文件</span></span><br><span class="line">	router.Static(<span class="string">"/static"</span>, <span class="string">"./templates/static"</span>) <span class="comment">//第一个参数为网页路由，第二个参数为文件路径</span></span><br><span class="line"></span><br><span class="line">	router.Use(initMiddleware)</span><br><span class="line">	router.GET(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		fmt.Println(<span class="string">"home"</span>)</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"主页"</span>)</span><br><span class="line">	})</span><br><span class="line">	router.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		fmt.Println(<span class="string">"here"</span>)</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"这是默认页"</span>)</span><br><span class="line">	})</span><br><span class="line">	routers.AdminRoutersInit(router)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们如果要在多个模板和控制器中复用该函数，就可以将其抽象为一个 Model。新建文件 <code>models/tool.go</code>：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间戳转化为日期</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnixToTime</span><span class="params">(timestamp <span class="type">int</span>)</span></span> <span class="type">string</span> {</span><br><span class="line">	t := time.Unix(<span class="type">int64</span>(timestamp), <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> t.Format(<span class="string">"2006-01-02 15:04:05"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后在主函数中导入该 models 包即可：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"test/models"</span></span><br><span class="line">	<span class="string">"test/routers"</span></span><br><span class="line">	<span class="string">"text/template"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMiddleware</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"我是全局中间件"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">//创建默认的路由引擎</span></span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自定义模板函数，主要要把这个函数放在加载模板前</span></span><br><span class="line">	router.SetFuncMap(template.FuncMap{</span><br><span class="line">		<span class="string">"UnixToTime"</span>: models.UnixToTime,</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">//加载模板，放在配置路由前面</span></span><br><span class="line">	router.LoadHTMLGlob(<span class="string">"templates/**/*"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载静态文件</span></span><br><span class="line">	router.Static(<span class="string">"/static"</span>, <span class="string">"./templates/static"</span>) <span class="comment">//第一个参数为网页路由，第二个参数为文件路径</span></span><br><span class="line"></span><br><span class="line">	router.Use(initMiddleware)</span><br><span class="line">	router.GET(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		fmt.Println(<span class="string">"home"</span>)</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"主页"</span>)</span><br><span class="line">	})</span><br><span class="line">	router.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		fmt.Println(<span class="string">"here"</span>)</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"这是默认页"</span>)</span><br><span class="line">	})</span><br><span class="line">	routers.AdminRoutersInit(router)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在控制器和 HTML 模板中使用该自定义 models 的方法为：</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">控制器中</button><button type="button" class="tab " data-href="样例-2">HTML模板中</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><p>在控制器 <code>controllers/userController.go</code> 直接调用封装的 models 函数：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	...</span><br><span class="line">	<span class="string">"test/models"</span></span><br><span class="line">	...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con UserController)</span></span> AdminFunc(c *gin.Context) { </span><br><span class="line">	<span class="comment">//c.String(200, "管理员页面")</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(models.UnixToTime(<span class="type">int</span>(time.Now().Unix()))) <span class="comment">//直接在控制器中调用 models 函数</span></span><br><span class="line">	c.HTML(http.StatusOK, <span class="string">"default/index.html"</span>, gin.H{</span><br><span class="line">		<span class="string">"t"</span>: <span class="type">int</span>(time.Now().Unix()),</span><br><span class="line">	})</span><br><span class="line">	<span class="comment">//con.success(c) //使用继承的方法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><p>在控制器 <code>controllers/userController.go</code> 中调用 HTML 模板，并传入函数参数 <code>t</code>：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	...</span><br><span class="line">	<span class="string">"test/models"</span></span><br><span class="line">	...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con UserController)</span></span> AdminFunc(c *gin.Context) { <span class="comment">//改成结构体 UserController 的方法，便于实现继承</span></span><br><span class="line">	<span class="comment">//c.String(200, "管理员页面")</span></span><br><span class="line">	c.HTML(http.StatusOK, <span class="string">"default/index.html"</span>, gin.H{</span><br><span class="line">		<span class="string">"t"</span>: <span class="type">int</span>(time.Now().Unix()),</span><br><span class="line">	})</span><br><span class="line">	<span class="comment">//con.success(c) //使用继承的方法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在 HTML 模板文件 <code>templates/default/index.html</code> 中调用 model 函数如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">{{ define <span class="string">"default/index.html"</span> }}</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"IE=edge"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;首页&lt;/h1&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line"></span><br><span class="line">    现在的时间是：{{UnixToTime .t}}</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">{{end}}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h2 id="gin-文件上传">12.Gin 文件上传</h2>
<p><strong>注意</strong>：需要在上传文件的 form 表单上面需要加入 enctype="multipart/form-data"</p>
<h3 id="单文件上传">12.1.单文件上传</h3>
<blockquote>
<p>官方文档：https://gin-gonic.com/zh-cn/docs/examples/upload-file/single-file/</p>
<p></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//官方示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  router := gin.Default()</span><br><span class="line">  <span class="comment">// 为 multipart forms 设置较低的内存限制 (默认是 32 MiB)</span></span><br><span class="line">  router.MaxMultipartMemory = <span class="number">8</span> &lt;&lt; <span class="number">20</span>  <span class="comment">// 8 MiB</span></span><br><span class="line">  router.POST(<span class="string">"/upload"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">    <span class="comment">// 单文件</span></span><br><span class="line">    file, _ := c.FormFile(<span class="string">"file"</span>)</span><br><span class="line">    log.Println(file.Filename)</span><br><span class="line"></span><br><span class="line">    dst := <span class="string">"./"</span> + file.Filename</span><br><span class="line">    <span class="comment">// 上传文件至指定的完整文件路径</span></span><br><span class="line">    c.SaveUploadedFile(file, <span class="string">"./files/"</span> + file.Filename)</span><br><span class="line"></span><br><span class="line">    c.String(http.StatusOK, fmt.Sprintf(<span class="string">"'%s' uploaded!"</span>, file.Filename))</span><br><span class="line">  })</span><br><span class="line">  router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
</blockquote>
<p>1.定义 HTML 模板文件 <code>templates/admin/userAdd.html</code> 用于上传。<font color="#ef042a"><strong>需要在上传文件的 form 表单上面需要加入 <code>enctype="multipart/form-data"</code></strong></font>：</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">代码</button><button type="button" class="tab " data-href="样例-2">效果预览</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">{{ define "admin/userAdd.html" }} <span class="comment">&lt;!-- 相当于给模板定义一个名字 define end 成对出现--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>演示文件上传<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/admin/user/doUpload"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">        用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">placeholder</span>=<span class="string">"用户名"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        头 像<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"face"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span>    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">{{ end }}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><p><img src="/img/load5.gif" data-original="https://cdn.jsdelivr.net/gh/hahahaha5606/blogImage/images/image-20250530161951655.png" alt="image-20250530161951655" style="zoom:80%;"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<p>2.在控制器 <code>controllers/admin/userController.go</code> 中定义实现上传逻辑的函数：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con UserController)</span></span> Add(c *gin.Context) { </span><br><span class="line">	<span class="comment">//c.String(200, "用户列表-add")</span></span><br><span class="line">	c.HTML(http.StatusOK, <span class="string">"admin/userAdd.html"</span>, gin.H{})</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con UserController)</span></span> DoUpload(c *gin.Context) {</span><br><span class="line">	username := c.PostForm(<span class="string">"username"</span>)</span><br><span class="line">	file, err := c.FormFile(<span class="string">"face"</span>)</span><br><span class="line">	success := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// file.Filename 获取文件名称 aaa.jpg   ./static/upload/aaa.jpg</span></span><br><span class="line">	dst := path.Join(<span class="string">"./static/upload"</span>, file.Filename)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> {</span><br><span class="line">		c.SaveUploadedFile(file, dst)</span><br><span class="line">		success = <span class="literal">true</span></span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//c.String(200, "执行上传")</span></span><br><span class="line">	c.JSON(http.StatusOK, gin.H{</span><br><span class="line">		<span class="string">"success"</span>:  success,</span><br><span class="line">		<span class="string">"username"</span>: username,</span><br><span class="line">		<span class="string">"dst"</span>:      dst,</span><br><span class="line">	})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>3.在控制器对应的路由组 <code>routers/adminRouters.go</code> 中注册定义的逻辑函数方法：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AdminRoutersInit</span><span class="params">(r *gin.Engine)</span></span> {</span><br><span class="line">	adminRouters := r.Group(<span class="string">"/admin"</span>, middlewares.InitMiddleware)</span><br><span class="line">	{</span><br><span class="line">		...</span><br><span class="line">    adminRouters.GET(<span class="string">"/user/add"</span>, admin.UserController{}.Add)</span><br><span class="line">		adminRouters.POST(<span class="string">"/user/doUpload"</span>, admin.UserController{}.DoUpload) <span class="comment">// 定义的上传逻辑函数</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>4.在浏览器中访问路由 <code>http://localhost:8080/admin/user/add</code> 进行测试，提交文件后成功跳转界面 <code>http://localhost:8080/admin/user/doUpload</code> 并保存提交的文件到指定文件夹 <code>./static/upload</code> 中。</p>
<h3 id="多文件上传">12.2.多文件上传</h3>
<p>多文件上传分为 “文件名相同” 和 “文件名不同” 两种情况：</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">文件名不同</button><button type="button" class="tab " data-href="样例-2">文件名相同</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><p>步骤与单文件上传大致相同。</p>
<p>1.定义 HTML 模板文件 <code>templates/admin/userEdit.html</code> 用于上传。<font color="#ef042a"><strong>需要在上传文件的 form 表单上面需要加入 <code>enctype="multipart/form-data"</code></strong></font>：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">{{ define "admin/userEdit.html" }} <span class="comment">&lt;!-- 相当于给模板定义一个名字 define end 成对出现--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>演示不同名的多文件上传<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/admin/user/doEdit"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">placeholder</span>=<span class="string">"用户名"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        头 像1:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"face1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        头 像2:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"face2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">{{ end }}</span><br></pre></td></tr></tbody></table></figure>
<p>2.在控制器 <code>controllers/admin/userController.go</code> 中定义实现上传逻辑的函数：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 多文件上传--不同文件名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con UserController)</span></span> Edit(c *gin.Context) {</span><br><span class="line">	c.HTML(http.StatusOK, <span class="string">"admin/userEdit.html"</span>, gin.H{})</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con UserController)</span></span> DoEdit(c *gin.Context) {</span><br><span class="line">	username := c.PostForm(<span class="string">"username"</span>)</span><br><span class="line">	file1, err1 := c.FormFile(<span class="string">"face1"</span>)</span><br><span class="line">	file2, err2 := c.FormFile(<span class="string">"face2"</span>)</span><br><span class="line">	success := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// file.Filename 获取文件名称 aaa.jpg   ./static/upload/aaa.jpg</span></span><br><span class="line">	dst1 := path.Join(<span class="string">"./static/upload"</span>, file1.Filename)</span><br><span class="line">	dst2 := path.Join(<span class="string">"./static/upload"</span>, file2.Filename)</span><br><span class="line">	<span class="keyword">if</span> err1 == <span class="literal">nil</span> &amp;&amp; err2 == <span class="literal">nil</span> {</span><br><span class="line">		c.SaveUploadedFile(file1, dst1)</span><br><span class="line">		c.SaveUploadedFile(file2, dst2)</span><br><span class="line">		success = <span class="literal">true</span></span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//c.String(200, "执行上传")</span></span><br><span class="line">	c.JSON(http.StatusOK, gin.H{</span><br><span class="line">		<span class="string">"success"</span>:  success,</span><br><span class="line">		<span class="string">"username"</span>: username,</span><br><span class="line">		<span class="string">"dst1"</span>:     dst1,</span><br><span class="line">		<span class="string">"dst2"</span>:     dst2,</span><br><span class="line">	})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>3.在控制器对应的路由组 <code>routers/adminRouters.go</code> 中注册定义的逻辑函数方法：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AdminRoutersInit</span><span class="params">(r *gin.Engine)</span></span> {</span><br><span class="line">	adminRouters := r.Group(<span class="string">"/admin"</span>, middlewares.InitMiddleware)</span><br><span class="line">	{</span><br><span class="line">		...</span><br><span class="line">		adminRouters.GET(<span class="string">"/user/edit"</span>, admin.UserController{}.Edit)</span><br><span class="line">		adminRouters.POST(<span class="string">"user/doEdit"</span>, admin.UserController{}.DoEdit) <span class="comment">// 定义的上传逻辑函数</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>4.在浏览器中访问路由 <code>http://localhost:8080/admin/user/edit</code> 进行测试，提交文件后成功跳转界面 <code>http://localhost:8080/admin/user/doEdit</code> 并保存提交的文件到指定文件夹 <code>./static/upload</code> 中。</p></div><div class="tab-item-content" id="样例-2"><blockquote>
<p>官方文档：<a target="_blank" rel="noopener" href="https://gin-gonic.com/zh-cn/docs/examples/upload-file/multiple-file/">多文件 | Gin Web Framework</a></p>
<p></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">  router := gin.Default()</span><br><span class="line">  <span class="comment">// 为 multipart forms 设置较低的内存限制 (默认是 32 MiB)</span></span><br><span class="line">  router.MaxMultipartMemory = <span class="number">8</span> &lt;&lt; <span class="number">20</span>  <span class="comment">// 8 MiB</span></span><br><span class="line">  router.POST(<span class="string">"/upload"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">    <span class="comment">// 这里要用 Multipart form</span></span><br><span class="line">    form, _ := c.MultipartForm()</span><br><span class="line">    files := form.File[<span class="string">"upload[]"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, file := <span class="keyword">range</span> files {</span><br><span class="line">      log.Println(file.Filename)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 上传文件至指定目录</span></span><br><span class="line">      c.SaveUploadedFile(file, <span class="string">"./files/"</span> + file.Filename)</span><br><span class="line">    }</span><br><span class="line">    c.String(http.StatusOK, fmt.Sprintf(<span class="string">"%d files uploaded!"</span>, <span class="built_in">len</span>(files)))</span><br><span class="line">  })</span><br><span class="line">  router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
</blockquote>
<p>相同名多文件上传除控制器中的业务逻辑函数与不同名多文件上传有差别外，其它文件与实现均一致。相同名多文件上传中控制器 <code>controllers/admin/userController.go</code> 定义实现上传逻辑的函数：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 多文件上传--相同文件名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con UserController)</span></span> Edit(c *gin.Context) { <span class="comment">//不变</span></span><br><span class="line">	c.HTML(http.StatusOK, <span class="string">"admin/userEdit.html"</span>, gin.H{})</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con UserController)</span></span> DoEdit(c *gin.Context) {</span><br><span class="line">	username := c.PostForm(<span class="string">"username"</span>)</span><br><span class="line"></span><br><span class="line">	form, _ := c.MultipartForm()</span><br><span class="line">	files := form.File[<span class="string">"face[]"</span>]</span><br><span class="line">	success := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, file := <span class="keyword">range</span> files {</span><br><span class="line">		dst := path.Join(<span class="string">"./static/upload"</span>, file.Filename)</span><br><span class="line">		<span class="comment">// 保存上传的文件至指定目录</span></span><br><span class="line">		c.SaveUploadedFile(file, dst)</span><br><span class="line">	}</span><br><span class="line">	success = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	c.JSON(http.StatusOK, gin.H{</span><br><span class="line">		<span class="string">"success"</span>:  success,</span><br><span class="line">		<span class="string">"username"</span>: username,</span><br><span class="line">	})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h2 id="gin-中的-cookie">13.Gin 中的 Cookie</h2>
<p>● HTTP 是无状态协议。简单地说，当你浏览了一个页面，然后转到同一个网站的另一个页面，服务器无法认识到这是同一个浏览器在访问同一个网站。每一次的访问，都是没有任何关系的。如果我们要实现<strong>多个页面之间共享数据</strong>的话我们就可以使用 Cookie 或者 Session 实现。</p>
<p>● <strong>Cookie</strong> 是<strong>存储于访问者计算机的浏览器</strong>中。可以让我们用同一个浏览器访问同一个域名的时候共享数据。Cookie 能实现：</p>
<p>​ 1、保持用户登录状态</p>
<p>​ 2、保存用户浏览的历史记录</p>
<p>​ 3、猜你喜欢，智能推荐</p>
<p>​ 4、电商网站的加入购物车</p>
<h3 id="设置和获取-cookie">13.1.设置和获取 Cookie</h3>
<blockquote>
<p>官方文档：https://gin-gonic.com/zh-cn/docs/examples/cookie/</p>
</blockquote>
<p><strong>设置 Cookie 的格式为</strong>：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">c.SetCookie(name, value <span class="type">string</span>, maxAge <span class="type">int</span>, path, domain <span class="type">string</span>, secure, httpOnly <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一个参数 key</span></span><br><span class="line"><span class="comment">第二个参数 value</span></span><br><span class="line"><span class="comment">第三个参数 过期时间(秒).如果只想设置 Cookie 的保存路径而不想设置存活时间，可以在第三个参数中传递 nil</span></span><br><span class="line"><span class="comment">第四个参数 cookie 的路径</span></span><br><span class="line"><span class="comment">第五个参数 cookie 的路径 Domain 作用域 本地调试配置成 localhost , 正式上线配置成域名</span></span><br><span class="line"><span class="comment">第六个参数是 secure ，当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效</span></span><br><span class="line"><span class="comment">第七个参数 httpOnly，是微软对 COOKIE 做的扩展。如果在 COOKIE 中设置了“httpOnly”属性，则通过程序（JS 脚本、applet 等）将无法读取到 COOKIE 信息，防止 XSS 攻击产生</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>获取 Cookie 的格式为</strong>：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">cookie, err := c.Cookie(<span class="string">"name"</span>)</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>也可以在浏览器中按 F12 键检查 Cookie。</p>
</blockquote>
<p>在控制器中设置Cookie的代码如下：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con UserController)</span></span> AdminLogin(c *gin.Context) { <span class="comment">//改成结构体 UserController 的方法，便于实现继承</span></span><br><span class="line">	<span class="comment">//设置cookie</span></span><br><span class="line">	c.SetCookie(<span class="string">"username"</span>, <span class="string">"张三"</span>, <span class="number">3600</span>, <span class="string">"/"</span>, <span class="string">"localhost"</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">	c.String(<span class="number">200</span>, <span class="string">"管理员登录界面"</span>)</span><br><span class="line">	con.success(c) <span class="comment">//使用继承的方法</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con UserController)</span></span> AdminGGetLogin(c *gin.Context) { <span class="comment">//改成结构体 UserController 的方法，便于实现继承</span></span><br><span class="line">	<span class="comment">//其他页面获取cookie</span></span><br><span class="line">	username, _ := c.Cookie(<span class="string">"username"</span>)</span><br><span class="line">	c.String(<span class="number">200</span>, <span class="string">"cookie="</span>+username)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(con UserController)</span></span> DeleteCookie(c *gin.Context) { <span class="comment">//改成结构体 UserController 的方法，便于实现继承</span></span><br><span class="line">	<span class="comment">//删除cookie，第三个参数为负数表示删除cookie</span></span><br><span class="line">	c.SetCookie(<span class="string">"username"</span>, <span class="string">"张三"</span>, <span class="number">-1</span>, <span class="string">"/"</span>, <span class="string">"localhost"</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">	c.String(<span class="number">200</span>, <span class="string">"cookie 删除成功"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="多个二级域名共享-cookie">13.2.多个二级域名共享 Cookie</h3>
<p>有时候我们希望用户在 a.itying.com 中设置 Cookie 信息后在 b.itying.com 中获取刚才设置的cookie，也就是实现多个二级域名共享 cookie（如在 a.itying.com 中登录之后，希望在 b.itying.com 也保持登录状态）。</p>
<p>这时候的话我们就可以这样设置 cookie：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">c.SetCookie(<span class="string">"usrename"</span>, <span class="string">"张三"</span>, <span class="number">3600</span>, <span class="string">"/"</span>, <span class="string">".itying.com"</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="gin-中的-session">14.Gin 中的 Session</h2>
<p>session 是另一种记录客户状态的机制，不同的是 Cookie 保存在客户端浏览器中，而 session保存在<strong>服务器</strong>上。</p>
<p>当客户端浏览器第一次访问服务器并发送请求时，服务器端会创建一个 session 对象，生成一个类似于 key,value 的键值对，然后将 value 保存到服务器 将 key(cookie)返回到浏览器(客户)端。浏览器下次访问时会携带 key(cookie)，找到对应的 session(value)。</p>
<p>Gin 官方没有给我们提供 Session 相关的文档，这个时候我们可以使用第三方的 Session 中间件（https://github.com/gin-contrib/sessions）来实现。gin-contrib/sessions 中间件支持的存储引擎：</p>
<p>• cookie</p>
<p>• memstore</p>
<p>• redis</p>
<p>• memcached</p>
<p>• mongodb</p>
<p>下面列举了两种存储 Session 的不同方式：</p>
<div class="tabs" id="样例"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="样例-1">基于Cookie 存储 Session</button><button type="button" class="tab " data-href="样例-2">基于 Redis 存储 Session</button></ul><div class="tab-contents"><div class="tab-item-content active" id="样例-1"><p>1.安装 Session 包</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">go get github.com/gin-contrib/sessions</span><br></pre></td></tr></tbody></table></figure>
<p>2.基本的 Session 用法</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"test/models"</span></span><br><span class="line">	<span class="string">"test/routers"</span></span><br><span class="line">	<span class="string">"text/template"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-contrib/sessions"</span></span><br><span class="line">	<span class="string">"github.com/gin-contrib/sessions/cookie"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMiddleware</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"我是全局中间件"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">//创建默认的路由引擎</span></span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自定义模板函数，主要要把这个函数放在加载模板前</span></span><br><span class="line">	router.SetFuncMap(template.FuncMap{</span><br><span class="line">		<span class="string">"UnixToTime"</span>: models.UnixToTime,</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">//加载模板，放在配置路由前面</span></span><br><span class="line">	router.LoadHTMLGlob(<span class="string">"templates/**/*"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载静态文件</span></span><br><span class="line">	router.Static(<span class="string">"/static"</span>, <span class="string">"./templates/static"</span>) <span class="comment">//第一个参数为网页路由，第二个参数为文件路径</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//配置session中间件</span></span><br><span class="line">	<span class="comment">// 创建基于 cookie 的存储引擎，secret11111 参数是用于加密的密钥</span></span><br><span class="line">	store := cookie.NewStore([]<span class="type">byte</span>(<span class="string">"secret11111"</span>))</span><br><span class="line">	<span class="comment">// 设置 session 中间件，参数 mysession 是 session 的名字，也是 cookie 的名字</span></span><br><span class="line">	<span class="comment">// store 是前面创建的存储引擎，我们可以替换成其他存储引擎</span></span><br><span class="line">	router.Use(sessions.Sessions(<span class="string">"mysession"</span>, store))</span><br><span class="line"></span><br><span class="line">	router.Use(initMiddleware)</span><br><span class="line">	router.GET(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		<span class="comment">//设置 sessions (这一步在控制器中也可以做，这里写是为了演示方便)</span></span><br><span class="line">		session := sessions.Default(c)</span><br><span class="line">		session.Set(<span class="string">"username"</span>, <span class="string">"张三"</span>)</span><br><span class="line">		session.Save() <span class="comment">//这一步保存必不可少</span></span><br><span class="line"></span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"主页"</span>)</span><br><span class="line">	})</span><br><span class="line">	router.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		<span class="comment">//获取sessions</span></span><br><span class="line">		session := sessions.Default(c)</span><br><span class="line">		username := session.Get(<span class="string">"username"</span>)</span><br><span class="line"></span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"这是默认页, username=%v"</span>, username)</span><br><span class="line">	})</span><br><span class="line">	routers.AdminRoutersInit(router)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-item-content" id="样例-2"><p>如果我们想将 session 数据保存到 redis 中（适用于在分布式架构，访问不同服务器时想实现负载均衡，共享session的场景），只要将 session 的存储引擎改成 redis 即可。</p>
<blockquote>
<p>保证电脑上已经安装了 Redis：在终端输入 <code>redis-cli</code> 查看输出即可。</p>
<p>如果没有安装，Windows 系统访问 https://github.com/tporadowski/redis/releases，下载 msi 安装包安装。</p>
</blockquote>
<p>1.首先安装 redis 存储引擎的包：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">go get github.com/gin-contrib/sessions/redis</span><br></pre></td></tr></tbody></table></figure>
<p>2.基于 Redis存储 Session：</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"test/models"</span></span><br><span class="line">	<span class="string">"test/routers"</span></span><br><span class="line">	<span class="string">"text/template"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-contrib/sessions"</span></span><br><span class="line">	<span class="string">"github.com/gin-contrib/sessions/redis"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initMiddleware</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">	fmt.Println(<span class="string">"我是全局中间件"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">//创建默认的路由引擎</span></span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自定义模板函数，主要要把这个函数放在加载模板前</span></span><br><span class="line">	router.SetFuncMap(template.FuncMap{</span><br><span class="line">		<span class="string">"UnixToTime"</span>: models.UnixToTime,</span><br><span class="line">	})</span><br><span class="line"></span><br><span class="line">	<span class="comment">//加载模板，放在配置路由前面</span></span><br><span class="line">	router.LoadHTMLGlob(<span class="string">"templates/**/*"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载静态文件</span></span><br><span class="line">	router.Static(<span class="string">"/static"</span>, <span class="string">"./templates/static"</span>) <span class="comment">//第一个参数为网页路由，第二个参数为文件路径</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//配置session中间件</span></span><br><span class="line">	<span class="comment">// 参数说明：</span></span><br><span class="line">	<span class="comment">// 第 1 个参数 - redis 最大的空闲连接数</span></span><br><span class="line">	<span class="comment">// 第 2 个参数 - 数通信协议 tcp 或者 udp</span></span><br><span class="line">	<span class="comment">// 第 3 个参数 - redis 地址, 格式，host:port</span></span><br><span class="line">	<span class="comment">// 第 4 个参数 - redis 密码</span></span><br><span class="line">	<span class="comment">// 第 5 个参数 - session 加密密钥</span></span><br><span class="line">	store, _ := redis.NewStore(<span class="number">10</span>, <span class="string">"tcp"</span>, <span class="string">"localhost:6379"</span>, <span class="string">""</span>, <span class="string">"secret"</span>)</span><br><span class="line">	router.Use(sessions.Sessions(<span class="string">"mysession"</span>, store))</span><br><span class="line"></span><br><span class="line">	router.Use(initMiddleware)</span><br><span class="line">	router.GET(<span class="string">"/home"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		<span class="comment">//设置 sessions (这一步在控制器中也可以做，这里写是为了演示方便)</span></span><br><span class="line">		session := sessions.Default(c)</span><br><span class="line">		session.Options(sessions.Options{ <span class="comment">//session 的过期时间</span></span><br><span class="line">			MaxAge: <span class="number">3600</span> * <span class="number">6</span>, <span class="comment">//6h  MaxAge 单位是秒</span></span><br><span class="line">		})</span><br><span class="line">		session.Set(<span class="string">"username"</span>, <span class="string">"张三"</span>)</span><br><span class="line">		session.Save() <span class="comment">//这一步保存必不可少</span></span><br><span class="line"></span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"主页"</span>)</span><br><span class="line">	})</span><br><span class="line">	router.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br><span class="line">		<span class="comment">//获取sessions</span></span><br><span class="line">		session := sessions.Default(c)</span><br><span class="line">		username := session.Get(<span class="string">"username"</span>)</span><br><span class="line"></span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"这是默认页, username=%v"</span>, username)</span><br><span class="line">	})</span><br><span class="line">	routers.AdminRoutersInit(router)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听并在 0.0.0.0:8080 上启动服务</span></span><br><span class="line">	router.Run(<span class="string">":8080"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>测试代码时可以在 redis 数据库中查看 session。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>
<h1 id="五gin-中使用-gorm-操作-mysql-数据库">五、Gin 中使用 GORM 操作 MySQL 数据库</h1>
<p>GORM 是 Golang 的一个 orm 框架。简单说，ORM 就是通过实例对象的语法，完成关系型数据库的操作的技术，是"对象-关系映射"（Object/Relational Mapping） 的缩写。使用 ORM框架可以让我们更方便的操作数据库。</p>
<p>六、Go 微服务</p>
<h1 id="参考链接">参考链接</h1>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Rm421N7Jy/?spm_id_from=333.337.search-card.all.click&amp;vd_source=124ec79ebd3e16b0f454a3994a468f98">【2025年新版】Go语言教程_Golang入门实战全套视频教程_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39805338/article/details/80810379">HTTP协议、URL、URI、请求响应—讲解很详细_url请求-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013257679/article/details/52235204">URL和URI区别以及相对路径和绝对路径_fileurl绝对路径-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38120321">URL与URI，有联系有区别？ - 知乎</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">胖胖大藕片</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/05/14/go%20%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/">http://example.com/2025/05/14/go 语言开发/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">藕片种植基地</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BB%A3%E7%A0%81%E7%AE%B1/">代码箱</a><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A0%81/">编码</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/hahahaha5606/blogImage/post_img/20231125235054.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/load1.gif" data-original="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/load2.gif" data-original="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/05/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" title="排序算法"><img class="cover" src="/img/load2.gif" data-original="https://cdn.jsdelivr.net/gh/hahahaha5606/blogImage/images/hexue.jpg" onerror="onerror=null;src='/img/problem.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">排序算法</div></div></a></div><div class="next-post pull-right"><a href="/2025/05/09/Git%20%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/" title="Git 记录"><img class="cover" src="/img/load5.gif" data-original="https://cdn.jsdelivr.net/gh/hahahaha5606/blogImage/post_img/20231125235032.jpg" onerror="onerror=null;src='/img/problem.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Git 记录</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/01/08/CUDA%E5%92%8CC++%E6%B7%B7%E5%90%88%E5%8A%A0%E9%80%9F%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/" title="CUDA和C++混合双打"><img class="cover" src="/img/load4.gif" data-original="https://cdn.jsdelivr.net/gh/hahahaha5606/blogImage/post_img/20231125235204.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-08</div><div class="title">CUDA和C++混合双打</div></div></a></div><div><a href="/2025/06/02/Docker%20%E6%95%99%E7%A8%8B/" title="Docker 教程"><img class="cover" src="/img/load5.gif" data-original="https://cdn.jsdelivr.net/gh/hahahaha5606/blogImage/images/hexue.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-02</div><div class="title">Docker 教程</div></div></a></div><div><a href="/2025/07/29/MySQL%20%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86/" title="MySQL 常用知识"><img class="cover" src="/img/load3.gif" data-original="https://cdn.jsdelivr.net/gh/hahahaha5606/blogImage/images/sonnnwwww.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-29</div><div class="title">MySQL 常用知识</div></div></a></div><div><a href="/2025/05/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" title="排序算法"><img class="cover" src="/img/load3.gif" data-original="https://cdn.jsdelivr.net/gh/hahahaha5606/blogImage/images/hexue.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-15</div><div class="title">排序算法</div></div></a></div><div><a href="/2024/10/15/%E6%9B%B2%E7%8E%87%E3%80%81%E6%9B%B2%E7%8E%87%E5%8D%8A%E5%BE%84%E4%B8%8E%E6%9B%B2%E7%8E%87%E5%9C%86/" title="曲率、曲率半径与曲率圆"><img class="cover" src="/img/load5.gif" data-original="https://cdn.jsdelivr.net/gh/hahahaha5606/blogImage/images/hexue.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-15</div><div class="title">曲率、曲率半径与曲率圆</div></div></a></div><div><a href="/2024/12/06/%E6%B1%82%E4%B8%8D%E8%A7%84%E5%88%99%E5%9B%BE%E5%BD%A2%E7%9A%84%E5%87%A0%E4%BD%95%E5%8F%82%E6%95%B0/" title="求不规则图形的几何参数"><img class="cover" src="/img/load1.gif" data-original="https://cdn.jsdelivr.net/gh/hahahaha5606/blogImage/post_img/20231125235054.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-06</div><div class="title">求不规则图形的几何参数</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E7%AE%80%E4%BB%8B%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-text">一、简介与环境搭建</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">二、基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-text">1.变量声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-text">2.常量声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E8%AF%AD%E5%8F%A5"><span class="toc-text">3.打印语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B"><span class="toc-text">4.1.整型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-text">4.2.浮点型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%9E%8B"><span class="toc-text">4.3.布尔型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">4.4.字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#go-%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-text">4.4.1.Go 语言字符串中的字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-text">4.4.2.字符串的修改</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">4.5.数据类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">5.运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">6.流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-if-else"><span class="toc-text">6.1.分支结构 if else</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84-for"><span class="toc-text">6.2.循环结构 for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E5%80%BC%E5%BE%AA%E7%8E%AF-for-range"><span class="toc-text">6.3.键值循环 for range</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF-switch-case"><span class="toc-text">6.4.条件分支 switch case</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E5%87%BA%E5%BE%AA%E7%8E%AF-break"><span class="toc-text">6.5.跳出循环 break</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E7%BB%AD%E4%B8%8B%E6%AC%A1%E5%BE%AA%E7%8E%AF-continue"><span class="toc-text">6.6.继续下次循环 continue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E5%88%B0%E6%8C%87%E5%AE%9A%E6%A0%87%E7%AD%BE-goto"><span class="toc-text">6.7.跳转到指定标签 goto</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-array"><span class="toc-text">7.数组 Array</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">7.1.数组的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%98%AF%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-text">7.2.数组是值类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">7.3.多维数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E7%89%87-slice"><span class="toc-text">8.切片 Slice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">8.1.切片的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E9%95%BF%E5%BA%A6%E5%92%8C%E5%AE%B9%E9%87%8F"><span class="toc-text">8.2.切片的长度和容量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E5%88%87%E7%89%87%E5%85%83%E7%B4%A0-append"><span class="toc-text">8.3.增加切片元素 append()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%88%87%E7%89%87-copy"><span class="toc-text">8.4.复制切片 copy()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%88%87%E7%89%87%E5%85%83%E7%B4%A0"><span class="toc-text">8.5.删除切片元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-text">9.数组和切片的排序？？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%E5%80%BC%E5%AF%B9-map"><span class="toc-text">10.键值对 map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-func"><span class="toc-text">11.函数 func</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%98%E9%87%8F"><span class="toc-text">11.1.函数类型与变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-text">11.2.高阶函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-text">11.3.匿名函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-text">11.4.闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defer-%E8%AF%AD%E5%8F%A5"><span class="toc-text">11.5.defer 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-text">11.6.常见内置函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#time-%E5%8C%85%E5%8F%8A%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-text">12.time 包及日期函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-text">13.指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">14.结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">14.1.结构体的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">14.2.结构体实例化的几种方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95%E5%92%8C%E6%8E%A5%E6%94%B6%E8%80%85"><span class="toc-text">14.3.结构体方法和接收者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5"><span class="toc-text">14.4.结构体的匿名字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">14.5.嵌套结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-text">14.6.结构体的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C-json-%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-text">14.7.结构体和 JSON 相互转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-interface"><span class="toc-text">15.接口 interface</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3"><span class="toc-text">15.1.空接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-text">15.2.类型断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85%E6%88%96%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">15.3.结构体的方法是值接收者或指针接收者实现接口的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="toc-text">15.4.一个结构体实现多个接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97"><span class="toc-text">15.5.接口嵌套</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-text">16.并发和并行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-text">16.1.进程和线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C-1"><span class="toc-text">16.2.并发和并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8Bgoroutine"><span class="toc-text">16.3.主线程和协程（goroutine）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#goroutine-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C-sync.waitgroup"><span class="toc-text">16.4.Goroutine 的使用和 sync.WaitGroup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%B9%B6%E8%A1%8C%E6%97%B6%E5%8D%A0%E7%94%A8-cpu-%E6%95%B0%E9%87%8F"><span class="toc-text">16.5.设置并行时占用 CPU 数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81"><span class="toc-text">16.6.并发安全和锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#recover-%E8%A7%A3%E5%86%B3%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84-panic"><span class="toc-text">16.7.Recover 解决协程中出现的 Panic</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E9%81%93-channel"><span class="toc-text">17.管道 Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">17.1.管道的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">17.2.管道的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E9%98%BB%E5%A1%9E"><span class="toc-text">17.3.管道阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#goroutine-%E4%B8%8E-channnel-%E7%BB%93%E5%90%88"><span class="toc-text">17.4.Goroutine 与 Channnel 结合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E7%AE%A1%E9%81%93"><span class="toc-text">17.5.单向管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-select"><span class="toc-text">17.5.多路复用 select</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-text">18.反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#reflect.typeof-%E8%8E%B7%E5%8F%96%E4%BB%BB%E6%84%8F%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-text">18.1.reflect.TypeOf() 获取任意值的类型对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reflect.valueof-%E8%8E%B7%E5%8F%96%E4%BB%BB%E6%84%8F%E5%AF%B9%E8%B1%A1%E5%80%BC"><span class="toc-text">18.2.reflect.ValueOf() 获取任意对象值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E4%BF%AE%E6%94%B9%E5%8F%98%E9%87%8F%E5%80%BC"><span class="toc-text">18.3.通过反射修改变量值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">18.4.反射与结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6-%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C"><span class="toc-text">19.文件 目录操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6-%E7%9B%AE%E5%BD%95%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">19.1.文件 目录基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-text">19.2.读取文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5"><span class="toc-text">19.3.文件写入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89go-%E4%B8%AD%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86"><span class="toc-text">三、Go 中的包管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#go-mod-%E6%8C%87%E4%BB%A4%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE"><span class="toc-text">1.go mod 指令管理项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#golang-%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85"><span class="toc-text">2.Golang 中自定义包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#golang-%E4%B8%AD-init-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="toc-text">3.Golang 中 init() 初始化函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#golang-%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85"><span class="toc-text">4.Golang 中使用第三方包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9Bgin-%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91"><span class="toc-text">四、Gin 框架开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#gin-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-text">1.Gin 环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%83%AD%E5%8A%A0%E8%BD%BD"><span class="toc-text">2.Go 程序的热加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gin-%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E8%B7%AF%E7%94%B1"><span class="toc-text">3.Gin 框架中的路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E7%9A%84%E4%B8%8D%E5%90%8C%E6%96%B9%E6%B3%95"><span class="toc-text">4.响应客户端请求的不同方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gin-html-%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93"><span class="toc-text">5.Gin HTML 模板渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gin-%E6%A8%A1%E6%9D%BF%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">5.1.Gin 模板基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97-template"><span class="toc-text">5.2.嵌套 template</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1"><span class="toc-text">6.静态文件服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E8%AF%A6%E8%A7%A3"><span class="toc-text">7.路由详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#get-post-%E4%BB%A5%E5%8F%8A%E8%8E%B7%E5%8F%96-get-post-%E4%BC%A0%E5%80%BC"><span class="toc-text">7.1.GET POST 以及获取 GET POST 传值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-get-post-%E4%BC%A0%E9%80%92%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%88%B0%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">7.2.获取 GET POST 传递的数据绑定到结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-post-xml-%E6%95%B0%E6%8D%AE"><span class="toc-text">7.3.获取 POST XML 数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%BB%84"><span class="toc-text">8.路由组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gin-%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-text">9.Gin 中自定义控制器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gin-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">10.Gin 中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c.next-%E8%B0%83%E7%94%A8%E8%AF%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E5%89%A9%E4%BD%99%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-text">10.1. c.Next() 调用该请求的剩余处理程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c.abort-%E4%BA%86%E8%A7%A3"><span class="toc-text">10.2. c.Abort() （了解）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">10.3.全局中间件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E8%B7%AF%E7%94%B1%E7%BB%84%E9%85%8D%E7%BD%AE%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">10.4.为路由组配置中间件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%92%8C%E5%AF%B9%E5%BA%94%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="toc-text">10.5.中间件和对应控制器之间共享数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">10.6.中间件注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gin-%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89-model"><span class="toc-text">11.Gin 中自定义 Model</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gin-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-text">12.Gin 文件上传</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-text">12.1.单文件上传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-text">12.2.多文件上传</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gin-%E4%B8%AD%E7%9A%84-cookie"><span class="toc-text">13.Gin 中的 Cookie</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%8E%B7%E5%8F%96-cookie"><span class="toc-text">13.1.设置和获取 Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%E5%85%B1%E4%BA%AB-cookie"><span class="toc-text">13.2.多个二级域名共享 Cookie</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gin-%E4%B8%AD%E7%9A%84-session"><span class="toc-text">14.Gin 中的 Session</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94gin-%E4%B8%AD%E4%BD%BF%E7%94%A8-gorm-%E6%93%8D%E4%BD%9C-mysql-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">五、Gin 中使用 GORM 操作 MySQL 数据库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">参考链接</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">©2023 - 2025  <i id="heartbeat" class="fa fas fa-heartbeat"></i> 胖胖大藕片</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><p id="ghbdages"></p></div></footer></div><div id="rightside"><!--这样修改较麻烦，不如直接修改"F:\Blog\themes\butterfly\source\css\_layout\rightside.styl"中的逻辑，将其取反，即可默认显示全部按钮，且点击后隐藏--><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'ybVvPd5f8ymUrtyDgiPIcU3E-gzGzoHsz',
      appKey: 'P08uK63s8SFzZd9oN7vr8tmn',
      avatar: 'monsterid',
      serverURLs: 'https://ybvvpd5f.lc-cn-n1-shared.com',
      emojiMaps: "",
      master: 'cda7cc5c3b41c1ce1e80dade99393150',   //博主邮箱md5加密32位小写
      tagMeta: ["博主","小伙伴","访客"],     //标识字段名
      friends:  [],  //小伙伴邮箱Md5
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('/js/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="/img/load4.gif" data-original="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=monsterid'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://ybvvpd5f.lc-cn-n1-shared.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'ybVvPd5f8ymUrtyDgiPIcU3E-gzGzoHsz',
        "X-LC-Key": 'P08uK63s8SFzZd9oN7vr8tmn',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script src="https://libs.baidu.com/jquery/2.1.4/jquery.min.js"></script><script src="/js/crash_cheat.js"></script><script src="/js/heartbeat.js"></script><script src="/js/showAppreciation.js"></script><script src="/js/timing.js"></script><script src="/js/sun_moon.js" async=""></script><script defer="" src="https://rmt.dogedoge.com/fetch/~/source/jsdelivr/npm/jquery@latest/dist/jquery.min.js"></script><script defer="" data-pjax="" src="https://cdn.jsdelivr.net/gh/sirxemic/jquery.ripples/dist/jquery.ripples.js"></script><script defer="" data-pjax="" src="/js/ripples.js"></script><script async="" data-pjax="" src="/js/anzhiyu.js"></script><script async="" data-pjax="" src="/js/anzhiyufunction.js"></script><script async="" src="/js/anzhiyuOnlyOne.js"></script><script type="text/javascript" src="/js/szgotop.js"></script><script src="/js/perfectscrollbar.min.js"></script><script src="/js/table_scrollbar.js"></script><script src="/js/hexo_githubcalendar.js"></script><script src="/js/load_book.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,爱国,敬业,诚信,友善,自由,平等,公正,法治" data-fontsize="15px" data-random="true" async="async"></script><link rel="stylesheet" href="/css/Aplayer.min.css" media="print" onload="this.media='all'"><script src="/js/Aplayer.min.js"></script><script src="/js/Meting2.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  //document.querySelectorAll('script[data-pjax]').forEach(item => {
  document.querySelectorAll('script[data-pjax], .pjax-reload script').forEach(*item* *=>* {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><div class="pjax-reload"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__fadeInLeft');
    arr[i].setAttribute('data-wow-duration', '600ms');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__fadeInRightBig');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer="defer" src="https://cdn.jsdelivr.net/gh/graingert/wow@1.3.0/dist/wow.min.js"></script><script defer="defer" src="/js/wow_init.js"></script></div><div id="nav-music"><div id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()">播放音乐</div><!--meting-js#8152976493(server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random") 安知鱼歌单--><meting-js id="12389320665" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"> </meting-js><!-- 我的网易云歌单--></div><!-- hexo injector body_end start -->
  <script data-pjax="" src="/js/hexo_githubcalendar.js"></script>
  <script data-pjax="">
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://githubcalendarapi.shiguang666.eu.org/api?user=hahahaha5606";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="hahahaha5606";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item github_calendar" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log("已挂载hexo-github-calendar https://github.com/Barry-Flynn/hexo-github-calendar");
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><script data-pjax="">
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo" title=""><img src="/img/load5.gif" data-original="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly" title=""><img src="/img/load3.gif" data-original="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" data-title="本站使用JsDelivr为静态资源提供CDN加速" title=""><img src="/img/load1.gif" data-original="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用双线部署，默认线路托管于Vercel" title=""><img src="/img/load1.gif" data-original="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用双线部署，联通线路托管于Coding" title=""><img src="/img/load5.gif" data-original="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&amp;logo=Codio" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Gtihub托管" title=""><img src="/img/load4.gif" data-original="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="/img/load1.gif" data-original="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async="" src="/js/runtime_huibiao.js"></script><!-- hexo injector body_end end -->
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script><script src="https://cdn.jsdelivr.net/npm/live2d-widget@^3.0.5/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"superSample":2,"position":"right","width":300,"height":600,"hOffset":45,"vOffset":-150},"mobile":{"show":false,"scale":1},"react":{"opacityDefault":0.3,"opacityOnHover":0.3,"opacity":0.95},"log":false});</script></body></html>